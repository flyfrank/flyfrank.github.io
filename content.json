{"meta":{"title":"mpoom blog","subtitle":null,"description":null,"author":"huyaoke","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-07-25T03:29:57.000Z","updated":"2018-07-25T08:36:44.779Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-07-25T03:30:32.000Z","updated":"2018-07-25T08:35:37.266Z","comments":true,"path":"blogroll/index.html","permalink":"http://yoursite.com/blogroll/index.html","excerpt":"","text":""},{"title":"分类","date":"2014-12-22T17:39:04.000Z","updated":"2018-07-25T08:33:56.939Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T17:39:04.000Z","updated":"2018-07-25T08:31:53.891Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java常用日志框架","slug":"Java常用日志框架介绍","date":"2018-07-26T04:00:00.000Z","updated":"2018-07-27T03:22:54.554Z","comments":true,"path":"2018/07/26/Java常用日志框架介绍/","link":"","permalink":"http://yoursite.com/2018/07/26/Java常用日志框架介绍/","excerpt":"","text":"Java常用日志框架介绍 Log4j Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一。 Log4j2 Apache Log4j 2是apache开发的一款Log4j的升级产品。 Commons Logging Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。 Slf4j 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。 Logback 一套日志组件的实现(slf4j阵营)。 Jul (Java Util Logging),自Java1.4以来的官方日志实现。 Java常用框架历史 1996年早期，欧洲安全电子市场项目组决定编写它自己的程序跟踪API(Tracing API)。经过不断的完善，这个API终于成为一个十分受欢迎的Java日志软件包，即Log4j。后来Log4j成为Apache基金会项目中的一员。 期间Log4j近乎成了Java社区的日志标准。据说Apache基金会还曾经建议sun引入Log4j到java的标准库中，但Sun拒绝了。 2002年Java1.4发布，Sun推出了自己的日志库JUL(Java Util Logging),其实现基本模仿了Log4j的实现。在JUL出来以前，log4j就已经成为一项成熟的技术，使得log4j在选择上占据了一定的优势。 接着，Apache推出了Jakarta Commons Logging，JCL只是定义了一套日志接口(其内部也提供一个Simple Log的简单实现)，支持运行时动态加载日志组件的实现，也就是说，在你应用代码里，只需调用Commons Logging的接口，底层实现可以是log4j，也可以是Java Util Logging。 后来(2006年)，Ceki Gülcü不适应Apache的工作方式，离开了Apache。然后先后创建了slf4j(日志门面接口，类似于Commons Logging)和Logback(Slf4j的实现)两个项目，并回瑞典创建了QOS公司，QOS官网上是这样描述Logback的：The Generic，Reliable Fast&amp;Flexible Logging Framework(一个通用，可靠，快速且灵活的日志框架)。 现今，Java日志领域被划分为两大阵营：Commons Logging阵营和SLF4J阵营。 Apache眼看有被Logback反超的势头，于2012-07重写了log4j 1.x，成立了新的项目Log4j 2。Log4j 2具有logback的所有特性。 java常用日志框架之间的关系 Log4j2与Log4j1发生了很大的变化，log4j2不兼容log4j1。 Log4j 2包含基于LMAX Disruptor库的下一代异步记录器。在多线程场景中，异步记录器的吞吐量比Log4j 1.x和Logback高18倍，延迟低。 Log4j 2明显优于Log4j 1.x，Logback和java.util.logging，尤其是在多线程应用程序中。 Commons Logging和Slf4j是日志门面(门面模式是软件工程中常用的一种软件设计模式，也被称为正面模式、外观模式。它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用)。log4j和Logback则是具体的日志实现方案。可以简单的理解为接口与接口的实现，调用这只需要关注接口而无需关注具体的实现，做到解耦。 比较常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。 Logback必须配合Slf4j使用。由于Logback和Slf4j是同一个作者，其兼容性不言而喻。 Commons Logging与Slf4j实现机制对比 Commons logging是通过动态查找机制，在程序运行时，使用自己的ClassLoader寻找和载入本地具体的实现。详细策略可以查看commons-logging-*.jar包中的org.apache.commons.logging.impl.LogFactoryImpl.java文件。由于OSGi不同的插件使用独立的ClassLoader，OSGI的这种机制保证了插件互相独立, 其机制限制了commons logging在OSGi中的正常使用。 Slf4j在编译期间，静态绑定本地的LOG库，因此可以在OSGi中正常使用。它是通过查找类路径下org.slf4j.impl.StaticLoggerBinder，然后绑定工作都在这类里面进。 如何在项目中选择日志框架如果是在一个新的项目中建议使用Slf4j与Logback组合，这样有如下的几个优点。 Slf4j实现机制决定Slf4j限制较少，使用范围更广。由于Slf4j在编译期间，静态绑定本地的LOG库使得通用性要比Commons logging要好。 Logback拥有更好的性能。Logback声称：某些关键操作，比如判定是否记录一条日志语句的操作，其性能得到了显著的提高。这个操作在Logback中需要3纳秒，而在Log4J中则需要30纳秒。LogBack创建记录器（logger）的速度也更快：13毫秒，而在Log4J中需要23毫秒。更重要的是，它获取已存在的记录器只需94纳秒，而Log4J需要2234纳秒，时间减少到了1/23。跟JUL相比的性能提高也是显著的。 Commons Logging开销更高 在使Commons Logging时为了减少构建日志信息的开销，通常的做法是： if(log.isDebugEnabled()){ ​ log.debug(&quot;User name： &quot; + user.getName() + &quot; buy goods id ：&quot; + good.getId()); } 在Slf4j阵营，你只需这么做： log.debug(&quot;User name：{} ,buy goods id ：{}&quot;, user.getName(),good.getId()); 也就是说，slf4j把构建日志的开销放在了它确认需要显示这条日志之后，减少内存和cup的开销，使用占位符号，代码也更为简洁 。 Logback文档免费。Logback的所有文档是全面免费提供的，不象Log4J那样只提供部分免费文档而需要用户去购买付费文档。 如何在项目中使用self4j直接使用slf4j来输入日志的方式 这里引用了slf4j官网的图，去官网查阅可以点击这里 简单说一下对上图的理解： 图中第一层绿色的模块application代表你的应用程序 图中第二层浅蓝色的模块，代表是抽象的日志接口层，这里用的是slf4j 图中第三层分为两种： 一种是深蓝色的，表示的是第二层中slf4j日志接口的直接实现,直接实现了slf4j的日志框架有logback、slf4j-simple（slf4j的简单实现）、 slf4j-nop（丢弃日志不打印） 另外一中湖蓝色的，表示是没有直接实现slf4j的API，而是通过适配器调用其它具体日志框架的API，这里包括slf4j到log4j的适配和slf4j到Jul的适配。 第四层灰色的模块表示具体的日志框架，他们没有直接实现slf4j的API，但是可以通过上层的适配器与slf4j做适配实现日志管理。 如果你的应用包含其他模块，但这些模块没有使用slf4j，而是使用了其他日志框架，不要担心，slf4j提供了一些包可以将系统中其他日志转到slf4j做一个统一输出，具体可以参考slf4j官网的这幅图 去官网查阅可以点击这里 上图中从左到右再到下分别为图一、图二、图三 图一表示使用slf4j作为统一日志输出，将程序中原有的Commons Longing、Log4j、Jul日志适配到slf4j jar包名 作用 log4j-over-slf4j-version.jar 将log4j适配到slf4j jcl-over-slf4j-version.jar 将commos logging适配到slf4j jul-to-slf4j-version.jar 将Java Util Logging适配到slf4j 可以通过上面的包将原来的日志适配到slf4j作为统一日志输出，使用logback作为具体日志实现。 图二、三原理类似，只是更换了slf4j的日志实现方式。 注意 如果有其它日志重定向到了slf4j，就不能将该日志再作为slf4j的具体实现了，否则会形成闭环（该日志将输出重定向到slf4j，slf4j又将日志输出到该日志），所以将其它日志重定向到slf4j的方式只有如上三种搭配组合方式。 上面介绍使用slf4j作为统一日志输出，将其它日志适配到slf4j，以及slf4j绑定具体日志实现，这些适配功能的jar包和适配器相关的jar包都是由slf4j提供的，Apache作为log4j的维护方，也提供了一些桥接器，更好的支持log4j 2 jar包 作用 log4j-1.2-api 将log4j 2作为log4j 1.x 的具体实现（两者不兼容） log4j-jcl 将log4j 2作为jcl 的具体实现 log4j-slf4j-impl 将log4j 2作为slf4j的具体实现 去log4j 2官网查看点击这里 参考链接 Java常用日志框架介绍 slf4j官网 log4j 2官网","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":"使用Hexo搭建个人博客","slug":"使用Hexo搭建个人博客","date":"2018-07-26T03:20:00.000Z","updated":"2018-07-27T01:03:07.429Z","comments":true,"path":"2018/07/25/使用Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/07/25/使用Hexo搭建个人博客/","excerpt":"","text":"记录一下自己使用Hexo搭建个人博客的过程，以及搭建过程中踩过的坑。 Hexo简介 这里引用Hexo官网介绍： &gt; 快速、简洁且高效的博客框架 &gt; A fast, simple &amp; powerful blog framework. 不了解的小伙伴可以到官网去详细了解一下，主页中有选择语言的选项，英文勉强的同学（说我的就是我自己）可以选择中文阅览,这里不再赘述。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Netty简介","slug":"深入学习Netty框架","date":"2018-07-25T16:00:00.000Z","updated":"2018-07-26T05:03:37.015Z","comments":true,"path":"2018/07/25/深入学习Netty框架/","link":"","permalink":"http://yoursite.com/2018/07/25/深入学习Netty框架/","excerpt":"","text":"官网简介： Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.用一句话来概括： Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能协议服务器和客户端。 特征设计 适用于各种传输类型的统一API - 阻塞和非阻塞套接字 基于灵活且可扩展的事件模型，可以清晰地分离关注点 高度可定制的线程模型 - 单线程，一个或多个线程池，如SEDA 真正的无连接数据报套接字支持（自3.1起） 易用 详细记录的Javadoc，用户指南和示例 没有其他依赖项，JDK 5（Netty 3.x）或6（Netty 4.x）就足够了 性能 吞吐量更高，延迟更低 减少资源消耗 最小化不必要的内存复制 安全 完整的SSL / TLS和StartTLS支持 架构示意图","categories":[],"tags":[{"name":"netty","slug":"netty","permalink":"http://yoursite.com/tags/netty/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-24T09:03:54.065Z","updated":"2018-07-24T09:03:54.065Z","comments":true,"path":"2018/07/24/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}