<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Maven Resources Plugin 二进制文件filtering</title>
    <url>/2020/12/18/mavenresourcesplugin-binaryfiltering/</url>
    <content><![CDATA[<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>Maven项目中打包使用Maven Resources Plugin拷贝配置文件，使用Filtering来处理项目配置文件中的变量，POM文件如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;
        &lt;filtering&gt;true&lt;&#x2F;filtering&gt;
    &lt;&#x2F;resource&gt;
&lt;&#x2F;resources&gt;
&lt;testResources&gt;
    &lt;testResource&gt;
        &lt;directory&gt;src&#x2F;test&#x2F;resources&lt;&#x2F;directory&gt;
        &lt;filtering&gt;true&lt;&#x2F;filtering&gt;
    &lt;&#x2F;testResource&gt;
&lt;&#x2F;testResources&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是对于项目配置文件目录下的二进制文件，经过Filtering处理后，文件内容发生了变化，如<code>pdf</code>, <code>ddl</code>文件内容被修改，导致打包后的文件无法正常使用。</p>
<h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>Maven Resources Plugin提供了Binary filtering配置项，阻止二进制文件被filtering，配置案例：</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;
        &lt;version&gt;3.2.0&lt;&#x2F;version&gt;
        &lt;configuration&gt;
          ...
          &lt;nonFilteredFileExtensions&gt;
            &lt;nonFilteredFileExtension&gt;pdf&lt;&#x2F;nonFilteredFileExtension&gt;
            &lt;nonFilteredFileExtension&gt;swf&lt;&#x2F;nonFilteredFileExtension&gt;
          &lt;&#x2F;nonFilteredFileExtensions&gt;
          ...
        &lt;&#x2F;configuration&gt;
      &lt;&#x2F;plugin&gt;
    &lt;&#x2F;plugins&gt;
    ...
  &lt;&#x2F;build&gt;
  ...
&lt;&#x2F;project&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>nonFilteredFileExtension</code>添加文件扩展名可以阻止文件被filtering。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://maven.apache.org/plugins/maven-resources-plugin/">Apache Maven Resources Plugin</a><br><a href="https://maven.apache.org/plugins/maven-resources-plugin/examples/binaries-filtering.html">Apache Maven Resources Plugin/ Binaries Filtering</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性哈希算法</title>
    <url>/2019/10/06/yi-zhi-xing-ha-xi-suan-fa/</url>
    <content><![CDATA[<h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希算法是为了解决分布式缓存中的热点问题而提出的。一致性哈希将每个对象映射到圆环边上的一个点，系统再将可用的节点机器映射到圆环不同位置。查找某个对象对应的机器时，需要用一致性哈希算法计算得到对象在圆环上的位置，沿着圆环边顺序查找，直到遇到默认机器节点，这台机器即为该对象的存储位置。当删除一台节点机器时，这台机器上的所有对象都要移动到下一台机器上。当添加一台机器到圆环边上的一个点，这个点下一台机器需要将这个点之前的对象移动到新机器上。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>一致性哈希算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建个人博客</title>
    <url>/2018/07/25/shi-yong-hexo-da-jian-ge-ren-bo-ke/</url>
    <content><![CDATA[<p>记录一下自己使用Hexo搭建个人博客的过程，以及搭建过程中踩过的坑。<br> <strong>Hexo简介</strong><br>这里引用<a href="https://hexo.io/">Hexo</a>官网介绍：  </p>
<blockquote>
<p>快速、简洁且高效的博客框架<br>A fast, simple &amp; powerful blog framework.</p>
</blockquote>
<h1 id="一、为什么选择Hexo"><a href="#一、为什么选择Hexo" class="headerlink" title="一、为什么选择Hexo"></a>一、为什么选择Hexo</h1><p>之前也想过自己用java写一个博客系统，顺便能学习一些开发技术。通过一段时间的折腾，主要发现有一下几个问题，于是放弃了自己开发的计划转而采用开源框架。</p>
<blockquote>
<p>使用java自行开发个人博客系统遇到的问题：</p>
</blockquote>
<ul>
<li>开发周期长：虽然可以使用一些脚手架快速搭建博客系统框架，但是仍需要个人大量的开发时间去实现及调试代码。</li>
<li>UI样式不美观: 由于本人是非前端开发人员，只能通过前端的一些脚手架去搭建博客前端，UI设计不够美观。</li>
<li>偏离初始目标：自己开发博客的目标是通过开发过程提高编码水平，但是随着在工作中的成长，知识面已经铺开，搭建个人博客已经无法带来技术深层面成长，只是重复造轮子罢了。</li>
</ul>
<h2 id="hexo-博客的优点"><a href="#hexo-博客的优点" class="headerlink" title="hexo 博客的优点"></a>hexo 博客的优点</h2><ul>
<li>支持MarkDown格式</li>
<li>使用Node.js生成静态文件，部署简便</li>
<li>有丰富的主题可以选择</li>
<li>有丰富的插件扩展性强</li>
</ul>
<p>选择hexo搭建个人博客完全满足我个人写博客的要求，最终选择使用hexo来搭建个人博客。</p>
<h1 id="二、如何管理个人博客"><a href="#二、如何管理个人博客" class="headerlink" title="二、如何管理个人博客"></a>二、如何管理个人博客</h1><h2 id="2-1-博客资源文件存储"><a href="#2-1-博客资源文件存储" class="headerlink" title="2.1 博客资源文件存储"></a>2.1 博客资源文件存储</h2><p>个人博客是以Node.js项目形式托管到github的私有仓库中的，方便我在任意设备去编辑发布博客。</p>
<h2 id="2-2-写作及提交新文章"><a href="#2-2-写作及提交新文章" class="headerlink" title="2.2 写作及提交新文章"></a>2.2 写作及提交新文章</h2><p>从github检出项目，我们可以使用<code>jetbrain</code>系列的开发工具安装MarkDown插件后进行写作新文章，或者使用常用MarkDown软件进行写作，完成后将文章提交到github仓库。</p>
<h2 id="2-3-文章发布更新"><a href="#2-3-文章发布更新" class="headerlink" title="2.3 文章发布更新"></a>2.3 文章发布更新</h2><blockquote>
<p><strong>前置条件</strong><br>目前个人博客是部署在个人购买的华为云服务器上，使用Nginx进行托管的。<br>云服务器安装Node.js及hexo环境，将github上的博客仓库克隆到本地,在Nginx中将博客的托管路径设置为hexo博客构建目录。</p>
</blockquote>
<p>文章发布时只在本地仓库下执行<code>git pull</code>和<code>hexo g</code>两个命令即可生成博客内容。<br>为简化操作，将上述脚本写入shell脚本，通过执行脚本进行发布文章。如果不想每次都去手动发布，可以添加系统定时任务，做到定时执行脚本去发布文章。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>使用github托管博客主要的优点在于添加新文章方便，我们使用MarkDown写完文章后，可以方便的提交到itHub进行管理；然后可以在任意地方去编辑修改及部署。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表设计方案</title>
    <url>/2021/03/04/fen-ku-fen-biao-she-ji-fang-an/</url>
    <content><![CDATA[<h1 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h1><p>系统数据库主要分为两个数据库，一个是主要的业务数据存储库，在该库下进行了分表操作；另一个是业务关联性较小的数据库，未进行分表。在当前业务场景下，系统每天的消息发送量基本分布在100万 ~ 3000万之间。消息下发后，用户可以查看消息发送记录，及用户接受状态。系统采用了按天分表的策略，提前为存储消息记录的表按天创建分表，每个大表将会按天创建366个分表，分表以月日为后缀。</p>
<h2 id="1-1-按天分表的优点"><a href="#1-1-按天分表的优点" class="headerlink" title="1.1 按天分表的优点"></a>1.1 按天分表的优点</h2><ul>
<li>用户可以以发送日期为时间限度，查询、导出当天的发送记录及用户接受状态。</li>
<li>可以通过日期条件，限定事务范围，简化分表事务问题。</li>
<li>分表规则简单，方便基于数据库各类连表查询操作。</li>
</ul>
<h2 id="1-2-分库分表遇到的问题"><a href="#1-2-分库分表遇到的问题" class="headerlink" title="1.2 分库分表遇到的问题"></a>1.2 分库分表遇到的问题</h2><ul>
<li>在开发新业务的过程中，分表数量急速增长，目前系统的分表数量已达7000多。</li>
<li>分表数据分布不均匀，有些表的数据库只有几十万或更少，而有的表的量超过了千万。</li>
<li>分表数量超过千万级，客户查询时会影响数据库性能，当前的分表机制无法做动态扩容。</li>
</ul>
<h1 id="二、分库分表方案"><a href="#二、分库分表方案" class="headerlink" title="二、分库分表方案"></a>二、分库分表方案</h1><p>分库分表的采用的常见方案垂直拆分和水平拆分。</p>
<h2 id="2-1-垂直拆分"><a href="#2-1-垂直拆分" class="headerlink" title="2.1 垂直拆分"></a>2.1 垂直拆分</h2><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>垂直分表主要主要针对数据列较多的宽表，一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的列拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>垂直分库主要是对系统中业务进行拆分，切分后不同的业务数据存放到不同的数据库。可以将这些数据库部署到不同的机器上，避免单机CPU、内存、IO瓶颈问题。此外还可以独立对高并发的业务进行性能单独优化而不影响其它业务。</p>
<h2 id="2-2-水平拆分"><a href="#2-2-水平拆分" class="headerlink" title="2.2 水平拆分"></a>2.2 水平拆分</h2><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>针对数据量巨大打单表（比如订单表）按照某种规则（如时间，哈希取模等），将数据路由到不同的分表中。但是这些分表仍处于一个数据库中，单库具有IO瓶颈问题。</p>
<h3 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h3><p>单独的水平分表会遇到单机数据库性能瓶颈及压力，如IO、连接数等硬件资源的限制。可以将单表数据按分表规则先路由到不同的数据库，然后再路由数据库内的不同分表之中。水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p>
<h2 id="2-3-水平分库分表切分规则"><a href="#2-3-水平分库分表切分规则" class="headerlink" title="2.3 水平分库分表切分规则"></a>2.3 水平分库分表切分规则</h2><h3 id="RANGE"><a href="#RANGE" class="headerlink" title="RANGE"></a>RANGE</h3><p>从0到1000万一个表，1000万到2000万一个表；</p>
<h3 id="HASH取模"><a href="#HASH取模" class="headerlink" title="HASH取模"></a>HASH取模</h3><ul>
<li>按用户ID哈希取模（避免分库事务，但数据可能会分布不均匀）</li>
<li>按订单ID哈希取模（数据分布较均匀，会有分库事务问题）<h3 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h3>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</li>
</ul>
<h1 id="三、分库分表面临的问题"><a href="#三、分库分表面临的问题" class="headerlink" title="三、分库分表面临的问题"></a>三、分库分表面临的问题</h1><ul>
<li><p>事务支持<br>分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>
</li>
<li><p>多库结果集合并</p>
</li>
<li><p>跨库join连接查询<br>分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。 粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。</p>
</li>
</ul>
<h1 id="四、分库分表产品"><a href="#四、分库分表产品" class="headerlink" title="四、分库分表产品"></a>四、分库分表产品</h1><p><img src="/2021/03/04/fen-ku-fen-biao-she-ji-fang-an/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BA%A7%E5%93%81.jpg" alt="分库分表设计方案"><br>参考文章：<a href="https://blog.csdn.net/fly910905/article/details/87101059">分库分表：中间件方案对比</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分库分表常用的方法就是垂直拆分和水平拆分，我们在进行分库分表设计时需要结合业务场景及资源环境去充分考虑。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>《一分钟经理人》</title>
    <url>/2022/03/23/book/yi-fen-zhong-jing-li-ren/</url>
    <content><![CDATA[<h1 id="一、经典的“自上而下”严密的管理方式存在什么问题？"><a href="#一、经典的“自上而下”严密的管理方式存在什么问题？" class="headerlink" title="一、经典的“自上而下”严密的管理方式存在什么问题？"></a>一、经典的“自上而下”严密的管理方式存在什么问题？</h1><p>经典的“自上而下”的严密的管理方式，能够严格规范员工的行为方式。但是放在今天，这种方式不能激发员工潜力还扼杀创造力。</p>
<h1 id="二、一分钟管理法"><a href="#二、一分钟管理法" class="headerlink" title="二、一分钟管理法"></a>二、一分钟管理法</h1><h2 id="2-1-一分钟目标"><a href="#2-1-一分钟目标" class="headerlink" title="2.1 一分钟目标"></a>2.1 一分钟目标</h2><p>设定一分钟目标：</p>
<ol>
<li>共同制定工作目标， 并清楚简洁地描述出来， 明确好的工作表现的标<br>准。</li>
<li>每个目标都单独写在一张纸上， 并写下完成期限。</li>
<li>规定每天用几分钟时间， 重温自己最重要的目标。</li>
<li>鼓励人们用一分钟时间审视自己的表现， 检查是否与目标一致。</li>
<li>若与目标不一致， 反思自己的工作表现， 以便调整。</li>
</ol>
<h2 id="2-2-一分钟称赞"><a href="#2-2-一分钟称赞" class="headerlink" title="2.2 一分钟称赞"></a>2.2 一分钟称赞</h2><p>进行一分钟称赞：</p>
<h3 id="◆-前半分钟"><a href="#◆-前半分钟" class="headerlink" title="◆ 前半分钟"></a>◆ 前半分钟</h3><ol>
<li>及时称赞下属。</li>
<li>告诉他们对在哪里—要说得非常具体。</li>
<li>告诉他们这件事情做对之后， 会让你感到多么高兴， 对整个团队和其他同事又会有多么大的帮助。</li>
</ol>
<h3 id="◆-停顿一会儿"><a href="#◆-停顿一会儿" class="headerlink" title="◆ 停顿一会儿"></a>◆ 停顿一会儿</h3><ol start="4">
<li>沉默几秒， 让他们静静地体会做对事带来的喜悦。</li>
</ol>
<h3 id="◆-后半分钟"><a href="#◆-后半分钟" class="headerlink" title="◆ 后半分钟"></a>◆ 后半分钟</h3><ol start="5">
<li>鼓励他们以后继续这样做。</li>
<li>明确说明你对他们有信心， 并会支持他们获得成功。</li>
</ol>
<h2 id="2-3-一分钟更正"><a href="#2-3-一分钟更正" class="headerlink" title="2.3 一分钟更正"></a>2.3 一分钟更正</h2><p>如果目标阐述清晰， 进行一分钟更正：</p>
<h3 id="◆-前半分钟-1"><a href="#◆-前半分钟-1" class="headerlink" title="◆ 前半分钟"></a>◆ 前半分钟</h3><ol>
<li>错误发生后立刻进行更正。</li>
<li>确认既有的事实， 分析错在哪里，要说得非常具体。</li>
<li>告诉他们这件事带给你的感受， 以及对工作成果可能造成的影响。</li>
</ol>
<h3 id="◆-停顿一会儿-1"><a href="#◆-停顿一会儿-1" class="headerlink" title="◆ 停顿一会儿"></a>◆ 停顿一会儿</h3><ol start="4">
<li>沉默几秒， 让他们审视所犯的错误。</li>
</ol>
<h3 id="◆-后半分钟-1"><a href="#◆-后半分钟-1" class="headerlink" title="◆ 后半分钟"></a>◆ 后半分钟</h3><ol start="5">
<li>告诉对方， 他们的实际能力比这次表现出来的更强， 你认为他们很不错。</li>
<li>告诉对方， 你对他们有信心， 仍然信任他们。</li>
<li>更正过后， 整件事就过去了。</li>
</ol>
<h1 id="三、一分钟管理法为什么有效？"><a href="#三、一分钟管理法为什么有效？" class="headerlink" title="三、一分钟管理法为什么有效？"></a>三、一分钟管理法为什么有效？</h1><p>在了解到一分钟管理法后，我们应该思考，为什么一分钟管理法有效？</p>
<h2 id="3-1-一分钟目标为什么有效？"><a href="#3-1-一分钟目标为什么有效？" class="headerlink" title="3.1 一分钟目标为什么有效？"></a>3.1 一分钟目标为什么有效？</h2><p>对每个人来说， 不论成功者还是有成功潜力的人， 设定一分钟目标都是提高工作效率的一条最基本的途径。</p>
<h2 id="3-2-一分钟称赞为什么有效？"><a href="#3-2-一分钟称赞为什么有效？" class="headerlink" title="3.2 一分钟称赞为什么有效？"></a>3.2 一分钟称赞为什么有效？</h2><p>训练成功者最重要的是发现他们做对了的事情——开始也许只是大概做对， 接着要逐渐引导他们做得越来越完美。通过一分钟称赞可以帮助人们建立自信，从而达到非常好的状态。</p>
<h2 id="3-3-一分钟更正为什么有效？"><a href="#3-3-一分钟更正为什么有效？" class="headerlink" title="3.3 一分钟更正为什么有效？"></a>3.3 一分钟更正为什么有效？</h2><p>反馈应该是即时的。 一旦你发现下属做错了事， 就要立刻指出来。如果把反馈集中起来，事情太多也不利于员工修正错误，而且有点翻旧账的嫌疑，最后产生争论，最后被批评的一方形成心理戒备，那么最后的反馈是无效的。</p>
<p>如果经理人及时提出意见，被更正的一方可以接受反馈信息。 每次只更正一个行为， 会让人觉得既公平又明确。对于一分钟更新更重要的是后半分钟，我们给员工反馈问题是希望他们修正问题获得成长，而不是贬低他们的价值，所以更正的同时，也要给予肯定和尊重。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>一分钟管理法和之前在《刻意练习》一书中有看到的3F（Focus，feedback，fix it）思想极为相近，其中focus对应着一分钟目标，而feedback和fix it原则正是一分钟更正的体现。一分钟目标，可以让我们能够明确自己的工作目标，从而专注工作；一分钟更正给予我们我们结果的反馈，并修正其中的错误，从而不断成长和进步。</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>一分钟经理人</tag>
      </tags>
  </entry>
  <entry>
    <title>《人间失格》</title>
    <url>/2021/05/30/book/ren-jian-shi-ge/</url>
    <content><![CDATA[<p><img src="/images/%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC.jpg" alt="人间失格"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><em><strong>《人间失格》 —— “无赖派”文学大师太宰治饱受争议的破灭之书</strong></em></p>
<blockquote>
<p>[日]太宰治 —— 著<br>杨伟 —— 译</p>
</blockquote>
<p>之前并不了解太宰治，是被书名吸引的才开始读的。在了解到作者的过往经历后，对这本的书的兴趣愈发浓厚。</p>
<p>太宰治的一生充满的传奇色彩，他出身豪门，一生立志文学，师从井伏鳟二等小说名家；大学时代曾积极投身左翼运动，却中途逃脱；生活放荡不羁，却热心于阅读《圣经》；五度自杀，四度殉情未遂，三十九岁时与最后一位情人投水自尽。以至于他说”回收往昔，我的人生充斥着耻辱”（《人间失格》），”生而为人，对不起”（《二十世纪旗手》），”上帝选民的不安与恍惚俱存于吾身”（《叶》）。这些格言式的短语七号成了太宰治人生和文学的最好注脚，也从某个角度勾勒除了他一生的心理轨迹。</p>
<p>《人间失格》一书中的主人公大庭叶藏通过「扮丑」逗笑周围人的来进行「自我救赎」。但是最终承受不住这样的压抑和无奈，在同学堀木的影响下一步一步走向堕落，利用酒精和毒品麻醉神经，用女性的肉体安抚自身的肉体，依靠女人维系基本生活。 太宰治以”私小说”的方式，将自己的一生的投影都折射在叶藏身上。</p>
<p> 读完这本书后，内心仿佛有什么东西被触动了，但是一切又了无痕迹。细细想来可能是在书中看到了自己的些许重影，如对这个人类世界的恐惧。</p>
<blockquote>
<p>我一直对人类畏葸不已，并因这种畏葸而战栗。对自己作为人类一员的言行也毫无自行，只好将独自的懊恼深藏进胸中的小匣子里，将精神上的忧郁和过敏封存起来”，伪装成天真无邪的乐天外表，把自己一步步地彻底打磨成搞笑的畸人。<br>无论如何，只要能让他们发笑。这样一来，即使我处在人们所谓的”生活”之外，也不会引起他们的注意吧。总而言之，不能有碍他们的视线。我是”无”，是”风”，是”空”。诸如此类的想法愈演愈烈，我只能用搞笑来逗家人们开你，甚至在必家人更费解更可怕的男俑和女佣面前，也拼命的提供搞笑服务。</p>
</blockquote>
<p>在与现实生活的斗争中，不断败北的他为自己带上了”丑角”面具来掩盖自己的真实面目，用小时候就惯用的”逗笑” “装模作样”等手法来伪装自己，取悦于他人。但是在现实的摧残下，那种矛盾愈演愈烈，最后变得不可调和，直至最终的自我毁灭。</p>
<p>看到好多评论说，心情好的时候，不要看太宰治的作品，因为那会让你的心情变得不好；心情不好的时候更不要去看太宰治的作品，那会让你糟糕的心情雪上加霜。</p>
<p>看完书不竟想问自己，当某一天，现实生活压的你喘不过气来，当内心的思想与现实产生激烈的矛盾后，我又该何去何从呢？</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>人间失格</tag>
      </tags>
  </entry>
  <entry>
    <title>《原生家庭》</title>
    <url>/2021/02/11/book/yuan-sheng-jia-ting/</url>
    <content><![CDATA[<p><img src="/images/%E5%8E%9F%E7%94%9F%E5%AE%B6%E5%BA%AD.jpeg" alt="原生家庭"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><em><strong>《原生家庭》 —— 如何修补自己的性格缺陷</strong></em></p>
<blockquote>
<p>[美]苏珊·福沃德 克雷格·巴克 —— 著<br>黄姝 王婷 —— 译</p>
</blockquote>
<h1 id="书序"><a href="#书序" class="headerlink" title="书序"></a>书序</h1><p> 你的所有的感受都是有道理的，尤其是那些灰暗的感受。内心充满痛苦的人，只要能发现这样一个简单的道理，他们的痛苦就会减轻很多。并且这个道理的核心是，你那些灰暗的、一直以来难以被别人和自己理解接纳、似乎无处安放的感受，其实就是来自你的家庭，而且主要是来自你与父母的关系。这是一个真相，我们必须尊重的真相。 —— 武志红 [心里学家、作家]</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>原生家庭</tag>
      </tags>
  </entry>
  <entry>
    <title>《可爱的诅咒》</title>
    <url>/2021/02/11/book/ke-ai-de-zu-zhou/</url>
    <content><![CDATA[<p><img src="/images/%E5%8F%AF%E7%88%B1%E7%9A%84%E8%AF%85%E5%92%92.jpeg" alt="可爱的诅咒"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><em><strong>《可爱的诅咒》—— 圣母型人格心里自助手册</strong></em></p>
<blockquote>
<p>[英]雅基·马森 —— 著<br>王丽 —— 译</p>
</blockquote>
<h1 id="书序"><a href="#书序" class="headerlink" title="书序"></a>书序</h1><p>生活中总会有一些这样的人，他（她）们将大部分精力都花在家人、朋友和同事身上，甚至对陌生人也有求必应，一旦停止这样做，就会觉得非常内疚，仿佛受了一场”可爱的诅咒”。在他们看来，很多事情的优先级都高于自己的身心健康，结果，支持了所有人，却让自己崩溃。</p>
<h1 id="精彩段落"><a href="#精彩段落" class="headerlink" title="精彩段落"></a>精彩段落</h1><h2 id="第一章-期望的牢笼"><a href="#第一章-期望的牢笼" class="headerlink" title="第一章 期望的牢笼"></a>第一章 期望的牢笼</h2><p>我们通常都会觉得自己被淹没在别人的期望中，而且完全不知道该如何以其它方式生活。事实上，就连想到改变，比如拒绝某个请求，都会觉得害怕。</p>
<h2 id="第四章-身体的感受与情绪的觉察"><a href="#第四章-身体的感受与情绪的觉察" class="headerlink" title="第四章 身体的感受与情绪的觉察"></a>第四章 身体的感受与情绪的觉察</h2><p>我们不敢说出我们与别人不同的意见。这还是”害怕冲突”的问题：当你能够忽略自己的真实想法并享受和睦时，你又何必冒险引起愤怒与不和呢？但是，这是需要我们自己付出代价的。再次重申，我们不敢显露真实的自己，包括我们的价值观、信仰、品味及意见，所以其他人也就永远无法了解真实的我们是什么样子。这种情况下维持的关系会有问题，因为它并非百分百真实。我们的自我感知也会有问题，因为我们并不相信别人是因为我们自身的样子而喜欢我们，而是以为他们喜欢我们只是因为我们与他们的意见一致。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总是想成为别人眼中的”好孩子”，一直努力做一个对别人”有用”的人，忽略自己真实的感受，通过”删除”自己真实的想法去赞成别人的观点来获得认同，我们可能都有一小块被”可爱的诅咒”施了法的脆弱区域，而我可能有一大片。</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>可爱的诅咒</tag>
      </tags>
  </entry>
  <entry>
    <title>《极简主义》</title>
    <url>/2021/02/16/book/ji-jian-zhu-yi/</url>
    <content><![CDATA[<p><img src="/images/%E6%9E%81%E7%AE%80%E4%B8%BB%E4%B9%89.jpg" alt="极简主义"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><em><strong>《极简主义》—— 活出生命真意</strong></em></p>
<blockquote>
<p>[美]乔舒亚·菲尔茨·米尔本 瑞安·尼科迪默斯 —— 著<br>李紫 —— 译</p>
</blockquote>
<h1 id="书序"><a href="#书序" class="headerlink" title="书序"></a>书序</h1><p>极简主义不是要你一无所有，而是要你穿越物质的海洋，找到真正重要的东西。在《极简主义》一书中，放弃高薪主管工作、转身成为美国极简主义生活先锋的乔舒亚和瑞安，分享了他们自己的人生故事和极简主义的生活理念。通过舍弃生活中多余的东西，我们得以超越物质，集中精力追求生命中最重要的 五种价值：健康、人际关系、热情、成长和奉献。 </p>
<h1 id="精彩内容"><a href="#精彩内容" class="headerlink" title="精彩内容"></a>精彩内容</h1><p>幸福源自内部，源自内心，源自充满意义的生活。</p>
<blockquote>
<p>不是转瞬即逝的欢愉，而是长久的满足，来自自律、专注、觉知、目的明确的生活。快乐只是一个副产品而已。</p>
</blockquote>
<p>快乐是我们专注于某个事情时的副产品，如果直接去寻求快乐，反而难以找到。</p>
<blockquote>
<p>我们在这世上只有有限的时间，这些时间可以用来积攒金钱财富，也可以花在有意义的事情上——后者不一定会妨碍人们追求前者，但对财富永无止境的追求并不能将我们带向有意义的生活。</p>
</blockquote>
<p>生命是有限的，我们应该先去寻找有意义的事情上。金钱只是在我们寻找有意义事情路上的一种重要工具，而不是我们最终的目标。</p>
<blockquote>
<p>我们不打算练得像个健美运动员。我们关心的是身体健康，体形匀称，对自己的身体状况感觉良好。在过去的几年间，我们试验了一些对我们有效的方法（其他很多东西对我们没什么用），而在此期间，我们发觉评价成功与否的最重要标准不在于体重秤上的数值，而是以下两件事：</p>
<ul>
<li>1．我们是否在持续地改善健康？</li>
<li>2．我们对自己的进步是否满意？</li>
</ul>
</blockquote>
<p>人生是一次长跑，只要我们不放弃就一定会到达终点。所以最终的成功不在阶段性的成果，而是在于你是否一直在坚持，一直在进步。</p>
<blockquote>
<p>要停止嫉妒，最简单的方法就是停止思考他人的意图。我们会嫉妒，往往是因为认为某人的行为意味着什么，而事实上他并没有那个意思。然而你永远不会知道别人的真实意图，所以思考这些根本就是浪费时间。</p>
</blockquote>
<p>以自我为中心，去揣测别人的意图往往会引起误解、嫉妒等负面情绪。保持良好的沟通可以在一定程度避免这些问题</p>
<blockquote>
<p>如果金钱不成问题，你的人生里你想做些什么？</p>
</blockquote>
<p>很早就发现，生活中缺少真正热爱的事情.</p>
<blockquote>
<p>换句话说，我人生的意义就是成长为一个独立个体，并以有意义的方式为他人做贡献。而好消息就是你可以决定自己该如何完成这两件事。</p>
</blockquote>
<p>在《活出生命的意义》一书中，生命的意义可以总结为以下三点：</p>
<ul>
<li>1.从事一份你喜欢的工作并投入其中 </li>
<li>2.爱，去爱一个人了解他的全部 </li>
<li>3.深处绝境仍能克服困难，勇敢的面对</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这个物欲横流的时代，极简主义或许是一种值得我们探索的生活方式。极简主义不是让你舍弃生活中的大多数东西过只拥有极少物质的生活，而是让你专注于生命中重要的、有意义的东西，拥有极少物质只是我们践行极简主义的结果而已。极简主义是一种工具，帮助我们追求生命中五种重要的价值：健康、人际关系、热情、成长、奉献。</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>《活出生命的意义》</title>
    <url>/2021/04/11/book/huo-chu-sheng-ming-de-yi-yi/</url>
    <content><![CDATA[<p><em><strong>《活出生命的意义》（Man’s Search for Meaning）—— 借着意义的寻找，将自己超拔出来去重新爱。</strong></em><br><img src="/images/%E6%B4%BB%E5%87%BA%E7%94%9F%E5%91%BD%E7%9A%84%E6%84%8F%E4%B9%89.png" alt="活出生命的意义"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>《活出生命的意义》（Man’s Search for Meaning）</strong></p>
<blockquote>
<p>[美]维克多·弗兰克尔 —— 著<br>吕娜 —— 译</p>
</blockquote>
<p>著名的心里学家弗兰克尔是20世纪的一个奇迹。纳粹时期，作为犹太人，他的全家都被关进奥斯维辛集中营，他的父母、妻子、哥哥全都死于毒气室中，只有他和妹妹幸存。弗兰克尔不但超越了这炼狱半的痛苦,更将自己的经验与学术结合，开创了意义疗法，替人们找到绝处再生的意义，也留下了人性史上最富光彩的见证。</p>
<p>弗兰克尔一生对生命充满了极大的热情，67岁仍开始学习驾驶飞机，并在几个月后领到驾照。一直到80岁还登上了阿尔卑斯山。这《活出生命的意义》曾经感动千千万万的人，它被美国国会图书馆评选为具有影响力的十本著作之一。到今天，这部作品销售已达1200万册，被翻译成24种语言。他并不是当年集中营里被编号为119104的待决囚徒，而是让人的可能性得以扩大的圣者。</p>
<h1 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h1><p>这本书主要分为两个部分，书的第一部分是自传部分（集中营的经历），第二部分是理论部分（存在意义分析治疗），浓缩了第一部分的精华。第一部分的自传是对作者理论存在的证明，两部分共同加强了本书的可信度。</p>
<h2 id="追求意义"><a href="#追求意义" class="headerlink" title="追求意义"></a>追求意义</h2><blockquote>
<p>人类对生命意义的追求是其主要的动机，而不是什么本能驱动的”次级合理化”。这种生命意义是独特的，因为只是并且只能是由特定的某个人来完成。也只有这样，他才满足了自己追求意义的独特愿望。人，能够为了自己的理想和价值而活，甚至为此付出生命！</p>
</blockquote>
<h2 id="存在之虚无"><a href="#存在之虚无" class="headerlink" title="存在之虚无"></a>存在之虚无</h2><blockquote>
<p>人类在成为真正的人的过程中经历了双重丧失。在人类历史之初，人丧失了赖以指导其行为并因此产生安全感的某些动物本能。此外，在最近时期，人类还经历了另外一种丧失，那就是原本作为其行为根基的传统迅速的消减。丧失了告诉他必须做什么的本能，丧失了告诉他应该做什么的传统，有时甚至连自己想做什么都不知道。这样，他要么去做别人所做的事（随大流），要么座别人希望他做的事（集权主义）。<br>简单理解，人类社会发展到现在，我们不必再为食物发愁，不必再担心害怕自然界的猛兽。但是我们也因此失去某些动物性本能。<br>存在之虚无的表单主要是厌倦。现在我们能理解叔本华的话了：人注定要徘徊在焦虑和厌倦这两极之间。</p>
</blockquote>
<h2 id="生命之意义"><a href="#生命之意义" class="headerlink" title="生命之意义"></a>生命之意义</h2><blockquote>
<p>生命的意义在每个人、每一天、每一刻都是不同的，所以重要的不是是生命之意义的普遍性，而是在特定时刻每个人特殊的生命意义。这个问题就好比问一个棋手：”告诉我，大师，世界上最厉害的招法是什么？”离开特定的棋局和特定的对手，压根不存在什么最厉害的招法，甚至连较好的招法也不存在，人的存在也是这样的。你不应该追问抽象的生命意义。每个人都有自己独特的使命。这个使命是他人无法替代的，并且你的生命也不可能重来一次。</p>
</blockquote>
<h2 id="发现生命意义的三种方式"><a href="#发现生命意义的三种方式" class="headerlink" title="发现生命意义的三种方式"></a>发现生命意义的三种方式</h2><p>人们活着是为了寻找生命的意义，这也是人们一生中被赋予的最艰巨的使命。弗兰克尔发现可能找寻到生命意义的三个途径。<br>（1）第一是通过创立某项工作或从事某种事业。<br>（2）第二是经历某种事情或者面对某个人，换句话说，不仅能从工作中也能从爱中找到意义。<br>（3）第三是在忍受不可避免的苦难时采取某种态度。</p>
<h2 id="存在之本质"><a href="#存在之本质" class="headerlink" title="存在之本质"></a>存在之本质</h2><blockquote>
<p>人之所以为人，是因为他总是指向某种事物或某人（他自己以外的某人）——不论是作为有待实现的意义还是需要面对的人。人越是忘记自己——投身于某种事业或献身于所爱的人——他就越有人性，越能实现自己的价值。所谓自我实现，绝不是只某种可以实现的目标，因为人越是追求这个目标，就是越容易失去它。换句话说，自我实现是自我超越唯一的副产品。</p>
</blockquote>
<h2 id="爱之意义"><a href="#爱之意义" class="headerlink" title="爱之意义"></a>爱之意义</h2><blockquote>
<p>爱是直达另一个人内心深处的唯一途径。只有在深爱另一个人时，你才能完全了解另一个人的本质。通过爱，你才能看到所爱的人的本质特性，甚至能够看到他潜在的东西即他应当实现而尚未实现的东西是什么。只有通过爱，才能是你所爱的人实现他的全部潜能。通过使他认识到自己的所能和应为，他就会实现自己的潜能。</p>
</blockquote>
<h2 id="苦难之意义"><a href="#苦难之意义" class="headerlink" title="苦难之意义"></a>苦难之意义</h2><blockquote>
<p>我们一定不能忘记，即使在看似毫无希望的境地，即使面对无可改变的厄运，人们也能找到生命之意义。那时重要的的是，能够见证人类潜能之极限，即人能够将灾难转化为胜利，将个人的厄运转化为人类之成就。</p>
</blockquote>
<blockquote>
<p>意义疗法的要义之一：人主要关注的不是获得快乐或避免痛苦，而是看到其生命的意义。这也是<br>人们为什么甚至准备着去受苦，在这个意义上，他的痛苦有了意义。</p>
</blockquote>
<p>作者在书中讲了一个例子：一名年迈的、患有严重抑郁症的全科医生来向作者咨询，他无法接受妻子的死亡（她在两年前去世，他爱她胜过世上的一切）。面对这个问题，作者思虑过后对这位失去爱妻的医生提出这样一个问题：”医生，如果你先她而去，而你太太在你死后还活着，那会怎样啊？” “啊，”他说，”那她可就受苦了，她怎么受得了啊！”。我马上回答：”你看医生，她免除了这样的痛苦，你替代了她的痛苦——当然代价是你现在还活着，并且陷入了深深的痛苦中。”</p>
<blockquote>
<p>假如痛苦是不可避免的，那么在遭遇痛苦时，人们也有可能找到意义。在一定意义上，一旦找到了意义（比如牺牲的意义），痛苦就不再是痛苦了。</p>
</blockquote>
<blockquote>
<p>但是遭受痛苦不是寻找意义的必要方式。如果痛苦是可以避免的，那么有意义的事就是去消除痛苦的根源，不论这种原因是心理的、生理的或政治的。遭受不必要的痛苦与其说是英雄行为，不如说是自虐。</p>
</blockquote>
<h2 id="生命之短暂"><a href="#生命之短暂" class="headerlink" title="生命之短暂"></a>生命之短暂</h2><blockquote>
<p>使生命丧失意义的事情，不仅包括痛苦，还包括死亡。意义疗法因为牢记人类存在的短暂性，所以不是消极悲观的，而是积极向上的。</p>
</blockquote>
<blockquote>
<p>意义疗法因为牢记人类存在的短暂性，所以不是消极悲观的，而是积极向上的。我们形象地表达这个意思:悲观主义者好比一个恐惧而悲伤地看着墙上的挂历每天都被撕掉一张，挂历越变越薄的人;而积极地应对生活问题的人好比一个每撕掉一张就把它整整齐齐地摞在一起，还要在背面记几行日记的人。他可以自豪而快乐地回忆日记中所记下的所有充实的日子，那些他曾经有过的全部生活。即便他意识到自己老了，那又有什么关系呢?他没有必要嫉妒年轻人，更没有必要为虚度的青春懊悔。他为什么要嫉妒年轻人呢?嫉妒年轻人所拥有的可能性和潜在的远大前程吗?“不，谢谢你”，他会这么想，“我拥有的不仅仅是可能性，而是现实性，我做过了，爱过了，也勇敢地承受过痛苦。这些痛苦甚至是我最珍视的，尽管它们不会引起别人的嫉妒”</p>
</blockquote>
<h2 id="集体性神经官能症"><a href="#集体性神经官能症" class="headerlink" title="集体性神经官能症"></a>集体性神经官能症</h2><blockquote>
<p>每个时代都有它的集体神经官能症，因此每个时代都需要相应的特定心理治疗方法来进行治疗。现在的集体官能症——存在之虚无——可以被表述为私人和个人的虚无主义，虚无主义认为生命毫无意义。</p>
</blockquote>
<blockquote>
<p>首先，关于人类“无谓”——即人不过是生物、心理和社会条件的产物，或是遗传与环境相结合的产物的理论是很危险的。它使神经官能症患者更愿意相信自己不过是外部影响的工具和牺牲品，认为人类不自由的心理疗法强化了这种神经官能症的宿命论。<br>当然，人的生命是有限的，自由也是有限的。人的自由不是无条件的自由，而是针对特定条件采取某种立场的自由。</p>
</blockquote>
<blockquote>
<p>神经症（英语：neurosis、psychoneurosis或neurotic disorder），香港、澳门、新加坡、台湾译作精神官能症，在广泛的意义上可以指任何引起沮丧的精神失衡。神经症属于功能性心理障碍（functional mental disorder）的一类，病人有痛苦（distress）的感觉但不包括妄想与幻觉与幻听，其行为也不会让人在社会上难以接受。不像精神病或者人格违常，神经症并不影响或者阻碍正常的思考。在西方，“神经症”是一个在精神分析领域里常常提及的术语，而在精神医学里已经废止不再使用。 而在《中国精神疾病分类方案与诊断标准》第三版（CCMD-III）中，则把神经症定义为一种具体的精神疾病，并将其分为焦虑症、恐惧症、神经衰弱、身心症（somatoform disorder）、强迫症、其他或待分类的神经症等六个亚型。<br>见<a href="https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E7%97%87">维基百科</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="如何寻找生命的意义？"><a href="#如何寻找生命的意义？" class="headerlink" title="如何寻找生命的意义？"></a>如何寻找生命的意义？</h2><p>人们活着是为了寻找生命的意义，这也是人们一生中被赋予的最艰巨的使命。弗兰克尔发现可能找寻到生命意义的三个途径。第一是创造或从事某种工作。第二是经历某种事情活着面对某个人，换句话说，不仅能从工作中也能从爱中找到意义。最重要的是第三个途径：即使是处于绝境的无助受害人，面对无法改变的厄运，仍能自我超越，并且以此改变自己。他能够把个人的悲剧转化为胜利。难。即使是处于绝境之中，面对无法改变的厄运，仍能自我超越，并且以此改变自己，把个人的悲剧转化为胜利。</p>
<h2 id="关于成功"><a href="#关于成功" class="headerlink" title="关于成功"></a>关于成功</h2><p>起初作者出书的初衷是通过具体的事例向读者传递一种观点——生命在任何条件下都有意义，即便是在最恶劣的情形下。然而让作者感到惊讶和非同寻常的是，在他的众多著作当中，恰恰是真笨他打算匿名出版的书出乎意料地给他带来了极大的成功。 因此，他再三叮嘱他的学生：”不要只想着成功——你越想成功，就越容易失败。成功就像幸福一样，可遇而不可求。它是一种自然而然的产物，是一个人无意识地投身于某一伟大的事业时产生的衍生品。我希望你们一切服从良心，并用只是去实现它。总有一天你会发现，当然是相当长的时间之后——注意，我说的是很长时间之后！——正是由于这种不关注，成功将降临于你。”</p>
<p>这个思想和道家的思想很相近，道家讲顺应自然，不要过于刻意。简单理解就是要顺应事物发展的客观规律。就像田野中的果树总是在春天开花结果待到秋天成熟，当你着急想吃到果子而勤劳的给果树浇水施肥，果子是不会提前在夏天成熟，你并不能提前吃到成熟的果子。但是如果你坚持浇水施肥并加以护理，待到秋天时，我想你一定能吃到成熟的香喷喷的果子。</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>活出生命的意义</tag>
      </tags>
  </entry>
  <entry>
    <title>《被讨厌的勇气》</title>
    <url>/2021/02/10/book/bei-tao-yan-de-yong-qi/</url>
    <content><![CDATA[<p><img src="/images/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94.jpg" alt="被讨厌的勇气"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><em><strong>《被讨厌的勇气》 —— “自我启发之父”阿德勒的哲学课</strong></em></p>
<blockquote>
<p>[日]案见一郎， 古贺史健<br>渠海霞 —— 译</p>
</blockquote>
<h1 id="书序"><a href="#书序" class="headerlink" title="书序"></a>书序</h1><p>小心检视，你的成功是否只是以害怕被他人讨厌而换来的。若是如此，那你的成功不幸只代表”你为他人活了一辈子” —— 陈文茜</p>
<h1 id="心里创伤并不存在"><a href="#心里创伤并不存在" class="headerlink" title="心里创伤并不存在"></a>心里创伤并不存在</h1><p>阿德勒在否定心理创伤学说的时候说了下面这段话：“任何经历本身并不是成功或者失败的原因。我们并非因为自身经历中的刺激——所谓的心理创伤——而痛苦，事实上我们会从经历中发现符合自己目的的因素。决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。”</p>
<p>阿德勒说，决定我们自己的不是“经验本身”而是“赋予经验的意义”。请你注意这一点。并不是说遭遇大的灾害或者幼年受到虐待之类的事件对人格形成毫无影响。相反，影响会很大。但关键是经历本身不会决定什么。我们给过去的经历“赋予了什么样的意义”，这直接决定了我们的生活。人生不是由别人赋予的，而是由自己选择的，是自己选择自己如何生活。</p>
<h1 id="一切烦恼都来自人际关系"><a href="#一切烦恼都来自人际关系" class="headerlink" title="一切烦恼都来自人际关系"></a>一切烦恼都来自人际关系</h1><p>在人际关系中根本不可能不受伤。只要涉入人际关系就会或大或小地受伤，也会伤害别人。阿德勒曾说“要想消除烦恼，只有一个人在宇宙中生存”。但是，那种事情根本就无法做到。</p>
<h1 id="自卑感"><a href="#自卑感" class="headerlink" title="自卑感"></a>自卑感</h1><p>自卑感的问题是我如何看待这种自己以及赋予它什么样的价值。困扰我们的自卑感不是”客观性的事实”而是”主观性的解释”。也就是说，价值必须建立在社会意义之上。与他人比较、自己赋予自己的意义，带来了自卑感。</p>
<h1 id="优越性"><a href="#优越性" class="headerlink" title="优越性"></a>优越性</h1><p>人都处于追求优越性这一”希望进步的状态”之中，树立某些理想或目标并努力为之奋斗。同时，对于无法达成理想的自己就会产生一种自卑感。而越自负的人越自卑，表现得自己好像很优秀，继而沉浸在一种虚假的优越感之中。健全的自卑感不是来自与别人的比较，而是来自与”理想的自己”的比较。</p>
<h1 id="寻求他人的认可"><a href="#寻求他人的认可" class="headerlink" title="寻求他人的认可"></a>寻求他人的认可</h1><p>阿德勒心理学否定寻求他人的认可。我们并不是为了满足别人的期待而活着，他人也不是为了满足你的期待而活。如果一味寻求别人的认可、在一别人的评价，那最终就会活在别人的人生中。</p>
<h1 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h1><p>“自由就是被别人讨厌”。毫不在意别人的评价、不害怕被别人讨厌、不追求被他人认可，如果不付出以上这些代价，那就无法贯彻自己的生活方式，也就是不能获得自由。</p>
<h1 id="最大的不幸"><a href="#最大的不幸" class="headerlink" title="最大的不幸"></a>最大的不幸</h1><p>对人而言，最大的不幸就是不喜欢自己。幸福就是”贡献感”。人只有在能够感觉到”我对别人有用”的时候才能体会到自己的价值。但是，这种贡献也可以童工看不见的形式实现。只要有”对别人有用”的主管感觉，即”贡献感”就可以。</p>
<h1 id="甘于平凡的勇气"><a href="#甘于平凡的勇气" class="headerlink" title="甘于平凡的勇气"></a>甘于平凡的勇气</h1><p>无论是希望特别优秀还是希望特别差劲，其目的都一样——引起他人的关注、脱离”普通”的状态、成为”特别的存在”。阿德勒心理学称之为”廉价的优越性追求”。我们根本没有必要特意炫耀自己的优越杏，要有甘于平凡的勇气。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在生活中我们经常想着要是我去做某事或我有什么样的条件我也可以取得成功，但是我们往往缺乏踏出那一步的勇气，更愿意以各种假想条件来安慰自己，活在自己想象的”可能性”之下。也许是担心梦可能会破灭，但是只有梦想破灭时我们才会有所成长吧～</p>
<p>读完这本书，对自己的心理认知又有了新的思考，其中最让我印象深刻的是阿德勒心理学否定了心理创伤。关于心理创伤，用阿德勒的观点简单理解就是我们面对眼前的困难不想做出改变，所以搬出心理创伤这个理由来逃避眼前的困难。而佛洛伊德是心理创伤理论的拥护者，他认为是由于心理创伤的存在，导致我们无法面对眼前的困难。这两种观点的本质就是目的论和原因论的区别。<br>从个人观点出发，我个人倾向于阿德勒的目的论，因为将心理创伤理解为目的论有助于我们做出积极的改变，克服困难。而如果将心理创伤理解为原因论，我们要么逃避要么原地踏步，无法积极做出改变应对困难。这种情况下，我们解决问题的方式成为了问题所在。<br>以上仅为个人的浅薄见解，因为对心理学这块没有深入的学习了解，没有太多的发言权，有时候在想心理创伤是否会导致我们身体出现应急反应，导致我们根本无法做出积极的改变，佛洛伊德的原因论也并不无道理。</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>被讨厌的勇气</tag>
      </tags>
  </entry>
  <entry>
    <title>《邓小平时代》</title>
    <url>/2021/06/08/book/deng-xiao-ping-shi-dai/</url>
    <content><![CDATA[<p><em><strong>《邓小平时代》—— 这是世界上第一本全面研究和记述邓小平政治生涯的著作</strong></em><br><img src="/images/%E9%82%93%E5%B0%8F%E5%B9%B3%E6%97%B6%E4%BB%A3.png" alt="邓小平时代"></p>
<p>不知不觉中发现自己对历史的兴趣越来越浓厚，不但把《明朝那些事儿》读了第二遍，而且为了对中国历史有一个更全面的认识，去看了朋友推荐的《中国通史》这部百集纪录片，直到现在用了半年时间看完了这本《邓小平时代》。<br>唐太宗曾说过：“以铜为镜，可以正衣冠；以史为镜，可以知兴替；以人为镜，可以明得失”。在历史的长河中，可以发现人类社会在不同时期仍有许多共同点，从而窥探到我们生活的社会的一些运行规律。</p>
<p>看完这本书后很多不曾明白的事情顿时豁然开朗，而邓小平跌宕起伏的人生以及其个人品质深深的折服了我，在我迷茫不知所措的时候，又多了一盏指引的明灯。</p>
<p>本想在这里总结一下邓小平的一生以及对中国乃至世界的影响，但是发现自己知识浅薄，对于介绍邓小平的书籍及文献仅读过此书。毛主席曾说：“没有调查，没有发言权”。于是作罢，就单单写写自己在此书中的收获吧。</p>
<h1 id="不争论，先尝试，见效之后再推广"><a href="#不争论，先尝试，见效之后再推广" class="headerlink" title="不争论，先尝试，见效之后再推广"></a>不争论，先尝试，见效之后再推广</h1><p>邓小平被称为改革开放的总设计师，但是在改革开放的工作中并不是一帆风顺的，在推行改革开放主要面临的阻力来自于当时的保守派，他们担心改革开放会使资本主义复辟。在这个方面，邓小平的做法就是：“不争论，先尝试，见效之后再推广”。<br>在生活中，很多事情都可以采取这种做法，通过试验结果再做选择，实践是检验真理的唯一标准，没必要一开始大家就争得头破血流。</p>
<h1 id="向美国、日本开放"><a href="#向美国、日本开放" class="headerlink" title="向美国、日本开放"></a>向美国、日本开放</h1><p>生活在当代的我们没有经历过战争，对于战争的认识仅限于书本上的历史事件。而且仅仅是通过历史我们都难以忘却中华民族遭受侵略，对于亲身经历过战争的邓小平来说，他们感受更为强烈。但是为什么在改革开放中要积极与美国日本建交？<br>从邓小平个人的情感和经历来说，战争虽然过去了，但是伤痛依旧。但是他作为国家领导他，必须为国家和人民利益着想，当时的中国需要美国、日本先进的工业技术来促进自身的发展，在个人情感和国家利益上他选择了后者。</p>
<h1 id="废除干部领导职务终身制"><a href="#废除干部领导职务终身制" class="headerlink" title="废除干部领导职务终身制"></a>废除干部领导职务终身制</h1><p>在我国两千多年的帝王统治中，国家干部领导和职务一直都是终身制。邓小平终结了毛泽东时代的领导人终身制，建立起任期制和退休制度。而且他自己带头执行退休制度，邓小平于1989年11月底辞职（于1997年2月逝世），将权利过度到了江泽明手中。<br>退休制能保证政府权利过度的稳定，这一点，在整个中国历史上是史无前例的。</p>
<h1 id="三落三起"><a href="#三落三起" class="headerlink" title="三落三起"></a>三落三起</h1><p>在我迷茫不知所措的时候，想起邓小平三落三起的人生经历，又会重新坚定自己的信念。给我印象最深刻的是邓小平在文革期间第二次被打倒，下放到江西劳改。<br>在文革期间，不仅邓小平本人受到了批斗，他的家庭成员也受到了迫害。邓小平的弟弟邓蜀平在文革中因为绝望而自杀，邓小平长子邓朴方在文革期间从四楼摔下来导致腰部以下瘫痪。他本人先是被软禁，后又被允许在拖拉机厂劳动。<br>这段时间被邓小平视为人生最痛苦的时期，然而就是在这样的处境之下，邓小平仍没有放弃自己的信念，他写信给毛主席，表示愿意为党和人民再做一些工作。</p>
<h1 id="三副一长"><a href="#三副一长" class="headerlink" title="三副一长"></a>三副一长</h1><p>1978年12月，邓小平在中共十一届三中全会上确立领导地位，取代时任中共中央主席、国务院总理华国锋成为中国实际上的最高领导人。虽然邓小平在1978年之后成为实际的最高领导人，但是在任职期间，并没有登上国家最高领导人的职位。<br>邓小平于1977年中共十届三中全会中第三次复出政坛，任中共中央副主席、国务院副总理、中央军委副主席和解放军总参谋长等党政军职务，合称三副一长。</p>
<h1 id="百万大裁军"><a href="#百万大裁军" class="headerlink" title="百万大裁军"></a>百万大裁军</h1><p> 在1985年中—1987年底期间，在当时的中国共产党中央军事委员会主席邓小平领导下，中国人民解放军裁军一百万人。<br> 邓小平提出裁军100万，理由主要有二。第一是因为解放军机构臃肿，每个军区的领导班子有十几名二十名之多，而且结构不合理，官兵比例是 1:2.6，远远高于其他国家。<br> 当时中国军费很少，而军队人数太多，直接限制了军队武器装备的发展和战斗力的提高。裁军可以节省开支、改善装备、提高军队素质。另一个裁军的理由是基于对国际形势的判断，短期内不会发生大的战争，要腾出更多的钱来搞建设，而且“即使战争爆发，我们也要消肿”。</p>
<p> 按照中央军委的决策部署，从1985年下半年开始，按照先机关，后部队、院校和保障单位的顺序，解放军自上而下地组织实施了百万大裁军。到1987年，中国人民解放军的总员额由423.8万人减到323.5万人。之后，又作了进一步的裁减，至1990年，全军总员额减到319.9万人，共裁减员额103.9万人。                   </p>
<h1 id="邓小平南巡"><a href="#邓小平南巡" class="headerlink" title="邓小平南巡"></a>邓小平南巡</h1><p>邓小平南巡，又称九二南巡，是指1992年1月18日至2月21日期间，邓小平在中国南方的深圳、珠海、广州、上海等地所做的巡视以及讲话，重申与改革开放相关的邓小平理论，并期许广东能按其“生产力为基础的发展观”发展经济在20年内追上亚洲四小龙。<br>邓小平的九二南巡在中华人民共和国历史上具有重要地位，因六四事件而放缓甚至停滞的中国改革开放自此重新提速，而九二南巡还拯救了当时中国新兴的资本市场。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《邓小平时代》一书是作者结合邓小平跌宕起伏的政治生涯和中国改革风云变幻的改革开放进程的全景式的描述。在读完整本书后，越发现自己的无知。<br>这里用之前看到的一段话来勉励自己。</p>
<blockquote>
<p>如果你觉得你的祖国不好，你就去建设它，如果你觉得政府不好，你就去考公务员去做官，如果你觉得人民没素质，就从你开始做一个高素质的公民，如果你觉得同胞愚昧无知，就从你开始学习并改变身边的人，而不是一昧的谩骂，抱怨，逃离。横眉冷对千夫指，俯首甘为孺子牛。<br>你所站立的地方，正是你的中国；你怎么样，中国便怎么样；你是什么，中国便是什么；你若光明，中国便不黑暗。愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p>
</blockquote>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>邓小平时代</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划之零一背包问题</title>
    <url>/2021/03/03/algorithm/dong-tai-gui-hua-zhi-ling-yi-bei-bao-wen-ti/</url>
    <content><![CDATA[<h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>有 NN 件物品和一个容量为 VV 的背包，每件物品有各自的价值，要求在有限的背包容量下，装入的物品总价值最大。</p>
<p>「0-1 背包」是较为简单的动态规划问题，也是其余背包问题的基础。</p>
<p>动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 ii 个物品的做出决策，「0-1」正好代表不选与选两种决定。</p>
<h1 id="二、题目分析"><a href="#二、题目分析" class="headerlink" title="二、题目分析"></a>二、题目分析</h1><blockquote>
<p>关于动态算法，了解的人可能需要2~3分钟，不懂的人可能需要2 ~ 3天，了解动态算法的思想很重要。</p>
</blockquote>
<h2 id="2-1-二维数据解法"><a href="#2-1-二维数据解法" class="headerlink" title="2.1 二维数据解法"></a>2.1 二维数据解法</h2><p>（1）状态f[i][j]定义：前 i 个物品，背包容量 j 下的最优解（最大价值）：</p>
<p>当前的状态依赖于之前的状态，可以理解为从初始状态f[0][0] = 0开始决策，有 N 件物品，则需要 N 次决 策，每一次对第 i 件物品的决策，状态f[i][j]不断由之前的状态更新而来。<br>（2）当前背包容量不够（j &lt; v[i]），没得选，因此前 i 个物品最优解即为前 i−1 个物品最优解：</p>
<p>对应代码：f[i][j] = f[i - 1][j]。<br>（3）当前背包容量够，可以选，因此需要决策选与不选第 i 个物品：</p>
<p>选：f[i][j] = f[i - 1][j - v[i]] + w[i]。<br>不选：f[i][j] = f[i - 1][j] 。<br>我们的决策是如何取到最大价值，因此以上两种情况取 max() 。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-none"><code class="language-none">public class MyBackpackSolution &#123;
    public static void main(String[] args) &#123;
        int[] weight &#x3D; &#123;2,2,6,5,4&#125;;
        int[] value &#x3D; &#123;6,3,5,4,6&#125;;

        int w &#x3D; 10;

        int n &#x3D; weight.length;
        int[][] maxVal &#x3D; new int[n + 1][w + 1];

        &#x2F;&#x2F; 由于循环从1开始，所以在遍历weight、value数组获取数据时坐标需要减一
        for(int i&#x3D;1; i&lt;&#x3D;n; i++) &#123;
            for (int j&#x3D;1; j&lt;&#x3D;w; j++) &#123;
                if (j &lt; weight[i-1]) &#123;
                    maxVal[i][j] &#x3D; maxVal[i-1][j];
                &#125; else &#123;
                    maxVal[i][j] &#x3D; Math.max(maxVal[i-1][j], maxVal[i-1][j - weight[i-1]] + value[i-1]);
                &#125;
            &#125;
        &#125;
        System.out.println(maxVal[n][w]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2-2-一维数组解法"><a href="#2-2-一维数组解法" class="headerlink" title="2.2 一维数组解法"></a>2.2 一维数组解法</h2><p>将状态f[i][j]优化到一维f[j]，实际上只需要做一个等价变形。</p>
<p>为什么可以这样变形呢？我们定义的状态f[i][j]可以求得任意合法的i与j最优解，但题目只需要求得最终状态f[n][m]，因此我们只需要一维的空间来更新状态。</p>
<p>（1）状态f[j]定义：NN 件物品，背包容量j下的最优解。</p>
<p>（2）注意枚举背包容量j必须从m开始。<br>（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态f[i][j]是由上一轮i - 1的状态得来的，f[i][j]与f[i - 1][j]是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。</p>
<p>（4）例如，一维状态第i轮对体积为 33 的物品进行决策，则f[7]由f[4]更新而来，这里的f[4]正确应该是f[i - 1][4]，但从小到大枚举j这里的f[4]在第i轮计算却变成了f[i][4]。当逆序枚举背包容量j时，我们求f[7]同样由f[4]更新，但由于是逆序，这里的f[4]还没有在第i轮计算，所以此时实际计算的f[4]仍然是f[i - 1][4]。</p>
<p>（5）简单来说，一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。</p>
<p>状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i] 。</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyBackpackSolution1 &#123;
    public static void main(String[] args) &#123;
        int[] weight &#x3D; &#123;2,2,6,5,4&#125;;
        int[] value &#x3D; &#123;6,3,5,4,6&#125;;

        int w &#x3D; 10;

        int n &#x3D; weight.length;

        int[] maxVal &#x3D; new int[w + 1];

        for (int i &#x3D; 1; i&lt;&#x3D; n; i++) &#123;
            for (int j&#x3D;w; j&gt;&#x3D; 1; j--) &#123;
                if (j &lt; weight[i-1]) &#123;
                    maxVal[j] &#x3D; maxVal[j];
                &#125; else &#123;
                    maxVal[j] &#x3D; Math.max(maxVal[j], maxVal[j - weight[i - 1]] + value[i-1]);
                &#125;
            &#125;
        &#125;
        System.out.println(maxVal[w]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>动态规划的核心还是找子问题的最有解，确定状态转移公式：<br>f[i][j]  = max(f[i - 1][j],  f[i - 1][j - v[i]] + w[i])</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.acwing.com/solution/content/1374/">AcWing 2. 01背包问题（状态转移方程讲解） </a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>零一背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>使用策略模式重构系统导入导出</title>
    <url>/2019/03/31/design-pattern/shi-yong-ce-lue-mo-shi-chong-gou-xi-tong-dao-ru-dao-chu/</url>
    <content><![CDATA[<p>​     合理的使用设计模式能提高代码的可维护性，但是往往一开始设计开发的时候没有考虑到业务的扩展性，在后期业务扩展的时候，需要在原有代码逻辑上增加新功能，这对开发人员来说无疑是非常痛苦的。刚好接到了在新的业务系统增加导入导出功能开发任务，在了解到系统原有导入导出复杂的逻辑后，决定利用策略模式来重构这一功能，降低开发的复杂度。</p>
<h1 id="系统原有导入导出"><a href="#系统原有导入导出" class="headerlink" title="系统原有导入导出"></a>系统原有导入导出</h1><p>​       系统原有使用异步导入导出方式，导入导出任务提交后，先将任务放到任务队列中去，使用一个线程不断从任务队列中获取待执行的任务交由任务线程池去执行。</p>
<blockquote>
<p>精简后的部分代码如下：</p>
</blockquote>
<p><strong>FileTaskExecutor.java</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 任务分发器线程内部类</span>
<span class="token keyword">class</span> <span class="token class-name">Boss</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token class-name">FileTask</span> task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
				task <span class="token operator">=</span> taskQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 导入导出任务封装为Worker交由线程池执行</span>
				executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Get next file task failed,cause by:&#123;&#125;"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 任务执行器线程内部类</span>
<span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">private</span> <span class="token class-name">FileTask</span> task<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>task <span class="token operator">=</span> task<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
			<span class="token class-name">FileType</span> fileType <span class="token operator">=</span> <span class="token class-name">FileUtil</span><span class="token punctuation">.</span><span class="token function">getFileType</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">FileHandler</span> fileHandler <span class="token operator">=</span> <span class="token class-name">FileHandlerFactory</span><span class="token punctuation">.</span><span class="token function">getFileHandler</span><span class="token punctuation">(</span>fileType<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">switch</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">case</span> <span class="token class-name">Import</span><span class="token operator">:</span>
                <span class="token comment">// 处理导入</span>
				<span class="token function">handleImport</span><span class="token punctuation">(</span>fileType<span class="token punctuation">,</span> task<span class="token punctuation">,</span> fileHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">commitFileTask</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> <span class="token class-name">TaskResult<span class="token punctuation">.</span>Success</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token keyword">case</span> <span class="token class-name">Export</span><span class="token operator">:</span>
                <span class="token comment">// 处理导出</span>
				<span class="token function">handleExport</span><span class="token punctuation">(</span>fileType<span class="token punctuation">,</span> task<span class="token punctuation">,</span> fileHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">commitFileTask</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> <span class="token class-name">TaskResult<span class="token punctuation">.</span>Success</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// TODO 异常情况下文件任务状态处理</span>
			<span class="token function">commitFileTask</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> <span class="token class-name">TaskResult<span class="token punctuation">.</span>Failed</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Execute file task failed,cause by:&#123;&#125;"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="导入关键步骤"><a href="#导入关键步骤" class="headerlink" title="导入关键步骤"></a>导入关键步骤</h3><p>根据导入的逻辑，导入主要包括以下几个步骤：</p>
<ul>
<li>1、读取导入文件，获取文件行内容</li>
<li>2、将文件行内容转换为实体类对象</li>
<li>3、将实体类对象保存到数据库</li>
<li>4、导入失败的对象重新写入文件并注明失败原因</li>
</ul>
<h3 id="导入代码实现"><a href="#导入代码实现" class="headerlink" title="导入代码实现"></a>导入代码实现</h3><p><strong>FileImporter.java</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">batchImport</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> rowList<span class="token punctuation">,</span> <span class="token class-name">FileHandler</span> fileHandler<span class="token punctuation">,</span> <span class="token class-name">ExportInfo</span> resultInfo<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">ImportInfo</span> importInfo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    task<span class="token punctuation">.</span><span class="token function">addHandledCount</span><span class="token punctuation">(</span>rowList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> headCells <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">getDataType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">case</span> <span class="token class-name">Blacklist</span><span class="token operator">:</span>
            headCells <span class="token operator">=</span> <span class="token class-name">FileHead</span><span class="token punctuation">.</span><span class="token function">getImportFailedHead</span><span class="token punctuation">(</span><span class="token class-name">FileHeader</span><span class="token punctuation">.</span>BLACKLIST<span class="token punctuation">)</span><span class="token punctuation">;</span>
            importInfo <span class="token operator">=</span> <span class="token function">importBlacklist</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> rowList<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Whitelist</span><span class="token operator">:</span>
            headCells <span class="token operator">=</span> <span class="token class-name">FileHead</span><span class="token punctuation">.</span><span class="token function">getImportFailedHead</span><span class="token punctuation">(</span><span class="token class-name">FileHeader</span><span class="token punctuation">.</span>WHITELIST<span class="token punctuation">)</span><span class="token punctuation">;</span>
            importInfo <span class="token operator">=</span> <span class="token function">importWhitelist</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> rowList<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Keyword</span><span class="token operator">:</span>
            headCells <span class="token operator">=</span> <span class="token class-name">FileHead</span><span class="token punctuation">.</span><span class="token function">getImportFailedHead</span><span class="token punctuation">(</span><span class="token class-name">FileHeader</span><span class="token punctuation">.</span>KEYWORD<span class="token punctuation">)</span><span class="token punctuation">;</span>
            importInfo <span class="token operator">=</span> <span class="token function">importKeyword</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> rowList<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">FileImportException</span><span class="token punctuation">(</span><span class="token string">"Invalid data type: "</span> <span class="token operator">+</span> task<span class="token punctuation">.</span><span class="token function">getDataType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 导入失败的记录写入文件，并注明失败原因</span>
    <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> cellsList <span class="token operator">=</span> importInfo<span class="token punctuation">.</span><span class="token function">getFailedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">writeResultInfoFile</span><span class="token punctuation">(</span>headCells<span class="token punctuation">,</span> cellsList<span class="token punctuation">,</span> task<span class="token punctuation">,</span> resultInfo<span class="token punctuation">,</span> fileHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * 导入黑名单
 * @param task
 * @param rowList
 * @return
 */</span>
<span class="token keyword">private</span> <span class="token class-name">ImportInfo</span> <span class="token function">importBlacklist</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> rowList<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">ImportInfo</span> impInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImportInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>
        <span class="token comment">// 文件行内容转换为实体类对象</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Blacklist</span><span class="token punctuation">></span></span> blacklists <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">parseBlacklist</span><span class="token punctuation">(</span>rowList<span class="token punctuation">,</span> task<span class="token punctuation">.</span><span class="token function">getParamsMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ListUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>blacklists<span class="token punctuation">)</span><span class="token punctuation">)</span>
            impInfo <span class="token operator">=</span> importDataService<span class="token punctuation">.</span><span class="token function">importBlacklist</span><span class="token punctuation">(</span>blacklists<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Import blacklist failed,cause by:&#123;&#125;"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        impInfo<span class="token punctuation">.</span><span class="token function">setResult</span><span class="token punctuation">(</span><span class="token class-name">Result<span class="token punctuation">.</span>Failed</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> impInfo<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>ImportService.java</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ImportInfo</span> <span class="token function">importBlacklist</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Blacklist</span><span class="token punctuation">></span></span> blacklists<span class="token punctuation">,</span> <span class="token class-name">FileTask</span> task<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">ImportInfo</span> importInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImportInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">ImportInfoBuild</span> importInfoBuild <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">getImportInfoBuild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// TODO 校验黑名单属性值是否合法</span>
		blacklistRepo<span class="token punctuation">.</span><span class="token function">addCachePhoneList</span><span class="token punctuation">(</span>blacklist<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 更新文件任务</span>
		task<span class="token punctuation">.</span><span class="token function">setHandledCount</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		task<span class="token punctuation">.</span><span class="token function">setHanldePercent</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">getCurPercent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		fileTaskRepo<span class="token punctuation">.</span><span class="token function">updateHandlingTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 返回导入详情</span>
		importInfo<span class="token punctuation">.</span><span class="token function">setResult</span><span class="token punctuation">(</span><span class="token class-name">Result<span class="token punctuation">.</span>Success</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		importInfo<span class="token punctuation">.</span><span class="token function">setResult</span><span class="token punctuation">(</span><span class="token class-name">Result<span class="token punctuation">.</span>Failed</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">throw</span> e<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> importInfo<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    上面代码是导入逻辑的关键代码，如果我们想新增一种导入类型，就必须扩展<strong>FileImporter</strong>类的switch分支，增加对应的导入类型和方法，并调用<strong>ImportService</strong>类中新增的导入方法。这样做的缺点就是随着系统导入类型增多，FileImporter类中的分支越来越多，ImportService类中代码量急剧膨胀，给后期开发和维护带来无尽麻烦。</p>
<p>​    同时从设计原则层面来说，这样设计实现违背了<strong>单一职责</strong>、<strong>开闭原则</strong>，所有的导入方法都写入一个类中，后期扩展需要在原有类的基础上进行修改。</p>
<h1 id="使用策略模式重构导入"><a href="#使用策略模式重构导入" class="headerlink" title="使用策略模式重构导入"></a>使用策略模式重构导入</h1><p>文件导入类中使用策略工厂获取对应的导入策略类，在策略类中将公共方法抽象为接口，这样在新增一种导入类型时，只需新增策略类并实现抽象方法即可。</p>
<p>   <strong>FileImporter.java</strong>（文件导入类）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">batchImport</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> rowList<span class="token punctuation">,</span> <span class="token class-name">FileHandler</span> fileHandler<span class="token punctuation">,</span> <span class="token class-name">ExportInfo</span> resultInfo<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 根据导入类型使用策略工厂获取对应的导入策略</span>
    <span class="token class-name">ImportFileStrategy</span> importFileStrategy <span class="token operator">=</span> importFileStrategyFactory<span class="token punctuation">.</span><span class="token function">fetchStrategy</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">getDataType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ImportInfo</span> impInfo <span class="token operator">=</span>  importFileStrategy<span class="token punctuation">.</span><span class="token function">importFile</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> rowList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 导入失败的记录写入文件，并注明失败原因</span>
    <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> cellsList <span class="token operator">=</span> importFileStrategy<span class="token punctuation">.</span><span class="token function">dataConvert</span><span class="token punctuation">(</span>impInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">writeResultInfoFile</span><span class="token punctuation">(</span>headCells<span class="token punctuation">,</span> cellsList<span class="token punctuation">,</span> task<span class="token punctuation">,</span> resultInfo<span class="token punctuation">,</span> fileHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>DefaultImportFileStrategyFactory.java</strong>(导入策略工厂类)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultImportFileStrategyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ImportFileStrategyFactory</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> STRATEGY_SUFFIX <span class="token operator">=</span> <span class="token string">"ImportFileStrategy"</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">DefaultImportFileStrategyFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ImportFileStrategy</span> <span class="token function">fetchStrategy</span><span class="token punctuation">(</span><span class="token class-name">String</span> typeName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ImportFileStrategyFactoryException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ImportFileStrategy</span> importFileStrategy <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>typeName <span class="token operator">+</span> STRATEGY_SUFFIX<span class="token punctuation">,</span> <span class="token class-name">ImportFileStrategy</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>importFileStrategy <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Fetch ImportFileStrategy failed,Unknown strategy type:&#123;&#125;"</span><span class="token punctuation">,</span>typeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ImportFileStrategyFactoryException</span><span class="token punctuation">(</span><span class="token class-name">MessageFormat</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Fetch ImportFileStrategy failed,Unknown strategy type:&#123;0&#125;"</span><span class="token punctuation">,</span>typeName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> importFileStrategy<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>ImportFileStrategy.java**(导入策略接口)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ImportFileStrategy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>

    <span class="token class-name">ImportInfo</span> <span class="token function">importFile</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> rowList<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getImportFileHeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">dataConvert</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>AbstractImportFileStrategy.java</strong>(导入策略抽象类)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractImportFileStrategy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">ImportFileStrategy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ImportInfo</span> <span class="token function">importFile</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> rowList<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> params <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">getParamsMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> elements <span class="token operator">=</span> <span class="token function">rowList2Objects</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> rowList<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">importList</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">rowList2Objects</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> rowList<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token class-name">ImportInfo</span> <span class="token function">importList</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> elements<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>BlacklistImportFileStrategy.java</strong>(黑名单导入策略类)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlacklistImportFileStrategy</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractImportFileStrategy</span><span class="token operator">&lt;</span><span class="token class-name">Blacklist</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Blacklist</span><span class="token punctuation">></span></span> <span class="token function">rowList2Objects</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> rowList<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO 文件行内容转换为实体类对象</span>
        <span class="token keyword">return</span> blacklist<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">ImportInfo</span> <span class="token function">importList</span><span class="token punctuation">(</span><span class="token class-name">FileTask</span> task<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Blacklist</span><span class="token punctuation">></span></span> elements<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO 将对象列表存储到数据库</span>
        <span class="token keyword">return</span> importInfo<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getImportFileHeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 获取文件头信息</span>
        <span class="token keyword">return</span> header<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">dataConvert</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Blacklist</span><span class="token punctuation">></span></span> elements<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 将类对象转换为文件行内容</span>
        <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从上我们可以看出，当我们需要新增一个导出类型时，只需新增一个导出策略类并继承<strong>AbstractImportFileStrategy</strong>抽象类，实现所有抽象方法即可。</p>
<p>系统导出的问题与导入类似，重构的方法也是类似的，这里不再赘述。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID生成方案</title>
    <url>/2022/01/17/distributed/fen-bu-shi-id-sheng-cheng-fang-an/</url>
    <content><![CDATA[<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>由于MySQL的单表数据量超过了千万级别，需要根据日期对数据库进行水平分表，分表后需要保证每个分表Id的全局唯一性，原来单表使用自增保证Id的有序性和唯一性，分表后需要生成全局唯一的Id。</p>
<p>所以接下来讨论一下分布式Id的生成方案，以及各种方案的优缺点等。</p>
<h1 id="二、分布式ID生成方案"><a href="#二、分布式ID生成方案" class="headerlink" title="二、分布式ID生成方案"></a>二、分布式ID生成方案</h1><h2 id="2-1-UUID"><a href="#2-1-UUID" class="headerlink" title="2.1 UUID"></a>2.1 UUID</h2><blockquote>
<p>A universally unique identifier (UUID) is a 128-bit label used for information in computer systems. The term globally unique identifier (GUID) is also used<br>通用唯一识别码（英语：Universally Unique Identifier，缩写：UUID）是用于计算机体系中以识别信息的一个128位标识符。</p>
</blockquote>
<p>根据标准方法生成，不依赖中央机构的注册和分配，UUID具有唯一性，这与其他大多数编号方案不同。重复UUID码概率接近零，可以忽略不计。<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81">通用唯一识别码-维基百科</a></p>
<h3 id="2-1-1-UUID定义"><a href="#2-1-1-UUID定义" class="headerlink" title="2.1.1 UUID定义"></a>2.1.1 UUID定义</h3><p>UUID是由一个16进制下的32位数所构成，故UUID理论上的总数为16的32次方=2的128次方，约等于3.4 x 10的38次方。也就是说若每纳秒（ns）产生1万亿个UUID，要花100亿年才会将所有UUID用完。</p>
<p>UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为 8-4-4-4-12 的32个字符。示例：<code>550e8400-e29b-41d4-a716-446655440000</code></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>生成容易、速度快</li>
<li>ID唯一（几乎不会产生重复ID，部分实现依赖于MAC硬件地址）</li>
<li>无需中心化服务器</li>
<li>不会泄露商业机密</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>可读性差</li>
<li>占用空间太多（16个字节）</li>
<li>作为数据库主键时，影响数据库性能</li>
</ul>
<blockquote>
<h4 id="为什么UUID不建议作为MySQL数据库表的主键？"><a href="#为什么UUID不建议作为MySQL数据库表的主键？" class="headerlink" title="为什么UUID不建议作为MySQL数据库表的主键？"></a>为什么UUID不建议作为MySQL数据库表的主键？</h4><p>MySQL数据库InnoDB存储引擎使用了聚簇索引，底层使用B+树来存储数据，B+树的非叶子节点存储索引数据，叶子节点存储具体的行数据，每个节点的大小默认为<code>16KB</code>。<br>其中叶子节点内部的记录根据主键大小进行排序，叶子节点之间使用双向链表进行连接。</p>
<p>如果使用UUID作为主键，由于UUID是无序的，在进行插入操作的时候，存储引擎需要维护主键索引的顺序,一条新的记录插入进来，可能会被插入到之前已经存放满的叶子结点内，此时将会产生页分裂，带来性能损耗。<br>根据MySQL InnoDb存储引擎的聚簇索引的特性，建议主键选取为递增有序的字段。</p>
</blockquote>
<h2 id="2-2-基于数据库自增ID"><a href="#2-2-基于数据库自增ID" class="headerlink" title="2.2 基于数据库自增ID"></a>2.2 基于数据库自增ID</h2><p>通过关系型数据库自增主键产生唯一的ID，现在流行的商业数据库都支持自增主键的特性，比如MySQL等。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>容易产生</li>
<li>ID单调递增</li>
<li>存储很小（int类型占用4个字节，bigint类型占用8个字节）</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>依赖于数据库、而且需要处理单点问题，而且单点有性能瓶颈问题</li>
<li>每次生成一个ID都需要访问一次数据库</li>
</ul>
<blockquote>
<p>关于数据库单点风险的问题可以通过数据库集群模式去优化，部署多个数据库实例，每个实例均可产生Id，每个数据库实例设置不通过的起始值和自增步长。<br>这种方式虽可以解决点单点问题，但是不利于后续的扩容。</p>
</blockquote>
<h2 id="2-3-基于数据库的分段发号方案"><a href="#2-3-基于数据库的分段发号方案" class="headerlink" title="2.3 基于数据库的分段发号方案"></a>2.3 基于数据库的分段发号方案</h2><p>号段方案是当下分布式ID生成器的主流实现方式之一，分段方案使用数据库表来存储最大ID，每次获取一个范围段的ID，获取后更新数据库表，并将这一段ID加载到内从中，在内存中进行分配，内存中的ID号段使用完成后，再从数据库中获取。</p>
<h3 id="数据库表结构示例："><a href="#数据库表结构示例：" class="headerlink" title="数据库表结构示例："></a>数据库表结构示例：</h3><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE id_generator (  &#96;id&#96; int(10) NOT NULL,  
&#96;max_id&#96; bigint(20) NOT NULL COMMENT &#39;当前最大id&#39;,  
&#96;step&#96; int(20) NOT NULL COMMENT &#39;号段的步长&#39;,  
&#96;biz_type&#96;    int(20) NOT NULL COMMENT &#39;业务类型&#39;,  
&#96;version&#96; int(20) NOT NULL COMMENT &#39;版本号&#39;,  
PRIMARY KEY (&#96;id&#96;)
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>max_id ：当前最大的可用id</li>
<li>step ：代表号段的长度</li>
<li>biz_type ：代表不同业务类型</li>
<li>version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</li>
</ul>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>相对于数据库自增的Id，有效减轻了数据库压力</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>依赖于数据库</li>
<li>每个节点产生的Id号段内递增</li>
</ul>
<h2 id="2-4-基于Redis的原子性递增"><a href="#2-4-基于Redis的原子性递增" class="headerlink" title="2.4 基于Redis的原子性递增"></a>2.4 基于Redis的原子性递增</h2><blockquote>
<h3 id="INCR-key"><a href="#INCR-key" class="headerlink" title="INCR key"></a>INCR key</h3><h4 id="Available-since-1-0-0"><a href="#Available-since-1-0-0" class="headerlink" title="Available since 1.0.0."></a>Available since 1.0.0.</h4></blockquote>
<blockquote>
<h4 id="Time-complexity-O-1"><a href="#Time-complexity-O-1" class="headerlink" title="Time complexity: O(1)"></a>Time complexity: O(1)</h4></blockquote>
<blockquote>
<p>Increments the number stored at key by one. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</p>
</blockquote>
<blockquote>
<p>Note: this is a string operation because Redis does not have a dedicated integer type. The string stored at the key is interpreted as a base-10 64 bit signed integer to execute the operation.</p>
</blockquote>
<blockquote>
<p>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</p>
</blockquote>
<p>Redis提供了<code>incr</code>指令，该指令可以对key中存储的值进行<code>+1</code>操作（Redis不支持Integer类型，key中存储的string值将会被转为一个64位的有符号整数进行操作）。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>实现简单</li>
<li>生成id效率高</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>强依赖于数据库</li>
<li>需要考虑Redis持久化的问题</li>
</ul>
<h2 id="2-5-基于雪花算法（Snowflake）"><a href="#2-5-基于雪花算法（Snowflake）" class="headerlink" title="2.5 基于雪花算法（Snowflake）"></a>2.5 基于雪花算法（Snowflake）</h2><p>snowflake是Twitter开源的分布式ID生成算法，生成的结果是一个Long类型的ID。</p>
<p>snowflake使用64bit来生成ID，由高位到低位成部分如下：</p>
<ul>
<li>1bit作为保留位，没有使用，永远是0</li>
<li>41bit作为时间戳，表示从1970-01-01年以来的毫秒数</li>
<li>10bit作为机器ID（5bit是数据中心，5bit是机器ID）</li>
<li>12bit作为毫秒内的流水号，每毫秒可以生成4096个ID</li>
</ul>
<p>雪花算法每秒可以生成400万+的ID，由于高位41位使用了时间戳，所以各节点生成的ID都是大致有序的。</p>
<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul>
<li>实现简单</li>
<li>不依赖其它组件</li>
<li>生成ID速度快</li>
</ul>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>生成的Id是趋势递增的（绝对递增会导致业务信息泄露）</li>
<li>依赖机器时间，需要处理时钟回拨的问题</li>
</ul>
<h2 id="2-6-百度-UidGenerator"><a href="#2-6-百度-UidGenerator" class="headerlink" title="2.6 百度(UidGenerator)"></a>2.6 百度(UidGenerator)</h2><p>UidGenerator是Java实现的, 基于Snowflake算法的唯一ID生成器。UidGenerator以组件形式工作在应用项目中, 支持自定义workerId位数和初始化策略, 从而适用于docker等虚拟化环境下实例自动重启、漂移等场景。 在实现上, UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万。</p>
<p>依赖版本：Java8及以上版本, MySQL(内置WorkerID分配器, 启动阶段通过DB进行分配; 如自定义实现, 则DB非必选依赖）</p>
<table>
<thead>
<tr>
<th>sign</th>
<th>delta seconds</th>
<th>worker node id</th>
<th>sequence</th>
</tr>
</thead>
<tbody><tr>
<td>1bit</td>
<td>28bits</td>
<td>22bits</td>
<td>13bits</td>
</tr>
</tbody></table>
<p>Snowflake算法描述：指定机器 &amp; 同一时刻 &amp; 某一并发序列，是唯一的。据此可生成一个64 bits的唯一ID（long）。默认采用上图字节分配方式：</p>
<ul>
<li>sign(1bit)<br>固定1bit符号标识，即生成的UID为正数。</li>
<li>delta seconds (28 bits)<br>当前时间，相对于时间基点”2016-05-20”的增量值，单位：秒，最多可支持约8.7年</li>
<li>worker id (22 bits)<br>机器id，最多可支持约420w次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。</li>
<li>sequence (13 bits)<br>每秒下的并发序列，13 bits可支持每秒8192个并发。<br>以上参数均可通过Spring进行自定义。</li>
</ul>
<h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以根据业务调整<code>delta seconds</code>、<code>worker id</code>、<code>sequence</code>的长度</li>
</ul>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>依赖于数据库表</li>
</ul>
<p><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">UidGenerator</a></p>
<h2 id="2-7-美团-Leaf"><a href="#2-7-美团-Leaf" class="headerlink" title="2.7 美团(Leaf)"></a>2.7 美团(Leaf)</h2><p>Leaf这个名字是来自德国哲学家、数学家莱布尼茨的一句话： &gt;There are no two identical leaves in the world &gt; “世界上没有两片相同的树叶”</p>
<h3 id="Leaf-segment数据库方案"><a href="#Leaf-segment数据库方案" class="headerlink" title="Leaf-segment数据库方案"></a>Leaf-segment数据库方案</h3><p>第一种Leaf-segment方案，在使用数据库的方案上，做了如下改变： - 原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。</p>
<h3 id="Leaf-snowflake方案"><a href="#Leaf-snowflake方案" class="headerlink" title="Leaf-snowflake方案"></a>Leaf-snowflake方案</h3><p>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。面对这一问题，我们提供了 Leaf-snowflake方案。<br>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p>
<ul>
<li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li>
<li>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li>
<li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li>
</ul>
<p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统</a></p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>上面介绍了6种分布式ID生成方案：</p>
<ul>
<li>UUID</li>
<li>基于数据库自增ID</li>
<li>基于数据库的分段发号方案</li>
<li>基于Redis的原子性递增</li>
<li>基于雪花算法（Snowflake）</li>
<li>百度(UidGenerator)</li>
<li>美团(Leaf)</li>
</ul>
<p>以上分布式ID生成方案又可以大致分为三类：</p>
<ul>
<li>UUID生成随机字符串，基本可以保证全局唯一，这类方法生成的ID占用空间较大（16字节）,而且生成的ID无序。</li>
<li>基于数据库生成的单调递增的ID，需要解决单点及性能问题，而且可能会导致业务数据泄露。<br>比如：通过订单ID推测出业务系统每天的订单量</li>
<li>snowflake算法类，对ID进行分段，分段表示时间、机器节点、序列号等，此类算法中由于包含时间段，所以需要考虑时钟回拨的问题。</li>
</ul>
<blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://colobu.com/2020/02/21/ID-generator/">分布式ID生成方案</a></p>
<p><a href="https://juejin.cn/post/6854573222290161672">9种分布式ID生成方式，总有一款适合你</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式ID</tag>
      </tags>
  </entry>
  <entry>
    <title>系统稳定性与高可用保障的思考</title>
    <url>/2022/02/24/distributed/xi-tong-wen-ding-xing-yu-gao-ke-yong-bao-zhang-de-si-kao/</url>
    <content><![CDATA[<blockquote>
<p>原文地址：<a href="%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BF%9D%E9%9A%9C%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%80%9D%E8%B7%AF">稳定性与高可用保障的工作思路</a>， 本文在原文的基础上做了一些补充和删减。</p>
</blockquote>
<h1 id="一、深入理解稳定性与高可用"><a href="#一、深入理解稳定性与高可用" class="headerlink" title="一、深入理解稳定性与高可用"></a>一、深入理解稳定性与高可用</h1><blockquote>
<p>维基百科上稳定性与高可用性的定义</p>
</blockquote>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><blockquote>
<p>稳定性是数学或工程上的用语，判别一系统在有界的输入是否也产生有界的输出。若是，称系统为稳定；若否，则称系统为不稳定。</p>
</blockquote>
<p>关于稳定性的定义我们可以总结归纳为 – 当系统接收输入后，能够产生正确的、符合预期的输出，称系统为稳定；否则，称系统为不稳定。</p>
<p>稳定性描述的是系统的行为，一个系统是否稳定，很难进行量化，但是可以通过否定的方式进行快速地判断。保障系统的稳定性或者说提高系统的稳定性需要通过各种方法来避免那些不稳定的情况发生。所谓的更稳定，客观上并不存在，是主观上希望避免或者减少不稳定的情况发生。</p>
<h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><blockquote>
<p>高可用性（英语：high availability，缩写为 HA），IT术语，指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行。</p>
</blockquote>
<p>与稳定性不同，可用性一个可以量化的指标，计算公式在维基百科中描述如下：</p>
<blockquote>
<p>根据系统损害、无法使用的时间，以及由无法运作恢复到可运作状态的时间，与系统总运作时间的比较。<br>计算公式：<br><img src="/2022/02/24/distributed/xi-tong-wen-ding-xing-yu-gao-ke-yong-bao-zhang-de-si-kao/formula.svg" alt="高可用计算公式"></p>
</blockquote>
<ul>
<li>A（可用性）</li>
<li>MTTR(Mean Time To Repair): 平均修复时间，指系统从发生故障到维修结束之间的时间段的平均值， MTTR越短，表示易恢复性越好。</li>
<li>MTTF(即 Mean Time To Failure): 平均无故障时间。指系统无故障运行的平均时间，取所有从系统开始正常运行到发生故障之间的时间段的平均值，MTTF越长，表示系统可靠性越高。</li>
<li>MTBF(Mean Time Between Failures):平均故障间隔，指系统两次故障发生时间之间的时间段的平均值，MTBF越长，表示出现故障出现的越不频繁。</li>
</ul>
<p> <img src="/2022/02/24/distributed/xi-tong-wen-ding-xing-yu-gao-ke-yong-bao-zhang-de-si-kao/MTTR-MTBF-and-MTTF.jpg" alt="MTTR-MTBF-and-MTTF"><br>从定义还可以看出，<code>MTBF = MTTR + MTTF</code>。</p>
<p>在线系统和执行关键任务的系统通常要求其可用性要达到5个9标准(99.999%)。</p>
<table>
<thead>
<tr>
<th>可用性</th>
<th>年故障时间</th>
</tr>
</thead>
<tbody><tr>
<td>99.9999%</td>
<td>32秒</td>
</tr>
<tr>
<td>99.999%</td>
<td>5分15秒</td>
</tr>
<tr>
<td>99.99%</td>
<td>52分34秒</td>
</tr>
<tr>
<td>99.9%</td>
<td>8小时46分</td>
</tr>
<tr>
<td>99%</td>
<td>3天15小时36分</td>
</tr>
</tbody></table>
<blockquote>
<p>以上内容出自:<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7#cite_note-snia-1">维基百科-高可用性</a></p>
</blockquote>
<p>综上所述，保障系统的稳定系及高可用的目标是使系统处于稳定的工作状态，避免线上问题及故障发生。其次，出现非稳定状态时，能够快速发现并将其恢复到稳定可用的状态。</p>
<h1 id="二、稳定性与高可用保障的核心思路"><a href="#二、稳定性与高可用保障的核心思路" class="headerlink" title="二、稳定性与高可用保障的核心思路"></a>二、稳定性与高可用保障的核心思路</h1><p><img src="/2022/02/24/distributed/xi-tong-wen-ding-xing-yu-gao-ke-yong-bao-zhang-de-si-kao/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="高可用解决方案"></p>
<h2 id="2-1-应用系统中常见非稳定的情况"><a href="#2-1-应用系统中常见非稳定的情况" class="headerlink" title="2.1 应用系统中常见非稳定的情况"></a>2.1 应用系统中常见非稳定的情况</h2><ul>
<li><p>功能：应用程序执行的功能出现错误，不符合预期。</p>
</li>
<li><p>容量：当系统接收的请求数量增加时，应用程序无法正常处理，出现异常或超时，导致服务失效。</p>
</li>
<li><p>安全：当系统接收到的没有授权的或者恶意攻击的请求时，应用程序出现异常甚至服务失效。</p>
</li>
<li><p>容错：对于用户错误的使用方式, 应用程序无法合适地处理。</p>
</li>
</ul>
<h2 id="2-2-软件系统问题原因归类"><a href="#2-2-软件系统问题原因归类" class="headerlink" title="2.2 软件系统问题原因归类"></a>2.2 软件系统问题原因归类</h2><ul>
<li><p>人为故障：在开发软件的各个环节中思考不充分，或者执行时粗心导致的各类问题。</p>
</li>
<li><p>硬件故障：网络不通，硬盘空间不够，内存崩溃等。</p>
</li>
<li><p>软件故障：线程池异常，JVM异常，中间件或其他依赖的应用服务异常。</p>
</li>
</ul>
<p>对于一个动态演进的系统而言，我们没有办法将故障发生的概率降为0，只能通过在软件生产的过程中，建立流程规范和机制来尽量减少其发生。其次对于一个运行的系统，我们需要建立并完善监控和预警机制来及时发现系统中的故障，并通过执行预案使系统快速恢复。基于上述结论，为了提高系统的可用性，需要从以下三个方面入手开展工作：故障预防，故障发现和故障恢复。</p>
<p><img src="/2022/02/24/distributed/xi-tong-wen-ding-xing-yu-gao-ke-yong-bao-zhang-de-si-kao/%E6%95%85%E9%9A%9C%E7%B1%BB%E5%9E%8B%E5%8F%8A%E9%A2%84%E9%98%B2%E6%8E%AA%E6%96%BD.png" alt="故障类型及预防措施"></p>
<p>人犯错的几率是远远大于机器的，因此故障预防最重要的是建立一套机制，在团队内达成共识并持续按照此流程开展研发工作，从而减少个人因素（思考、执行、状态等方面）对系统稳定性的影响。而故障发现以及故障恢复，则是需要通过系统监控和应急方案来快速发现系统异常并恢复，从而尽量减轻故障的影响面。</p>
<h2 id="2-3-稳定性与高可用保障方案"><a href="#2-3-稳定性与高可用保障方案" class="headerlink" title="2.3 稳定性与高可用保障方案"></a>2.3 稳定性与高可用保障方案</h2><p>下面以蚂蚁日常的产品研发流程为例，从功能、容量、安全、容错这4个核心要素出发，给出一套方案仅供参考。<br><img src="/2022/02/24/distributed/xi-tong-wen-ding-xing-yu-gao-ke-yong-bao-zhang-de-si-kao/%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BF%9D%E9%9A%9C%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="稳定性保障及高可用"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>稳定性和高可用是一个很庞大的命题，底层开发者来在设计开发过程中，缺乏一套系统的框架思路，缺少对于稳定性和高可用的方案系统全面的考量。通过对上述稳定性和高可用的理解，可以从故障预防、故障发现、故障恢复三个层面进行稳定性和高可用保障。而对于具体的方案可以从研发规范、容量保障、监控告警、应急快反这四个核心要素制定相关规范，从实现系统的稳定性和高可用的保障。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法源码分析及实践</title>
    <url>/2022/01/18/distributed/xue-hua-suan-fa-yuan-ma-fen-xi-ji-shi-jian/</url>
    <content><![CDATA[<h1 id="一、雪花算法简介"><a href="#一、雪花算法简介" class="headerlink" title="一、雪花算法简介"></a>一、雪花算法简介</h1><p>雪花算法（Snowflake）是一种生成分布式全局唯一ID的算法，这种算法由Twitter创建并开源。</p>
<p>雪花算法由64位的二进制组成，刚好可以用一个Long类型存储，一共包含四个部分：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>时间戳</th>
<th>数据中心和机器ID</th>
<th>序列号</th>
</tr>
</thead>
<tbody><tr>
<td>1 bit</td>
<td>41 bits</td>
<td>10 bits</td>
<td>12 bits</td>
</tr>
</tbody></table>
<ul>
<li>1位是符号位，没有被使用，始终是0</li>
<li>41位是时间戳，具体到毫秒，表示现在至1970年以来的毫秒数，最多可用69年</li>
<li>10位是数据中心和机器ID，10位最多可以表示1024台机器</li>
<li>12位是序列号，表示毫秒内生成的序列号，每毫秒最多可生成4096个ID</li>
</ul>
<h1 id="二、雪花算法源码-java"><a href="#二、雪花算法源码-java" class="headerlink" title="二、雪花算法源码(java)"></a>二、雪花算法源码(java)</h1><blockquote>
<p>雪花算法Java版本源码来自<code>beyondfengyu</code>的github：<a href="https://github.com/beyondfengyu/SnowFlake/blob/master/SnowFlake.java">Snowflake</a></p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * twitter的snowflake算法 -- java实现
 * 
 * @author beyond
 * @date 2016&#x2F;11&#x2F;26
 *&#x2F;
public class SnowFlake &#123;

    &#x2F;**
     * 起始的时间戳
     *&#x2F;
    private final static long START_STMP &#x3D; 1480166465631L;

    &#x2F;**
     * 每一部分占用的位数
     *&#x2F;
    private final static long SEQUENCE_BIT &#x3D; 12; &#x2F;&#x2F;序列号占用的位数
    private final static long MACHINE_BIT &#x3D; 5;   &#x2F;&#x2F;机器标识占用的位数
    private final static long DATACENTER_BIT &#x3D; 5;&#x2F;&#x2F;数据中心占用的位数

    &#x2F;**
     * 每一部分的最大值
     * 二进制位运算过程如下：
     * 负数的二进制用补码（整数的二进制位取反后加一）表示，-1的补码的二进制位全部为1，进行&#96;&lt;&lt;&#96;左移运算后低位补0，高位全部都是1
     * 再与-1进行&#96;^&#96;异或运算（这里可以替换为&#96;~&#96;取反运算），则高位全部变为0，低位变为1
     *&#x2F;
    private final static long MAX_DATACENTER_NUM &#x3D; -1L ^ (-1L &lt;&lt; DATACENTER_BIT);
    private final static long MAX_MACHINE_NUM &#x3D; -1L ^ (-1L &lt;&lt; MACHINE_BIT);
    private final static long MAX_SEQUENCE &#x3D; -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);

    &#x2F;**
     * 每一部分向左的位移
     *&#x2F;
    private final static long MACHINE_LEFT &#x3D; SEQUENCE_BIT;
    private final static long DATACENTER_LEFT &#x3D; SEQUENCE_BIT + MACHINE_BIT;
    private final static long TIMESTMP_LEFT &#x3D; DATACENTER_LEFT + DATACENTER_BIT;

    private long datacenterId;  &#x2F;&#x2F;数据中心
    private long machineId;     &#x2F;&#x2F;机器标识
    private long sequence &#x3D; 0L; &#x2F;&#x2F;序列号
    private long lastStmp &#x3D; -1L;&#x2F;&#x2F;上一次时间戳

    public SnowFlake(long datacenterId, long machineId) &#123;
        if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) &#123;
            throw new IllegalArgumentException(&quot;datacenterId can&#39;t be greater than MAX_DATACENTER_NUM or less than 0&quot;);
        &#125;
        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;
            throw new IllegalArgumentException(&quot;machineId can&#39;t be greater than MAX_MACHINE_NUM or less than 0&quot;);
        &#125;
        this.datacenterId &#x3D; datacenterId;
        this.machineId &#x3D; machineId;
    &#125;

    &#x2F;**
     * 产生下一个ID
     *
     * @return
     *&#x2F;
    public synchronized long nextId() &#123;
        long currStmp &#x3D; getNewstmp();
        if (currStmp &lt; lastStmp) &#123;
            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);
        &#125;

        if (currStmp &#x3D;&#x3D; lastStmp) &#123;
            &#x2F;&#x2F;相同毫秒内，序列号自增
            sequence &#x3D; (sequence + 1) &amp; MAX_SEQUENCE;
            &#x2F;&#x2F;同一毫秒的序列数已经达到最大
            if (sequence &#x3D;&#x3D; 0L) &#123;
                currStmp &#x3D; getNextMill();
            &#125;
        &#125; else &#123;
            &#x2F;&#x2F;不同毫秒内，序列号置为0
            sequence &#x3D; 0L;
        &#125;

        lastStmp &#x3D; currStmp;

        return (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT &#x2F;&#x2F;时间戳部分
                | datacenterId &lt;&lt; DATACENTER_LEFT       &#x2F;&#x2F;数据中心部分
                | machineId &lt;&lt; MACHINE_LEFT             &#x2F;&#x2F;机器标识部分
                | sequence;                             &#x2F;&#x2F;序列号部分
    &#125;

    private long getNextMill() &#123;
        long mill &#x3D; getNewstmp();
        while (mill &lt;&#x3D; lastStmp) &#123;
            mill &#x3D; getNewstmp();
        &#125;
        return mill;
    &#125;

    private long getNewstmp() &#123;
        return System.currentTimeMillis();
    &#125;

    public static void main(String[] args) &#123;
        SnowFlake snowFlake &#x3D; new SnowFlake(2, 3);

        for (int i &#x3D; 0; i &lt; (1 &lt;&lt; 12); i++) &#123;
            System.out.println(snowFlake.nextId());
        &#125;

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码中有两个关键的步骤:</p>
<ul>
<li>获取ID时，如果在同一毫秒内，则在序列号上递增</li>
<li>如果同一毫秒内的序列号已经递增到最大值<code>4095</code>，则通过循坏阻塞直到下一毫秒到来</li>
</ul>
<p>所以雪花算法每毫秒最多可生成4096个ID，每秒最多可生成400万+的ID。</p>
<h1 id="三、时钟回拨"><a href="#三、时钟回拨" class="headerlink" title="三、时钟回拨"></a>三、时钟回拨</h1><p>从上述雪花算法的组成及源码可以看出，雪花算法是强依赖于机器时间的，如果机器发生了时钟回拨，则就会产生重复ID，所以必须解决时钟回拨的问题，防止影响业务。</p>
<h2 id="3-1-解决方案"><a href="#3-1-解决方案" class="headerlink" title="3.1 解决方案"></a>3.1 解决方案</h2><h3 id="时钟回拨后不生成ID，循环等待时间点到达"><a href="#时钟回拨后不生成ID，循环等待时间点到达" class="headerlink" title="时钟回拨后不生成ID，循环等待时间点到达"></a>时钟回拨后不生成ID，循环等待时间点到达</h3><ul>
<li>优点：实现简单，适合时间较小的时钟回拨</li>
<li>缺点：回拨时间间隔较大时，会造成业务阻塞</li>
</ul>
<h3 id="使用LRU缓存近一段时间内每毫秒内的最大序列号"><a href="#使用LRU缓存近一段时间内每毫秒内的最大序列号" class="headerlink" title="使用LRU缓存近一段时间内每毫秒内的最大序列号"></a>使用LRU缓存近一段时间内每毫秒内的最大序列号</h3><p>使用LRU缓存近一段时间内每一毫秒的最大序列号，如果发生时钟回拨，则从最大序列号继续递增，适合小范围内时钟回拨</p>
<ul>
<li>优点：实现简单，适合小范围时间回拨</li>
<li>缺点：当回拨时间较长时，需要缓存数据量太大</li>
</ul>
<h3 id="设置备用的数据中心"><a href="#设置备用的数据中心" class="headerlink" title="设置备用的数据中心"></a>设置备用的数据中心</h3><p>为每个节点预留一个备用的配置中心ID，当出现时钟回拨时，切换到备用的数据中心生成ID，时钟到达正常时间切换回原来的数据中心ID。</p>
<ul>
<li>优点：实现简单，适合任意范围内的时钟回拨</li>
<li>缺点： 需要占用掉一部分数据中心ID作为备用</li>
</ul>
<p>以上几种方式都没有考虑服务宕机重启后的时钟回拨问题，这个问题可以通过在启动时进行最大ID校验时间戳进行解决。</p>
<h1 id="四、百度UIDGenerator"><a href="#四、百度UIDGenerator" class="headerlink" title="四、百度UIDGenerator"></a>四、百度UIDGenerator</h1><h2 id="4-1-百度UIDGenerator"><a href="#4-1-百度UIDGenerator" class="headerlink" title="4.1 百度UIDGenerator"></a><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">4.1 百度UIDGenerator</a></h2><p>UidGenerator是Java实现的, 基于Snowflake算法的唯一ID生成器。UidGenerator以组件形式工作在应用项目中, 支持自定义workerId位数和初始化策略, 从而适用于docker等虚拟化环境下实例自动重启、漂移等场景。</p>
<p>依赖于数据库（UidGenerator以组件形式工作，内置WorkerID分配器, 启动阶段通过DB进行分配; 如自定义实现, 则DB非必选依赖）</p>
<h2 id="4-2-DefaultUidGenerator"><a href="#4-2-DefaultUidGenerator" class="headerlink" title="4.2 DefaultUidGenerator"></a>4.2 DefaultUidGenerator</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;** Bits allocate *&#x2F;
 protected int timeBits &#x3D; 28;
 protected int workerBits &#x3D; 22;
 protected int seqBits &#x3D; 13;

 &#x2F;** Customer epoch, unit as second. For example 2016-05-20 (ms: 1463673600000)*&#x2F;
 protected String epochStr &#x3D; &quot;2016-05-20&quot;;
 protected long epochSeconds &#x3D; TimeUnit.MILLISECONDS.toSeconds(1463673600000L);

 &#x2F;** Stable fields after spring bean initializing *&#x2F;
 protected BitsAllocator bitsAllocator;
 protected long workerId;

 &#x2F;** Volatile fields caused by nextId() *&#x2F;
 protected long sequence &#x3D; 0L;
 protected long lastSecond &#x3D; -1L;

 &#x2F;** Spring property *&#x2F;
 protected WorkerIdAssigner workerIdAssigner;
 
 &#x2F;**
  * Get UID
  *
  * @return UID
  * @throws UidGenerateException in the case: Clock moved backwards; Exceeds the max timestamp
  *&#x2F;
 protected synchronized long nextId() &#123;
     long currentSecond &#x3D; getCurrentSecond();

     &#x2F;&#x2F; Clock moved backwards, refuse to generate uid
     if (currentSecond &lt; lastSecond) &#123;
         long refusedSeconds &#x3D; lastSecond - currentSecond;
         throw new UidGenerateException(&quot;Clock moved backwards. Refusing for %d seconds&quot;, refusedSeconds);
     &#125;

     &#x2F;&#x2F; At the same second, increase sequence
     if (currentSecond &#x3D;&#x3D; lastSecond) &#123;
         sequence &#x3D; (sequence + 1) &amp; bitsAllocator.getMaxSequence();
         &#x2F;&#x2F; Exceed the max sequence, we wait the next second to generate uid
         if (sequence &#x3D;&#x3D; 0) &#123;
             currentSecond &#x3D; getNextSecond(lastSecond);
         &#125;

     &#x2F;&#x2F; At the different second, sequence restart from zero
     &#125; else &#123;
         sequence &#x3D; 0L;
     &#125;

     lastSecond &#x3D; currentSecond;

     &#x2F;&#x2F; Allocate bits for UID
     return bitsAllocator.allocate(currentSecond - epochSeconds, workerId, sequence);
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>DefaultUidGenerator相对于原生的雪花算法做了一些调整，允许对各段占用长度进行自定义</p>
<ul>
<li>时间戳占用的位数减少了，默认占28位,起始时间默认为<code>2016-05-20 (ms: 1463673600000)</code>，时间戳到秒级别</li>
<li>机器占用的位数增大了，默认占22位，最多允许420万次的启停（内置实现为在启动时由数据库分配，默认分配策略为用后即弃）</li>
<li>序列位增加了一位，默认占13位，可支持每秒8192个并发。</li>
</ul>
<blockquote>
<p>对于时钟回拨问题，DefaultUidGenerator粗暴的直接抛出异常。</p>
</blockquote>
<h2 id="4-3-CachedUidGenerator"><a href="#4-3-CachedUidGenerator" class="headerlink" title="4.3 CachedUidGenerator"></a>4.3 CachedUidGenerator</h2><p>这种方案和上面默认的方案不同之处在于预先生成UID，将生成的UID缓存在一个环形数组之中，定义了两个指针（tail、cursor）去控制UID的消费位置及生成的最大的UID的位置，端获取客户端获取UID时没有加锁，而是使用了CAS机制，其中提过了两种机制触发UID的生成：</p>
<ul>
<li>阈值机制：获取UID时，如果剩余可获取的UID小于设定的阈值，则通过线程池提交一个任务生成UID缓存到环形数组之中</li>
<li>定时机制：通过定时任务定时生成UID缓存到环形数组之中</li>
</ul>
<p>RingBuffer环形数组，数组每个元素成为一个slot。RingBuffer容量，默认为Snowflake算法中sequence最大值，且为2^N（sequence最大值 &lt;&lt; 3, 即sequence最大值的3倍）。可通过boostPower配置进行扩容，以提高RingBuffer 读写吞吐量。</p>
<p>CachedUidGenerator采用了双RingBuffer，Uid-RingBuffer用于存储Uid、Flag-RingBuffer用于存储Uid状态(是否可填充、是否可消费)</p>
<p>由于数组元素在内存中是连续分配的，可最大程度利用CPU cache以提升性能。但同时会带来「伪共享」FalseSharing问题，为此在Tail、Cursor指针、Flag-RingBuffer中采用了CacheLine 补齐方式。</p>
<p>Tail指针、Cursor指针用于环形数组上读写slot：</p>
<ul>
<li><p>Tail指针<br>表示Producer生产的最大序号(此序号从0开始，持续递增)。Tail不能超过Cursor，即生产者不能覆盖未消费的slot。当Tail已赶上curosr，此时可通过rejectedPutBufferHandler指定PutRejectPolicy</p>
</li>
<li><p>Cursor指针<br>表示Consumer消费到的最小序号(序号序列与Producer序列相同)。Cursor不能超过Tail，即不能消费未生产的slot。当Cursor已赶上tail，此时可通过rejectedTakeBufferHandler指定TakeRejectPolicy</p>
</li>
</ul>
<p>RingBuffer填充时机</p>
<ul>
<li><p>初始化预填充<br>RingBuffer初始化时，预先填充满整个RingBuffer.</p>
</li>
<li><p>即时填充<br>Take消费时，即时检查剩余可用slot量(tail - cursor)，如小于设定阈值，则补全空闲slots。阈值可通过paddingFactor来进行配置</p>
</li>
<li><p>周期填充<br>通过Schedule线程，定时补全空闲slots。可通过scheduleInterval配置，以应用定时填充功能，并指定Schedule时间间隔</p>
</li>
</ul>
<blockquote>
<p>上述描述中存在一个「伪共享」FalseSharing问题，为此在Tail、Cursor指针、Flag-RingBuffer中采用了CacheLine 补齐方式。</p>
</blockquote>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><ul>
<li>较于原生的雪花算法减少了时间戳占用的长度，时间戳的长度调整到了22位，具体到秒级别，起始时间设置为了2016年。</li>
<li>增加了机器ID占用的长度，而且机器ID的分配使用了数据库自增的主键，允许单节点420万次的启动。</li>
<li>序列号的位数增大了1位，每秒最多可生成8192个UID。</li>
</ul>
<h3 id="DefaultUidGenerator方案："><a href="#DefaultUidGenerator方案：" class="headerlink" title="DefaultUidGenerator方案："></a>DefaultUidGenerator方案：</h3><ul>
<li>获取UID时要加锁（synchronized）</li>
<li>发生时钟回拨时，直接抛出异常。</li>
</ul>
<h3 id="CachedUidGenerator方案："><a href="#CachedUidGenerator方案：" class="headerlink" title="CachedUidGenerator方案："></a>CachedUidGenerator方案：</h3><ul>
<li>获取UID时不用加锁，使用了CAS</li>
<li>提前生成UID缓存到环形之中，通过阈值或定制机制预生成UID</li>
<li>生成UID时不依赖于时间戳，而是对<code>lastSecond</code>进行加一（这个值的初始值为系统启动时的时间戳）</li>
<li>获取的UID中的时间戳不准确</li>
</ul>
<blockquote>
<p>CachedUidGenerator方案没有依赖于时间戳，所以不会在运行时出现时钟回拨问题，而且对于同一秒内如果序列号增长到最大时，可以借用未来时间进行生成。</p>
</blockquote>
<h1 id="五、美团（Leaf）"><a href="#五、美团（Leaf）" class="headerlink" title="五、美团（Leaf）"></a>五、美团（Leaf）</h1><h2 id="5-1-Leaf：美团分布式ID生成服务开源"><a href="#5-1-Leaf：美团分布式ID生成服务开源" class="headerlink" title="5.1 Leaf：美团分布式ID生成服务开源"></a>5.1 <a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html">Leaf：美团分布式ID生成服务开源</a></h2><p>Leaf是美团基础研发平台推出的一个分布式ID生成服务，名字取自德国哲学家、数学家莱布尼茨的一句话：“There are no two identical leaves in the world.”Leaf具备高可靠、低延迟、全局唯一等特点。目前已经广泛应用于美团金融、美团外卖、美团酒旅等多个部门。具体的技术细节，可参考此前美团技术博客的一篇文章：《Leaf美团分布式ID生成服务》。近日，Leaf项目已经在Github上开源：<a href="https://github.com/Meituan-Dianping/Leaf">https://github.com/Meituan-Dianping/Leaf</a> ，希望能和更多的技术同行一起交流、共建。</p>
<h3 id="Leaf的特性"><a href="#Leaf的特性" class="headerlink" title="Leaf的特性"></a>Leaf的特性</h3><p>Leaf在设计之初就秉承着几点要求：</p>
<ul>
<li>全局唯一，绝对不会出现重复的ID，且ID整体趋势递增。</li>
<li>高可用，服务完全基于分布式架构，即使MySQL宕机，也能容忍一段时间的数据库不可用。</li>
<li>高并发低延时，在CentOS 4C8G的虚拟机上，远程调用QPS可达5W+，TP99在1ms内。</li>
<li>接入简单，直接通过公司RPC服务或者HTTP调用即可接入。</li>
</ul>
<h2 id="5-2-号段模式"><a href="#5-2-号段模式" class="headerlink" title="5.2 号段模式"></a>5.2 号段模式</h2><p>依赖于数据库，使用了预分发的方式生成ID，在DB上挂N个Server, 每个Server启动的时候都会去DB拿固定长度的ID List，然后再基于内存进行分发，数据库中记录了当前最大的ID。</p>
<ul>
<li>使用双Buffer，异步获取号段</li>
<li>MySQL采用半同步方式同步数据</li>
</ul>
<h2 id="5-3-Leaf-Snowflake模式"><a href="#5-3-Leaf-Snowflake模式" class="headerlink" title="5.3 Leaf Snowflake模式"></a>5.3 Leaf Snowflake模式</h2><p>Leaf Snowflake模式提供了Snowflake的Java版本实现，使用了Zookeeper身体工程机器号，获取后会在本机文件系统化缓存一个workID文件。</p>
<h2 id="5-4-Leaf-总结"><a href="#5-4-Leaf-总结" class="headerlink" title="5.4 Leaf 总结"></a>5.4 Leaf 总结</h2><ul>
<li>号段模式：依赖于数据库，低位趋势增长，较少的ID号段浪费，能够容忍MySQL的短时间不可用。</li>
<li>Snowflake模式：完全分布式，ID有语义（没有解决时钟回拨的问题）。</li>
</ul>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>目前来说，分布式ID生成方案总的来说可以分为3类：</p>
<ul>
<li>UUID这类依赖于硬件，生成无序的ID</li>
<li>依赖于数据库，可以实现单调递增和趋势递增</li>
<li>雪花算法类，依赖于时间戳，趋势递增，有时钟回拨问题</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>雪花算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty简介</title>
    <url>/2018/07/25/framework/shen-ru-xue-xi-netty-kuang-jia/</url>
    <content><![CDATA[<p><strong>官网简介：</strong><br>　　<code>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients.</code><br><strong>用一句话来概括：</strong><br>　　Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能协议服务器和客户端。  </p>
<hr>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p><strong>设计</strong>  </p>
<ul>
<li>适用于各种传输类型的统一API - 阻塞和非阻塞套接字</li>
<li>基于灵活且可扩展的事件模型，可以清晰地分离关注点</li>
<li>高度可定制的线程模型 - 单线程，一个或多个线程池，如SEDA</li>
<li>真正的无连接数据报套接字支持（自3.1起）  </li>
</ul>
<p><strong>易用</strong></p>
<ul>
<li>详细记录的Javadoc，用户指南和示例</li>
<li>没有其他依赖项，JDK 5（Netty 3.x）或6（Netty 4.x）就足够了</li>
</ul>
<p><strong>性能</strong></p>
<ul>
<li>吞吐量更高，延迟更低</li>
<li>减少资源消耗</li>
<li>最小化不必要的内存复制</li>
</ul>
<p><strong>安全</strong></p>
<ul>
<li>完整的SSL / TLS和StartTLS支持</li>
</ul>
<hr>
<h4 id="架构示意图"><a href="#架构示意图" class="headerlink" title="架构示意图"></a>架构示意图</h4><p><img src="/2018/07/25/framework/shen-ru-xue-xi-netty-kuang-jia/components.png" alt="Netty框架图"></p>
]]></content>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro简介及使用</title>
    <url>/2018/08/26/framework/shiro-jian-jie-ji-shi-yong/</url>
    <content><![CDATA[<p>　　<strong>Apache Shiro™</strong> is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.</p>
<p>　　Apache Shiro™是一个功能强大且易于使用的Java安全框架，可执行身份验证，授权，加密和会话管理。 借助Shiro易于理解的API，您可以快速轻松地保护任何应用程序 - 从最小的移动应用程序到最大的Web和企业应用程序。</p>
<p>#一、Apache Shiro简介</p>
<p>　　Apache Shiro的首要目标是易于使用和理解。安全有时可能非常复杂，甚至是痛苦的，但并非必须如此。框架应尽可能掩盖复杂性，并提供简洁直观的API，以简化开发人员确保其应用程序安全的工作。</p>
<p>##1、Apache Shiro可以做的一些事情：</p>
<ul>
<li>验证用户以验证其身份</li>
<li>为用户执行访问控制，例如：<ul>
<li>确定是否为用户分配了某个安全角色</li>
<li>确定是否允许用户执行某些操作</li>
</ul>
</li>
<li>在任何环境中使用Session API，即使没有Web容器或EJB容器也是如此。</li>
<li>在身份验证，访问控制或会话生命周期内对事件做出反应。</li>
<li>聚合用户安全数据的1个或多个数据源，并将其全部显示为单个复合用户“视图”。</li>
<li>启用单点登录（SSO）功能</li>
<li>无需登录即可为用户关联启用“记住我”服务</li>
</ul>
<p>　　Shiro尝试为所有应用程序环境实现这些功能 - 从最简单的命令行应用程序到最大的企业应用程序，而不会强制依赖其他第三方框架，容器或应用程序服务器。当然，该项目旨在尽可能地融入这些环境，但它可以在任何环境中开箱即用。</p>
<p>##2、Shiro的功能特性</p>
<p>Apache Shiro是一个具有许多功能的综合应用程序安全框架。下图显示了Shiro主要关注点：</p>
<p><img src="/2018/08/26/framework/shiro-jian-jie-ji-shi-yong/ShiroFeatures.png" alt="shiro功能"></p>
<p>Shiro针对应用程序安全的四大基础-Authentication, Authorization, Session Management, and Cryptography:</p>
<ul>
<li><strong>Authentication:</strong> 身份认证/登录，验证用户是不是拥有相应的身份；</li>
<li><strong>Authorization:</strong> 授权，即权限验证，验证某个已认证的用户是否拥有某个权限；</li>
<li><strong>Session Management:</strong> 会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；</li>
<li><strong>Cryptography:</strong> 加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
</ul>
<p>在不同的应用程序环境中还有其他功能可以支持和强化这些问题，尤其是：</p>
<ul>
<li>Web Support：Shiro的Web支持API可帮助轻松保护Web应用程序。</li>
<li>Caching：缓存，确保安全操作保持快速高效。</li>
<li>Concurrency：Apache Shiro支持具有并发功能的多线程应用程序。</li>
<li>Testing：存在测试支持以帮助您编写单元和集成测试，并确保您的代码按预期受到保护。</li>
<li>“Run As”：允许用户假定其他用户的身份（如果允许）的功能，有时在管理方案中很有用。</li>
<li>“Remember Me”：记住用户在会话中的身份，这样他们只需要在强制要求时登录。</li>
</ul>
<h2 id="3、Shiro架构"><a href="#3、Shiro架构" class="headerlink" title="3、Shiro架构"></a>3、Shiro架构</h2><p>Apache Shiro的设计目标是通过直观和易用来简化应用程序安全性。Shiro的核心设计模拟了大多数人对应用程序安全性的看法 - 在某人（或某事）与应用程序交互的环境中。 </p>
<p>shiro架构有三个主要概念：Subject，SecurityManager和Realms。下图是这些组建如何交互的高级概述、之后介绍每个概念：</p>
<p><img src="/2018/08/26/framework/shiro-jian-jie-ji-shi-yong/ShiroBasicArchitecture.png" alt="shiro架构"></p>
<ul>
<li><p><strong>Subject:</strong>  主体，<code>Subject</code>代表了与当前应用程序进行安全交互的“用户”。虽然“用户”这个词通常意味着一个具体的人，但是它可以是一个人，但它也可以代表第三方服务，守护进程帐户，cron作业或任何类似的东西 - 基本上任何与软件交互的东西。</p>
<p><code>Subject</code>实例都绑定到<code>SecurityManager</code>，当您与<code>Subject</code>‘进行交互时，这些交互会委托给<code>Subject</code>绑定的<code>SecurityManager</code>。</p>
</li>
<li><p><strong>SecurityManager:</strong> 安全管理器，<code>SecurityManager</code>是shiro架构的核心，<code>SecurityManager</code>管理着所有的<code>Subject</code>,所有与安全有关的操作都会与<code>SecurityManager</code>交互.</p>
</li>
<li><p><strong>Realm:</strong> 域，充当Shiro与应用程序安全数据之间的“桥梁”或“连接器”。当实际与安全相关的数据（如用户帐户）进行交互以执行身份验证（登录）和授权（访问控制）时，Shiro会从为应用程序配置的一个或多个领域中查找许多这些内容。</p>
<p>从这个意义上讲，Realm本质上是一个特殊的安全性的<a href="https://en.wikipedia.org/wiki/Data_access_object">DAO</a>：它封装了数据源的连接细节，并根据需要使相关数据可用于Shiro。配置Shiro时，必须至少指定一个Realm用于身份验证和/或授权。</p>
<p>Shiro提供了开箱即用的领域，可以连接到许多安全数据源（也称为目录），如LDAP，关系数据库（JDBC），文本配置源（如INI和属性文件等）。如果默认域不符合您的需要，您可以插入自己的Realm实现来表示自定义数据源</p>
</li>
</ul>
<p><strong>注意：</strong> 从上述可以看出，shiro不提供维护用户和权限的功能，而是通过realm让用户自己来实现。</p>
<h3 id="shiro详细架构"><a href="#shiro详细架构" class="headerlink" title="shiro详细架构"></a>shiro详细架构</h3><p>下图显示了Shiro的核心架构概念，后面是每个概述的简短摘要：</p>
<p><img src="/2018/08/26/framework/shiro-jian-jie-ji-shi-yong/ShiroArchitecture.png" alt="shiro详细架构"></p>
<ul>
<li><strong>Subject</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html"><code>org.apache.shiro.subject.Subject</code></a>）<br>当前与软件交互的实体（用户，第三方服务等）的“用户”。</li>
<li><strong>SecurityManager</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/mgt/SecurityManager.html">org.apache.shiro.mgt.SecurityManager</a>）<br>如上所述，这<code>SecurityManager</code>是Shiro架构的核心，协调各组件稳定运行，所有的安全相关的操作都是通过<code>SecurityManager</code>进行控制。</li>
<li><strong>Authenticator</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html">org.apache.shiro.authc.Authenticator</a>）<br>认证器，负责执行验证用户认证的组件。当用户尝试登录时，由<code>Authenticator</code>执行用户认证的逻辑。该<code>Authenticator</code>知道如何与一个或多个存储用户/帐户信息的<code>Realms</code>协调工作。从这些<code>Realms</code>获取的数据用于验证用户的身份，以保证用户确实是他们所说的人。<ul>
<li><strong>Authentication Strategy</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AuthenticationStrategy.html">org.apache.shiro.authc.pam.AuthenticationStrategy</a>）<br>认证策略，如果多于一个<code>Realm</code>被配置时，<code>AuthenticationStrategy</code>将与<code>realm</code>协调，以确定在其下的认证尝试成功或失败（例如，如果一个<code>realm</code>认证成功但是其他认证失败，那么这次认证是成功的吗？必须所有<code>realm</code>都要认证成功？还是只需要第一个？）。</li>
</ul>
</li>
<li><strong>Authorizer</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/Authorizer.html">org.apache.shiro.authz.Authorizer</a>）<br>访问控制器，<code>Authorizer</code>确定“用户”在该应用程序的访问控制权限。决定用户是否有权限进行某项操作，控制用户能访问应用程序的哪些功能。</li>
<li><strong>SessionManager</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/mgt/SessionManager.html">org.apache.shiro.session.mgt.SessionManager</a>）<br><code>SessionManager</code>知道如何创建和管理用户<code>Session</code>生命周期，提供在所有环境中的用户强大的会话体验。这是安全框架领域的一项独特功能 - 即使没有可用的Web / Servlet或EJB容器，Shiro也能够在任何环境中本地管理用户会话。默认情况下，Shiro将使用现有的会话机制（例如Servlet Container），但如果没有，例如在独立应用程序或非Web环境中，它将使用其内置的企业会话管理提供相同的编程经验。的<code>SessionDAO</code>存在允许任何数据源被用来坚持的会议。<ul>
<li><strong>SessionDAO</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/mgt/eis/SessionDAO.html">org.apache.shiro.session.mgt.eis.SessionDAO</a>）<br><code>SessionDAO</code>执行<code>Session</code>代表的持久性（CRUD）操作<code>SessionManager</code>。这允许将任何数据存储插入会话管理基础结构。</li>
</ul>
</li>
<li><strong>CacheManager</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/cache/CacheManager.html">org.apache.shiro.cache.CacheManager</a>）<br><code>CacheManager</code>创建和管理<code>Cache</code>其他四郎组件使用实例的生命周期。由于Shiro可以访问许多后端数据源以进行身份验证，授权和会话管理，因此缓存一直是框架中的一流架构功能，可在使用这些数据源时提高性能。任何现代开源和/或企业缓存产品都可以插入Shiro，以提供快速有效的用户体验。</li>
<li><strong>Cryptography</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/crypto/package-summary.html">org.apache.shiro.crypto</a>）<br>密码模块，Shiro提供了一些常见的加密组件用于如密码加密/解密的。该软件包中的所有类都经过精心设计，易于使用且易于理解。</li>
<li><strong>Realms</strong>（<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html">org.apache.shiro.realm.Realm</a>）<br>如上所述，Realms充当Shiro和应用程序安全数据之间的“桥接”或“连接器”。当实际与安全相关的数据（如用户帐户）进行交互以执行身份验证（登录）和授权（访问控制）时，Shiro会从为应用程序配置的一个或多个领域中查找许多这些内容。您可以根据<code>Realms</code>需要配置任意数量（通常每个数据源一个），Shiro将根据需要进行身份验证和授权协调。</li>
</ul>
<h1 id="二、Shiro核心功能"><a href="#二、Shiro核心功能" class="headerlink" title="二、Shiro核心功能"></a>二、Shiro核心功能</h1><p>上面主要介绍了shiro的功能特性及架构，下面介绍shiro的核心功能的使用。</p>
<h2 id="1、Shiro身份验证"><a href="#1、Shiro身份验证" class="headerlink" title="1、Shiro身份验证"></a>1、Shiro身份验证</h2><p><strong>身份验证</strong>过程就是证明用户实际上是他们所说的人，为了让用户证明自己的身份，他们需要提供一些能够让系统识别和信任的身份证明。</p>
<p>在shiro中，用户需要提供principals （身份）和credentials（证明）给shiro，从而应用能验证用户身份：</p>
<p><strong>principals</strong>：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/密码/手机号。</p>
<p><strong>credentials</strong>：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。</p>
<p>最常见的principals和credentials组合就是用户名/密码了。接下来先进行一个基本的身份认证。</p>
<h2 id="2、身份验证步骤"><a href="#2、身份验证步骤" class="headerlink" title="2、身份验证步骤"></a>2、身份验证步骤</h2><p>Subject身份验证的过程主要分为以下三个步骤：</p>
<ul>
<li>1、收集用户身份/凭证，即如用户名/密码。</li>
<li>2、提交用户身份/凭证进行身份验证。</li>
<li>3、如果提交成功，则允许访问，否则重试身份验证或阻止访问。</li>
</ul>
<p>接一下来结合代码对上述的三个步骤进行说明。</p>
<p><strong>步骤一：收集用户身份/凭证，即如用户名/密码</strong></p>
<pre class="line-numbers language-//Example" data-language="//Example"><div class="caption"><span>using most common scenario of username/password pair:</span></div><code class="language-//Example">&#x2F;&#x2F;Example using most common scenario of username&#x2F;password pair:
UsernamePasswordToken token &#x3D; new UsernamePasswordToken(username, password);

&#x2F;&#x2F;&quot;Remember Me&quot; built-in: 
token.setRememberMe(true);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在当前的例子中，我们使用了UsernamePasswordToken，支持最常见的用户名/密码身份验证方法。这是Shiro的org.apache.shiro.authc.AuthenticationToken接口的实现，该接口是Shiro的身份验证系统用来表示提交的身份信息和凭据的基本接口。</p>
<p>这里需要注意的是，Shiro不关心如何获取这些信息，你可以从http表单中获取，也可以从http请求头中获取，或者通过命令行参数获取。应用程序获取用户身份信息和凭证的过程与与Shiro的AuthenticationToken概念完全分离。</p>
<p>这个例子还表明我们已经表示希望Shiro为身份验证尝试执行“记住我”服务。这可确保Shiro在以后返回应用程序时记住用户身份。</p>
<p><strong>步骤二：提交用户身份和凭证</strong></p>
<p>在收集了用户身份和凭据并将其表示为AuthenticationToken实例后，我们需要将token提交给Shiro以执行实际的身份验证尝试：</p>
<pre class="line-numbers language-Subject" data-language="Subject"><div class="caption"><span>currentUser </span></div><code class="language-Subject">Subject currentUser &#x3D; SecurityUtils.getSubject();
currentUser.login(token);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>获取当前正在执行的Subject后，我们进行一次登录调用，传入我们之前创建的AuthenticationToken实例。</p>
<p><strong>步骤三：处理验证结果（成功或失败）</strong></p>
<p>如果登录方法正常地返回，此次验证完成，用户已经过身份验证。 应用程序线程可以继续不间断，所有对SecurityUtils.getSubject（）的进一步调用将返回经过身份验证的Subject实例以及对subject的任何调用。 <code>isAuthenticated()</code>将返回true。</p>
<p>但是如果登录尝试失败会发生什么？ 例如，如果最终用户提供了错误的密码，或者访问了系统太多次并且他们的帐户被锁定了怎么办？</p>
<p>Shiro具有丰富的运行时AuthenticationException层次结构，可以准确指示尝试失败的原因。 您可以在try / catch块中包装登录并捕获您希望的任何异常并相应地对它们做出反应。 例如：</p>
<pre class="line-numbers language-none"><code class="language-none">try &#123;
    currentUser.login(token);
&#125; catch ( UnknownAccountException uae ) &#123; ...&#x2F;&#x2F;用户名错误
&#125; catch ( IncorrectCredentialsException ice ) &#123; ...&#x2F;&#x2F;密码错误
&#125; catch ( LockedAccountException lae ) &#123; ...&#x2F;&#x2F;账号锁定
&#125; catch ( ExcessiveAttemptsException eae ) &#123; ...&#x2F;&#x2F;超过最大登录失败尝试次数
&#125; ... catch your own ...
&#125; catch ( AuthenticationException ae ) &#123;
    &#x2F;&#x2F;unexpected error?
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果其中一个现有异常类不满足您的需求，则可以创建自定义AuthenticationExceptions以表示特定的异常。</p>
<p><strong>Remembered vs. Authenticated</strong></p>
<p>如上例所示，除了正常的登录过程外，Shiro还支持“记住我”的概念。 值得指出的是，Shiro在<em>remembered</em> Subject和实际<em>authenticated</em> Subject之间做了非常精确的区分：</p>
<ul>
<li><p><strong>Remembered</strong>：<em>remembered</em> Subject不是匿名的并且具有已知的身份（即subject.getPrincipals（）非空）。 但是，在先前的会话期间，先前的身份验证会记住此身份。 如果subject.isRemembered（）返回true，则认为subject被记住。</p>
</li>
<li><p><strong>Authenticated</strong>：<em>authenticated</em> Subject是在subject的当前会话期间已成功通过身份验证的主题（即，在不抛出异常的情况下调用登录方法）。 如果subject.isAuthenticated（）返回true，则认为subject已经过身份验证。</p>
</li>
</ul>
<h2 id="三、身份验证流程"><a href="#三、身份验证流程" class="headerlink" title="三、身份验证流程"></a>三、身份验证流程</h2><p>到目前为止，我们只研究了如何从应用程序代码中验证subject。 现在我们将介绍在发生身份验证时Shiro内部发生的事情。</p>
<p>我们从架构章节中获取了我们之前的架构图，并且只保留了与身份验证相关的组件。 每个数字代表身份验证尝试期间的一个步骤：</p>
<p><img src="/2018/08/26/framework/shiro-jian-jie-ji-shi-yong/ShiroAuthenticationSequence.png" alt="身份验证流程"></p>
<ul>
<li><p><strong>步骤1</strong>：应用程序代码调用Subject.login方法，传入构造的AuthenticationToken实例，表示最终用户的身份和凭证。</p>
</li>
<li><p><strong>步骤2</strong>：Subject实例，通常是DelegatingSubject（或子类），通过调用securityManager.login（token）委托应用程序的SecurityManager，其中实际的身份验证工作开始。</p>
</li>
<li><p><strong>步骤3</strong>：SecurityManager接收tokent，并通过调用authenticator.authenticate（token）简单地委托给其内部Authenticatorinstance。一般是ModularRealmAuthenticator实例，它支持在身份验证期间协调一个或多个Realm实例。 ModularRealmAuthenticator实质上为Apache Shiro提供了PAM风格的范例（其中每个realm都是PAM术语中的“模块”）。</p>
</li>
<li><p><strong>步骤4</strong>：如果为应用程序配置了多个Realm，则ModularRealmAuthenticator实例将使用其配置的AuthenticationStrategy启动多Realm身份验证尝试。在调用Realms进行身份验证之前，期间和之后，将调用AuthenticationStrategy以允许它对每个Realm的结果做出反应。我们很快就会介绍AuthenticationStrategies。</p>
<ul>
<li><strong>注意</strong>：如果只配置了一个Realm，则直接调用它 ，在单Realm应用程序中不需要AuthenticationStrategy。</li>
</ul>
</li>
<li><p><strong>步骤5</strong>：查询每个配置的Realm以查看它是否支持提交的AuthenticationToken。 如果是这样，将使用提交的token调用支持的Realm的getAuthenticationInfo方法。 getAuthenticationInfo方法有效地表示该特定Realm的单个身份验证尝试。 我们将很快介绍Realm身份验证行为。</p>
</li>
</ul>
<p><strong><a href="http://shiro.apache.org/authentication.html#authenticator">Authenticator</a></strong></p>
<p>如上所述，Shiro SecurityManager默认使用ModularRealmAuthenticator实例。 ModularRealmAuthenticator同时支持具有单个Realm的应用程序以及具有多个Realm的应用程序。</p>
<p>在单领域应用程序中，ModularRealmAuthenticator将直接调用单个领域。如果配置了两个或更多领域，它将使用AuthenticationStrategy实例来协调尝试的发生方式。我们将在下面介绍AuthenticationStrategies。</p>
<p>ModularRealmAuthenticator能适合大多数应用场景，如果你希望使用自定义Authenticator，可以将自定义的Authenticator配置到SecurityManager。</p>
<p><strong><a href="http://shiro.apache.org/authentication.html#authenticationstrategy">AuthenticationStrategy</a>：认证策略</strong></p>
<p>当为应用程序配置两个或多个领域时，ModularRealmAuthenticator依赖于内部AuthenticationStrategy组件来确定身份验证尝试成功或失败的条件。</p>
<p>例如，如果只有一个Realm成功验证了AuthenticationToken，但其他所有验证失败，那么验证尝试是否成功？或者所有领域是否必须成功验证才能被认为是成功的整体尝试？或者，如果领域成功验证，是否有必要进一步咨询其他领域？ AuthenticationStrategy根据应用程序的需要做出适当的决策。</p>
<p>AuthenticationStrategy是一个无状态组件，在身份验证尝试期间会被查询4次（这4次交互所需的任何必要状态将作为方法参数提供）：</p>
<ul>
<li>1、在调用任何Realm之前</li>
<li>2、在调用单个Realm的getAuthenticationInfo方法之前</li>
<li>3、在调用单个Realm的getAuthenticationInfo方法之后立即执行</li>
<li>4、在所有Realm被调用之后</li>
</ul>
<p>AuthenticationStrategy还负责聚合每个成功Realm的结果，并将它们“绑定”到一个AuthenticationInfo表示中。最终聚合AuthenticationInfo实例是Authenticator实例返回的实例，也是Shiro用来表示Subject的最终身份（又名Principals）的实例。</p>
<p>Shiro有3个具体的AuthenticationStrategy实现：</p>
<table>
<thead>
<tr>
<th><code>AuthenticationStrategy</code> class</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AtLeastOneSuccessfulStrategy.html"><code>AtLeastOneSuccessfulStrategy</code></a></td>
<td>如果一个（或多个）领域成功进行身份验证，则认为整体尝试成功。 如果没有成功进行身份验证，则尝试失败。</td>
</tr>
<tr>
<td><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.html"><code>FirstSuccessfulStrategy</code></a></td>
<td>仅使用从第一个成功通过身份验证的Realm返回的信息。 所有进一步的领域都将被忽略。 如果没有成功验证，则尝试失败。</td>
</tr>
<tr>
<td><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AllSuccessfulStrategy.html"><code>AllSuccessfulStrategy</code></a></td>
<td>所有已配置的域必须成功进行身份验证才能将整体尝试视为成功。 如果任何人未成功验证，则尝试失败。</td>
</tr>
</tbody></table>
<p>ModularRealmAuthenticator默认为AtLeastOneSuccessfulStrategy实现，因为这是最常用的策略。</p>
<pre class="line-numbers language-none"><code class="language-none">*注：如果您想自己创建自己的AuthenticationStrategy实现，可以使用org.apache.shiro.authc.pam.AbstractAuthenticationStrategy作为起点。 AbstractAuthenticationStrategy类自动实现将每个Realm的结果合并到单个AuthenticationInfo实例中的“捆绑”&#x2F;聚合行为。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><a href="http://shiro.apache.org/authentication.html#realm-authentication-order">Realm Authentication Order</a>：认证顺序</strong></p>
<p>ModularRealmAuthenticator以迭代顺序与Realm实例交互。ModularRealmAuthenticator可以访问SecurityManager上配置的Realm实例。 执行身份验证尝试时，它将遍历该集合，并且对于支持提交的AuthenticationToken的每个Realm，调用Realm的getAuthenticationInfo方法。</p>
<p>ModularRealmAuthenticator根据SecurityManager中Realm配置按序调用的。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>shiro</tag>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache SkyWalking简介及使用</title>
    <url>/2020/05/20/framework/apache-skywalking-jian-jie-ji-shi-yong/</url>
    <content><![CDATA[<h1 id="一、什么是SkyWalking"><a href="#一、什么是SkyWalking" class="headerlink" title="一、什么是SkyWalking"></a>一、什么是SkyWalking</h1><p>分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。<br>SkyWalking 是观察性分析平台和应用性能管理系统。</p>
<p>提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案.<br>支持Java, .Net Core, PHP, NodeJS, Golang, LUA语言探针<br>支持Envoy + Istio构建的Service Mesh<br><img src="/2020/05/20/framework/apache-skywalking-jian-jie-ji-shi-yong/frame.jpeg"><br>更多内容参考<a href="https://skywalking.apache.org/zh/">SkyWalking官网</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SkyWalking</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码解析</title>
    <url>/2019/07/06/java/concurrenthashmap-yuan-ma-jie-xi/</url>
    <content><![CDATA[<blockquote>
<p><strong>面试常见问题</strong></p>
<p>ConcurrentHashMap实现原理</p>
<p>ConcurrentHashMap如何保证线程安全</p>
</blockquote>
<blockquote>
<p><em><strong>本文基于JDK1.8</strong></em></p>
</blockquote>
<h2 id="一、构造方法和基本属性"><a href="#一、构造方法和基本属性" class="headerlink" title="一、构造方法和基本属性"></a>一、构造方法和基本属性</h2><p>JDK8中ConcurrentHashMap参考了JDK8 HashMap的实现，构造方法和基本属性与HashMap大致相同，可参考<a href="http://blog.mpoom.cn/2019/07/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">HashMap源码解</a>,以下主要列举不同的地方。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Encodings for Node hash fields. See above for explanation.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MOVED     <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// hash for forwarding nodes</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEBIN   <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// hash for roots of trees</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RESERVED  <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// hash for transient reservations</span>
<span class="token comment">// Hash节点正常可用位</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HASH_BITS <span class="token operator">=</span> <span class="token number">0x7fffffff</span><span class="token punctuation">;</span> <span class="token comment">// usable bits of normal node hash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="二、主要方法解析"><a href="#二、主要方法解析" class="headerlink" title="二、主要方法解析"></a>二、主要方法解析</h2><h3 id="2-1-spread-int-h"><a href="#2-1-spread-int-h" class="headerlink" title="2.1  spread(int h)"></a>2.1  spread(int h)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 这里的spread方法作用与HashMap中的hash方法相同，//先对低16位进行扰动处理，然后屏蔽符号位，结果为32      * 位int型非负数
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> HASH_BITS<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-2-tabAt-Node-lt-K-V-gt-tab-int-i"><a href="#2-2-tabAt-Node-lt-K-V-gt-tab-int-i" class="headerlink" title="2.2 tabAt(Node&lt;K,V&gt;[] tab, int i)"></a>2.2 tabAt(Node&lt;K,V&gt;[] tab, int i)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 该方法通过Unsafe类直接进行内存寻址定位,用来返回节点数组的指定位置的节点的原子操作
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">tabAt</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> ASHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> ABASE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-3-casTabAt-Node-lt-K-V-gt-tab-int-i-Node-lt-K-V-gt-c-Node-lt-K-V-gt-v"><a href="#2-3-casTabAt-Node-lt-K-V-gt-tab-int-i-Node-lt-K-V-gt-c-Node-lt-K-V-gt-v" class="headerlink" title="2.3  casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)"></a>2.3  casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 比较交换（CAS）
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">boolean</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> c<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> ASHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> ABASE<span class="token punctuation">,</span> c<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-4-setTabAt-Node-lt-K-V-gt-tab-int-i-Node-lt-K-V-gt-v"><a href="#2-4-setTabAt-Node-lt-K-V-gt-tab-int-i-Node-lt-K-V-gt-v" class="headerlink" title="2.4  setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v)"></a>2.4  setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 
 */</span>   
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">void</span> <span class="token function">setTabAt</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">putObjectVolatile</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> ASHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> ABASE<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-5-put-K-key-V-value"><a href="#2-5-put-K-key-V-value" class="headerlink" title="2.5  put(K key, V value)"></a>2.5  put(K key, V value)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Maps the specified key to the specified value in this table.
 * Neither the key nor the value can be null.(键值都不能为空)
 *
 * &lt;p>The value can be retrieved by calling the &#123;@code get&#125; method
 * with a key that is equal to the original key.
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return the previous value associated with &#123;@code key&#125;, or
 *         &#123;@code null&#125; if there was no mapping for &#123;@code key&#125;
 * @throws NullPointerException if the specified key or value is null
 */</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/** Implementation for put and putIfAbsent */</span>
<span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 键值都不能为null,否则抛出NPE异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">;</span> 
        <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 如果i位置没有数据，则比较并交换</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// no lock when adding to empty bin</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">/*
         * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，
         * 则当前线程也会参与去复制，通过允许多线程复制的功能，以此来减少数组的复制所带来的性能损失
         */</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果在这个位置有元素的话，就采用synchronized的方式加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 标识该节点为列表节点</span>
                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
                            <span class="token comment">// 如果key相同，则覆盖旧value值</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
                                 <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                            <span class="token comment">// 插入列表尾部</span>
                            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span>
                        binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                        <span class="token comment">// 红黑树结构旋转插入</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 如果列表长度大于等于8则转换为红黑树</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>
                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 统计size，并检测是否需要扩容</span>
    <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-6-initTable"><a href="#2-6-initTable" class="headerlink" title="2.6  initTable()"></a>2.6  initTable()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Initializes table, using the size recorded in sizeCtl.
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> 
    <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
    <span class="token comment">// 如果table为null则进行初始化</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//sizeCtl&lt;0表示其他线程已经在初始化了或者扩容了，挂起当前线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>
        <span class="token comment">//CAS操作SIZECTL为-1，表示初始化状态</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>
                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
                    <span class="token comment">// 初始化后，sizeCtl长度为数组长度的3/4</span>
                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> tab<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-7-treeifyBin-Node-lt-K-V-gt-tab-int-index"><a href="#2-7-treeifyBin-Node-lt-K-V-gt-tab-int-index" class="headerlink" title="2.7 treeifyBin(Node&lt;K,V&gt;[] tab, int index)"></a>2.7 treeifyBin(Node&lt;K,V&gt;[] tab, int index)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Replaces all linked nodes in bin at given index unless table is
 * too small, in which case resizes instead.
 * 当数组长度小于64的时候，扩张数组长度一倍，否则的话把链表转为树
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> b<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>
            <span class="token comment">// 数组长度小于64，则扩容1倍</span>
            <span class="token function">tryPresize</span><span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>hash <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//使用synchronized同步器，将该节点出的链表转为红黑树</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> b<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token comment">// 将列表节点转换为红黑树节点</span>
                        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                            hd <span class="token operator">=</span> p<span class="token punctuation">;</span>
                        <span class="token keyword">else</span>
                            tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                        tl <span class="token operator">=</span> p<span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-8-tryPresize-int-size"><a href="#2-8-tryPresize-int-size" class="headerlink" title="2.8 tryPresize(int size)"></a>2.8 tryPresize(int size)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Tries to presize table to accommodate the given number of elements.
 *
 * @param size number of elements (doesn't need to be perfectly accurate)
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">tryPresize</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果指定容量大小大于等于最大容量的一半，则设置为最大容量，否则扩大为size的两倍</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> <span class="token punctuation">(</span>MAXIMUM_CAPACITY <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span>
        <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>
        <span class="token comment">// 如果还未初始化，则进行初始化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> c<span class="token punctuation">;</span>
            <span class="token comment">// 初始化tab的时候，把sizeCtl设为-1</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> tab<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        table <span class="token operator">=</span> nt<span class="token punctuation">;</span>
                        sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
                    sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
         <span class="token comment">/*
         * 一直扩容到的c小于等于sizeCtl或者数组长度大于最大长度的时候，则退出
         * 所以在一次扩容之后，不是原来长度的两倍，而是2的n次方倍
         */</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;=</span> sc <span class="token operator">||</span> n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> table<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>
                    sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>
                    transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment">/*
                 * transfer的线程数加一,该线程将进行transfer的帮忙
                 * 在transfer的时候，sc表示在transfer工作的线程数
                 */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">/*
             * 没有在初始化或扩容，则开始扩容
             */</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span><span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-9-transfer-Node-lt-K-V-gt-tab-Node-lt-K-V-gt-nextTab"><a href="#2-9-transfer-Node-lt-K-V-gt-tab-Node-lt-K-V-gt-nextTab" class="headerlink" title="2.9 transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)"></a>2.9 transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Moves and/or copies the nodes in each bin to new table. See
 * above for explanation.
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span>
        stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span> <span class="token comment">// subdivide range</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// initiating</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// try to cope with OOME</span>
            sizeCtl <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
        transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// to ensure sweep before committing nextTab</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>
                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span>compareAndSwapInt
                     <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> TRANSFERINDEX<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>
                      nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span>
                                   nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>
                i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                nextTable <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
                sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// recheck before commit</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// already processed</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>
                                lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                            hn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                            hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                            ln <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> <span class="token class-name">K</span> pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> <span class="token class-name">V</span> pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                                ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>f<span class="token punctuation">;</span>
                        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> lo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hi <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">int</span> h <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
                            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span>
                                <span class="token punctuation">(</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                    lo <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                loTail <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                <span class="token operator">++</span>lc<span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                    hi <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                hiTail <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                <span class="token operator">++</span>hc<span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                        <span class="token punctuation">&#125;</span>
                        ln <span class="token operator">=</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span>
                            <span class="token punctuation">(</span>hc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>
                        hn <span class="token operator">=</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span>
                            <span class="token punctuation">(</span>lc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>在ConcurrentHashMap中，同步处理主要是通过Synchronized和unsafe两种方式来完成的。</p>
<ul>
<li><p>在取得sizeCtl、某个位置的Node的时候，使用的都是unsafe的方法，来达到并发安全的目的</p>
</li>
<li><p>当需要在某个位置设置节点的时候，则会通过Synchronized的同步机制来锁定该位置的节点。</p>
</li>
<li><p>在数组扩容的时候，则通过处理的步长和fwd节点来达到并发安全的目的，通过设置hash值为MOVED</p>
</li>
<li><p>当把某个位置的节点复制到扩张后的table的时候，也通过Synchronized的同步机制来保证现程安全</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码解析</title>
    <url>/2019/07/06/java/hashmap-yuan-ma-jie-xi/</url>
    <content><![CDATA[<blockquote>
<p><strong>面试常见问题</strong></p>
<p>1、你看过那些源码吗？<br>2、那你能讲讲HashMap的实现原理吗？<br>3、HashMap什么时候会进行rehash？<br>4、HashMap什么时候会进行扩容？<br>5、那HashMap的初始容量设置成多少比较合适呢？<br>6、结合源码说说HashMap在高并发场景中为什么会出现死循环？<br>7、JDK1.8中对HashMap做了哪些性能优化？<br>8、HashMap和HashTable有何不同？<br>9、HashMap 和 ConcurrentHashMap 的区别？<br>10、ConcurrentHashMap和LinkedHashMap有什么区别？<br>11、为什么ConcurrentHashMap中的链表转红黑树的阀值是8？<br>12、什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？<br>13、还看过其他的源码吗？Spring的源码有了解吗？<br>14、SpringBoot的源码呢？知道starter是怎么实现的吗？</p>
</blockquote>
<h2 id="一、构造方法"><a href="#一、构造方法" class="headerlink" title="一、构造方法"></a>一、构造方法</h2><h3 id="1-1无参构造方法"><a href="#1-1无参构造方法" class="headerlink" title="1.1无参构造方法"></a>1.1无参构造方法</h3><blockquote>
<p>默认初始化容量16，加载因子0.75</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Constructs an empty &lt;tt>HashMap&lt;/tt> with the default initial capacity
 * (16) and the default load factor (0.75).
 */</span>
<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment">// all other fields defaulted</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-2-指定初始容量initialCapacity，默认加载因子0-75"><a href="#1-2-指定初始容量initialCapacity，默认加载因子0-75" class="headerlink" title="1.2  指定初始容量initialCapacity，默认加载因子0.75"></a>1.2  指定初始容量initialCapacity，默认加载因子0.75</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Constructs an empty &lt;tt>HashMap&lt;/tt> with the specified initial
 * capacity and the default load factor (0.75).
 *
 * @param  initialCapacity the initial capacity.
 * @throws IllegalArgumentException if the initial capacity is negative.
 */</span>
<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-3-指定初始容量initialCapaticy和加载因子loadFactor"><a href="#1-3-指定初始容量initialCapaticy和加载因子loadFactor" class="headerlink" title="1.3 指定初始容量initialCapaticy和加载因子loadFactor"></a>1.3 指定初始容量initialCapaticy和加载因子loadFactor</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Constructs an empty &lt;tt>HashMap&lt;/tt> with the specified initial
 * capacity and load factor.
 *
 * @param  initialCapacity the initial capacity
 * @param  loadFactor      the load factor
 * @throws IllegalArgumentException if the initial capacity is negative
 *         or the load factor is nonpositive
 */</span>
<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>
                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>
        initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>
                                           loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>
    <span class="token comment">// 阈值初始化为初始容量最小2的倍数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>HashMap初始容量为指定容量的最小2的倍数。该方法将初始容量的二进制最高位右移再与原值进行或运算，将低位全部转换为1，最后加1，由此得到初始化容量的最小的2的倍数</strong></p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Returns a power of two size for the given target capacity.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-4-用其他Map初始化"><a href="#1-4-用其他Map初始化" class="headerlink" title="1.4 用其他Map初始化"></a>1.4 用其他Map初始化</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Constructs a new &lt;tt>HashMap&lt;/tt> with the same mappings as the
 * specified &lt;tt>Map&lt;/tt>.  The &lt;tt>HashMap&lt;/tt> is created with
 * default load factor (0.75) and an initial capacity sufficient to
 * hold the mappings in the specified &lt;tt>Map&lt;/tt>.
 *
 * @param   m the map whose mappings are to be placed in this map
 * @throws  NullPointerException if the specified map is null
 */</span>
<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>
    <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="二、属性解析"><a href="#二、属性解析" class="headerlink" title="二、属性解析"></a>二、属性解析</h2><h3 id="2-1-基本属性"><a href="#2-1-基本属性" class="headerlink" title="2.1  基本属性"></a>2.1  基本属性</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 默认初始化容量，必须是2的倍数，初始默认为16
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// aka 16</span>

<span class="token comment">/**
 * 最大容量，小于2的30次方
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 默认加载因子0.75
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 列表转红黑树的阈值，列表大于等于8时将转为红黑树
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 红黑树转列表的阈值
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 列表转红黑树的最小容量，如果一个槽中的数据太多，HashMap应考虑扩容，该值用来解决扩容与列表转树的冲突
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 在首次使用时初始化，根据需要扩容，大小始终为2的倍数
 */</span>
<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

<span class="token comment">/**
 * Holds cached entrySet(). Note that AbstractMap fields are used
 * for keySet() and values().
 */</span>
<span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entrySet<span class="token punctuation">;</span>

<span class="token comment">/**
 * HashMap中键值对的数量
 */</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

<span class="token comment">/**
 * HashMap结构修改次数
 */</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>

<span class="token comment">/**
 * 下次扩容时table的大小
 * @serial
 */</span>
<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

<span class="token comment">/**
 * hash table 加载因子
 * @serial
 */</span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-2-内部类Node-lt-K-V-gt"><a href="#2-2-内部类Node-lt-K-V-gt" class="headerlink" title="2.2  内部类Node&lt;K,V&gt;"></a>2.2  内部类Node&lt;K,V&gt;</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 基础hash节点，包含一个hash值，一个key-value键值对，和下个节点
 */</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token class-name">V</span> value<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>

    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>
        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-3-内部类TreeNode-lt-K-V-gt"><a href="#2-3-内部类TreeNode-lt-K-V-gt" class="headerlink" title="2.3  内部类TreeNode&lt;K,V&gt;"></a>2.3  内部类TreeNode&lt;K,V&gt;</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 红黑树节点，包含父节点、左节点、右节点、前置节点以及节点颜色
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> parent<span class="token punctuation">;</span>  <span class="token comment">// red-black tree links</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> left<span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> right<span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> prev<span class="token punctuation">;</span>    <span class="token comment">// needed to unlink next upon deletion</span>
    <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> val<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * Returns root of tree containing this node.
     */</span>
    <span class="token keyword">final</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> r<span class="token punctuation">;</span>
            r <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="三、主要方法解析"><a href="#三、主要方法解析" class="headerlink" title="三、主要方法解析"></a>三、主要方法解析</h2><h3 id="3-1-hash-Object-key"><a href="#3-1-hash-Object-key" class="headerlink" title="3.1  hash(Object key)"></a>3.1  hash(Object key)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * key首先经过原生的hash方法后返回int类型的hash值，将该值的高16位右移传递到低16位并与原来的值异或运算。
 * 这样处理是为了将key的hash值的高位特征传递到低位，降低hash冲突的概率。
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-2-put-K-key-V-value"><a href="#3-2-put-K-key-V-value" class="headerlink" title="3.2  put(K key, V value)"></a>3.2  put(K key, V value)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 在map中将指定的键和值进行关联映射，如果map中已经存在该键的映射关系，
 * 那么map中该键关联的值将被替换。
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return 返回key关联的旧值，如果原来key关联的为null，则返回null
 */</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * Implements Map.put and related methods
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don't change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */</span>
<span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> 
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> 
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token comment">// talbe在第一次使用时初始化</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// key的hash值未产生hash冲突，则将value作为第一个节点存储到map中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span> 
        <span class="token class-name">K</span> k<span class="token punctuation">;</span>
        <span class="token comment">// 出现hash冲突，且key与第一个节点相同，用节点e标记该节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment">// key所对应的槽中的第一个节点为TreeNode</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 出现hash冲突后，遍历列表</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 遍历列表，如无重复key值，将value值添加到列表末尾</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 如果列表长度大于等于阈值8，则将列表转换为红黑树</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token comment">// 如果列表中存在重复的key，用节点e标记已存在的节点</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 已存在key的映射</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// existing mapping for key</span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token comment">// onlyIfAbsent为false或旧值为null，将新的value映射到map中</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token comment">// </span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 返回key关联的旧值</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token comment">// map中数据量大于容量阈值（容量*加载因子），map进行扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-3-resize"><a href="#3-3-resize" class="headerlink" title="3.3  resize()"></a>3.3  resize()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 初始化或扩容（2倍），  如果为null，则按照初始容量分配，否则以2的倍数进行扩容。
 * @return the table
 */</span>
<span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 如果未超过容量最大值，则扩容2倍</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>
                 oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>
        <span class="token comment">// 初始化容量</span>
        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// zero initial threshold signifies using defaults</span>
        <span class="token comment">// 初始容量值为0，初始化时容量为默认大小16</span>
        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 初始化阈值（初始容量 * 加载因子）</span>
        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    <span class="token comment">// 容量扩大为原来的两倍</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 进行rehash，把数据转移的扩容后的HashMap中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token comment">// hash槽中只有一个元素时，直接转移过去</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token comment">// 节点类型为树节点，列表已转为红黑树了</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// preserve order</span>
                    
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                        <span class="token comment">// HashMap槽中的数据为列表时，由于HashMap扩容后容量变为原来的两倍，通                             // 过 `e.hash &amp; oldCap` 运算，如果结果等于0， 则表示当前元素在新                                 // table中位置与原来相同，如果不等于0，则在新table中位置需要增加原来的                             // 容量oldCap</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-treeifyBin-Node-lt-K-V-gt-tab-int-hash"><a href="#3-4-treeifyBin-Node-lt-K-V-gt-tab-int-hash" class="headerlink" title="3.4  treeifyBin(Node&lt;K,V&gt;[] tab, int hash)"></a>3.4  treeifyBin(Node&lt;K,V&gt;[] tab, int hash)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 将列表转红黑树
 */</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> 
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>
    <span class="token comment">// 如果数组为null或数组容量小于列表转红黑树的阈值（64），则进行初始化或扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 将列表节点转换为红黑树节点</span>
            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                hd <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>
                tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            tl <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="四、多线程下HashMap死循环问题分析"><a href="#四、多线程下HashMap死循环问题分析" class="headerlink" title="四、多线程下HashMap死循环问题分析"></a>四、多线程下HashMap死循环问题分析</h2><p>HashMap多线程下死循环问题在JDK1.7存在，JDK1.8已经解决了死循环的问题，但仍然不是线程安全的。</p>
<blockquote>
<p>JDK1.7多线程下死循环代码分析</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Rehashes the contents of this map into a new array with a
 * larger capacity.  This method is called automatically when the
 * number of keys in this map reaches its threshold.
 *
 * If current capacity is MAXIMUM_CAPACITY, this method does not
 * resize the map, but sets threshold to Integer.MAX_VALUE.
 * This has the effect of preventing future calls.
 *
 * @param newCapacity the new capacity, MUST be a power of two;
 *        must be greater than current capacity unless current
 *        capacity is MAXIMUM_CAPACITY (in which case value
 *        is irrelevant).
 */</span>
<span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>
    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * Transfers all entries from current table to newTable.
 */</span>
<span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
            e <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>上述代码在多线程下出现死循环的地方在transfer方法的内的do-while循环内，假设线程1在执行do-while循环的第2行代码时被挂起，此时线程1的记录了e节点信息和e.next节点信息，如果此时另外一个线程完成了整个扩容操作，此时线程1再次执行，由于线程2在执行扩容时，列表按照头插法的方式插入，线程1记录的仍是原列表的顺序，线程1继续操作，会导致列表首位相连，从而产生死循环。</p>
<p> 此外，HashMap在多线程环境下还可能导致put操作导致元素丢失。</p>
<p>死循环产生的具体过程可参考：[<a href="https://www.cnblogs.com/dongguacai/p/5599100.html">深入理解JAVA集合系列三：HashMap的死循环解读</a>]</p>
</blockquote>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>HashMap底层基于数组和列表来实现的，将key经过hash散列再按数组长度取模运算，定位到一个hash槽，将key-value值作为一个节点存储到hash槽中，如果槽中出现hash冲突，则以列表的形式存储节点，当列表长度大于等于8时且map中总结点个数大于等于64时，则将列表转换为红黑树。</li>
<li>当HashMap中的节点个数超过容量阈值（容量*加载因子）时，HashMap会进行扩容，扩容是会进行rehash。</li>
<li>当HashMap中某个槽中的元素个数大于等于8且总元素个数小于64时，这时候HashMap会进行扩容而不是转为红黑树。</li>
<li>HashMap的初始容量设置成initialCapacity = (需要存储的元素个数 / 负载因子) + 1，如果不确定，设置为16（默认值）。</li>
<li>在JDK1.8中，当HashMap某个槽中的元素个数大于等于8时，且总元素个数超过64，则将列表转化为红黑树提高查找速度。</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA快捷键使用</title>
    <url>/2021/12/28/java/intellij-idea-kuai-jie-jian-shi-yong/</url>
    <content><![CDATA[<h1 id="工具用得好，下班下得早"><a href="#工具用得好，下班下得早" class="headerlink" title="工具用得好，下班下得早"></a>工具用得好，下班下得早</h1><h2 id="Ctrl-Alt-T"><a href="#Ctrl-Alt-T" class="headerlink" title="Ctrl + Alt + T"></a>Ctrl + Alt + T</h2><p>使用if，if/else, while, do/while, for, try/catch, try/finally, try/catch/finally, synchronized, Runnalbe 包围代码块</p>
<h2 id="Alt-Enter"><a href="#Alt-Enter" class="headerlink" title="Alt + Enter"></a>Alt + Enter</h2><p>代码快速补全、包引入、临时变量生成等</p>
<h2 id="Ctrl-Alt-M"><a href="#Ctrl-Alt-M" class="headerlink" title="Ctrl + Alt + M"></a>Ctrl + Alt + M</h2><p>将代码块提取到一个方法</p>
<h2 id="Ctrl-Shift-上下方向键"><a href="#Ctrl-Shift-上下方向键" class="headerlink" title="Ctrl + Shift + 上下方向键"></a>Ctrl + Shift + 上下方向键</h2><p>上下移动单行代码和代码块</p>
<h2 id="Class-new-（Alt-Enter）"><a href="#Class-new-（Alt-Enter）" class="headerlink" title="Class.new + （Alt + Enter）"></a>Class.new + （Alt + Enter）</h2><p><code>Class.new</code>创建一个Class类型的匿名对象，<code>Alt + Enter</code>将匿名对象赋值给一个新建的变量</p>
<h2 id="instance-try"><a href="#instance-try" class="headerlink" title="instance.try"></a>instance.try</h2><p>根据instance实例对象快速生成try/catch代码块</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 和 HTTP 的那些事（四） HTTPS 和 证书</title>
    <url>/2020/07/09/java/java-he-http-de-na-xie-shi-si-https-he-zheng-shu/</url>
    <content><![CDATA[<blockquote>
<p>非原创，转载于：<a href="https://www.aneasystone.com/archives/2016/04/java-and-https.html">https://www.aneasystone.com/archives/2016/04/java-and-https.html</a></p>
</blockquote>
<p>说起 HTTP 的那些事，则不得不提 HTTPS ，而说起 HTTPS ，则不得不提数字证书。这篇博客将从 Java 的角度，学习 HTTPS 和数字证书技术，并分享爬虫开发的过程中针对爬取 HTTPS 站点时可能遇到的一些问题。<br>在前面的几篇博客里，其实已经略微提到过 HTTPS 了，譬如使用 <code>HttpsURLConnection</code> 类发送 HTTPS 请求，在使用代理时 HTTP 和 HTTPS 的一些差异等等。关于 HTTPS 的概念就不废话了，下面直接进入正题。</p>
<h2 id="一、访问-HTTPS-站点"><a href="#一、访问-HTTPS-站点" class="headerlink" title="一、访问 HTTPS 站点"></a>一、访问 HTTPS 站点</h2><p>在前面的第一篇博客<a href="https://www.aneasystone.com/archives/2015/12/java-and-http-one.html">《模拟 HTTP 请求》</a>里，介绍了两种方法来模拟发送 HTTP 请求，访问 HTTP 站点。一种方式是通过 java.net 自带的 <code>HttpURLConnection</code>，另一种方式是通过 Apache 的 <code>HttpClient</code>，这两种方式各有各的优势。这里也使用这两种方式来访问 HTTPS 站点，从下面的代码可以看到，和前面访问 HTTP 站点几乎完全一样。</p>
<h3 id="1-1-使用-HttpURLConnection"><a href="#1-1-使用-HttpURLConnection" class="headerlink" title="1.1 使用 HttpURLConnection"></a>1.1 使用 HttpURLConnection</h3><pre class="line-numbers language-none"><code class="language-none">@Test
public void basicHttpsGet() throws Exception &#123;
     
    String url &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;;
    URL obj &#x3D; new URL(url);
 
    HttpsURLConnection con &#x3D; (HttpsURLConnection) obj.openConnection();    
    con.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) ...&quot;);
    con.setRequestProperty(&quot;Accept-Language&quot;, &quot;en-US,en;q&#x3D;0.5&quot;);
    con.setRequestMethod(&quot;GET&quot;);
 
    String responseBody &#x3D; readResponseBody(con.getInputStream());
    System.out.println(responseBody);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-2-使用-HttpClient"><a href="#1-2-使用-HttpClient" class="headerlink" title="1.2 使用 HttpClient"></a>1.2 使用 HttpClient</h3><pre class="line-numbers language-none"><code class="language-none">@Test
public void basicHttpsGet() throws Exception &#123;
     
    String url &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;;    
    HttpGet request &#x3D; new HttpGet(url);
    request.setHeader(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) ...&quot;);
     
    CloseableHttpClient httpclient &#x3D; HttpClients.createDefault();
    CloseableHttpResponse response &#x3D; httpclient.execute(request);
    String responseBody &#x3D; readResponseBody(response);
    System.out.println(responseBody);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>具体的代码解释参见第一篇博客，这里不再赘述。一般情况下，访问 HTTPS 站点就和访问 HTTP 站点一样简单，无论是 HttpURLConnection 还是 HttpClient ，都将底层的实现细节封装了起来，给我们提供了一致的对外接口，所以我们不用关心 HTTPS 的实现原理。对底层细节的封装，本来是一件好事，也是一种好的设计方式，可以让开发人员使用起来更方便，提高开发效率，但是对于那些不求甚解的人来说，可能带来的困惑比之带来的方便要更多。</p>
<h3 id="1-3-遭遇-PKIX-path-building-failed"><a href="#1-3-遭遇-PKIX-path-building-failed" class="headerlink" title="1.3 遭遇 PKIX path building failed"></a>1.3 遭遇 PKIX path building failed</h3><p>使用上面的代码作为爬虫程序爬取成千上万的网页，在大多数情况下，无论是 HTTP 也好，HTTPS 也罢，都可以很好的工作。不过有时候，你可能没那么好的运气，有些站点在墙外，被强大的防火长城拒之门外，这时你可以找一些境外代理，通过<a href="https://www.aneasystone.com/archives/2015/12/java-and-http-using-proxy.html">《使用代理》</a>这篇博客中介绍的方法来解决；有些站点需要使用身份认证输入用户名密码才能访问，这可以使用上一篇博客<a href="https://www.aneasystone.com/archives/2016/03/java-and-http-authentication.html">《代理认证》</a>中介绍的方法来解决；另外，在访问有些 HTTPS 站点时，你还可能会遇到下面的异常：</p>
<blockquote>
<p>javax.net.ssl.SSLHandshakeException:<br>sun.security.validator.ValidatorException: PKIX path building failed:<br>sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</p>
</blockquote>
<p>要解决这个异常，这就是我们这篇将要介绍的内容。</p>
<h2 id="二、证书认证的原理"><a href="#二、证书认证的原理" class="headerlink" title="二、证书认证的原理"></a>二、证书认证的原理</h2><p>大多数人第一次遇到上面的异常时的反应，估计都是一脸茫然，因为这个异常信息提示比较模糊，对于不懂 HTTPS 的人来说，什么 SSLHandshake ，什么 PKIX path ，完全不知所云。所以我们要先弄懂 HTTPS 的工作原理，才好去解决这个问题。我们知道 HTTPS 其实就是 HTTP + SSL/TLS 的合体，它其实还是 HTTP 协议，只是在外面加了一层，SSL 是一种加密安全协议，引入 SSL 的目的是为了解决 HTTP 协议在不可信网络中使用明文传输数据导致的安全性问题。可以说，整个互联网的通信安全，都是建立在 SSL/TLS 的安全性之上的。</p>
<h3 id="2-1-SSL-TLS-协议及其握手过程"><a href="#2-1-SSL-TLS-协议及其握手过程" class="headerlink" title="2.1 SSL/TLS 协议及其握手过程"></a>2.1 SSL/TLS 协议及其握手过程</h3><p>学过计算机网络的同学肯定都还记得 TCP 在建立连接时的三次握手，之所以需要 TCP 三次握手，是因为网络中存在延迟的重复分组，可能会导致服务器重复建立连接造成不必要的开销。SSL/TLS 协议在建立连接时与此类似，也需要客户端和服务器之间进行握手，但是其目的却大相径庭，在 SSL/TLS 握手的过程中，客户端和服务器彼此交换并验证证书，并协商出一个 “对话密钥” ，后续的所有通信都使用这个 “对话密钥” 进行加密，保证通信安全。</p>
<p>网上有很多 SSL/TLS 握手的示意图，其中下面这副非常全面，也非常专业，想深入了解 SSL/TLS 的同学可以研究下。</p>
<p><a href="http://www.cheat-sheets.org/saved-copy/Ssl_handshake_with_two_way_authentication_with_certificates-1.pdf">http://www.cheat-sheets.org/saved-copy/Ssl_handshake_with_two_way_authentication_with_certificates-1.pdf</a></p>
<p>阮一峰在他的 <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL/TLS协议运行机制的概述》</a> 和 <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解SSL/TLS协议》</a> 两篇博客中详细介绍了 SSL/TLS 的原理，感兴趣的同学可以去看看。我这里使用 <a href="https://publib.boulder.ibm.com/tividd/td/TRM/SC23-4822-00/zh_CN/HTML/user277.htm">IBM Tivoli Risk Manager 用户手册</a> 里的一张图（因为这张图比较浅显易懂）来大概的说明下我们在平时使用浏览器访问 HTTPS 站点时，中间发生的握手过程。</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/3515553513.png" alt="ssl_handshake.png"></p>
<p>整个 SSL/TLS 的握手和通信过程，简单来说，其实可以分成下面三个阶段：</p>
<ol>
<li>打招呼<ul>
<li>当用户通过浏览器访问 HTTPS 站点时，浏览器会向服务器打个招呼（ClientHello），服务器也会和浏览器打个招呼（ServerHello）。所谓的打招呼，实际上是告诉彼此各自的 SSL/TLS 版本号以及各自支持的加密算法等，让彼此有一个初步了解。</li>
</ul>
</li>
<li>表明身份、验证身份<ul>
<li>第二步是整个过程中最复杂的一步，也是 HTTPS 通信中的关键。为了保证通信的安全，首先要保证我正在通信的人确实就是那个我想与之通信的人，服务器会发送一个证书来表明自己的身份，浏览器根据证书里的信息进行核实（为什么通过证书就可以证明身份呢？怎么通过证书来验证对方的身份呢？这个后面再说）。如果是双向认证的话，浏览器也会向服务器发送客户端证书。</li>
<li>双方的身份都验证没问题之后，浏览器会和服务器协商出一个 “对话密钥” ，要注意这个 “对话密钥” 不能直接发给对方，而是要用一种只有对方才能懂的方式发给他，这样才能保证密钥不被别人截获（或者就算被截获了也看不懂）。</li>
</ul>
</li>
<li>通信<ul>
<li>至此，握手就结束了。双方开始聊天，并通过 “对话密钥” 加密通信的数据。</li>
</ul>
</li>
</ol>
<p>握手的过程大致如此，我们现在已经了解到 HTTPS 通信需要进行一次握手，所以上面看到的 <code>javax.net.ssl.SSLHandshakeException</code> 这个异常，我们也不难理解，实际上也就是在 SSL/TLS 握手的过程中出现了问题。当然，这其中还有很多很多细节，下面继续。</p>
<h3 id="2-2-HTTPS-中的密码学"><a href="#2-2-HTTPS-中的密码学" class="headerlink" title="2.2 HTTPS 中的密码学"></a>2.2 HTTPS 中的密码学</h3><p>HTTPS 协议之所以复杂，是为了保证通信过程中数据的安全性，而要保证通信安全，它在协议中运用了大量的密码学原理，可以说 HTTPS 是集密码学之大成。无论是在 SSL/TLS 握手的过程中，还是在加密通信的过程中，HTTPS 都涉及了大量的密码学概念，譬如，在证书的数字签名中使用了哈希算法和非对称加密算法，在加密通信的过程中使用了对称加密算法，为了防止传输的数据被篡改和重放还使用了 MAC（消息认证码）等。</p>
<p>要想深入了解 HTTPS 的工作原理，下面这些概念还是得好好研究下，网上已经有很多文章介绍这些概念了，我在这里总结一下。</p>
<ul>
<li>哈希<ul>
<li>哈希算法又称散列，它是一种将任意长度的数据转化为固定长度的算法</li>
<li>哈希算法是不可逆的</li>
<li>常见的哈希算法有 MD5 和 SHA1</li>
</ul>
</li>
<li>对称加密<ul>
<li>对称加密指的是加密和解密使用相同一个密钥</li>
<li>对称加密的优点是速度快，缺点是密钥管理不方便，必须共享密钥</li>
<li>常见的对称加密算法有 DES、AES、Blowfish 等</li>
</ul>
</li>
<li>非对称加密<ul>
<li>非对称加密指的是加密和解密使用不同的密钥，其中一个是公钥，另一个是私钥，公钥是公开的，私钥只有自己知道</li>
<li>使用公钥加密的数据必须使用私钥解密，使用私钥加密的数据必须使用公钥解密</li>
<li>公钥和私钥之间存在着某种联系，但是从公钥不能（或很难）推导出私钥</li>
<li>非对称加密的缺点是速度慢，优点是密钥管理很方便</li>
<li>常见的非对称加密算法有 RSA、ECC 等</li>
</ul>
</li>
<li>数字证书</li>
</ul>
<h3 id="2-3-关于证书"><a href="#2-3-关于证书" class="headerlink" title="2.3 关于证书"></a>2.3 关于证书</h3><p>简单来说，数字证书就好比介绍信上的公章，有了它，就可以证明这份介绍信确实是由某个公司发出的，而证书可以用来证明任何一个东西的身份，只要这个东西能出示一份证明自己身份的证书即可，譬如可以用来验证某个网站的身份，可以验证某个文件是否可信等等。<a href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html">《数字证书及 CA 的扫盲介绍》</a> 和 <a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html">《数字证书原理》</a> 这篇博客对数字证书进行了很通俗的介绍。</p>
<p>知道了证书是什么之后，我们往往更关心它的原理，在上面介绍 SSL/TLS 握手的时候留了两个问题：为什么通过证书就可以证明身份呢？怎么通过证书来验证对方的身份呢？</p>
<p>这就要用到上面所说的非对称加密了，非对称加密的一个重要特点是：使用公钥加密的数据必须使用私钥才能解密，同样的，使用私钥加密的数据必须使用公钥解密。正是因为这个特点，网站就可以在自己的证书中公开自己的公钥，并使用自己的私钥将自己的身份信息进行加密一起公开出来，这段被私钥加密的信息就是证书的数字签名，浏览器在获取到证书之后，通过证书里的公钥对签名进行解密，如果能成功解密，则说明证书确实是由这个网站发布的，因为只有这个网站知道他自己的私钥（如果他的私钥没有泄露的话）。</p>
<p>在非对称加密算法中，最出众的莫过于 RSA 算法，关于 RSA 算法的数学细节，可以参考阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA算法原理（一）》</a>和<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">《RSA算法原理（二）》</a>这两篇博客，强烈推荐。</p>
<p>当然，如果只是简单的对数字签名进行校验的话，还不能完全保证这个证书确实就是网站所有，黑客完全可以在中间进行劫持，使用自己的私钥对网站身份信息进行加密，并将证书中的公钥替换成自己的公钥，这样浏览器同样可以解密数字签名，签名中身份信息也是完全合法的。这就好比那些地摊上伪造公章的小贩，他们可以伪造出和真正的公章完全一样的出来以假乱真。为了解决这个问题，信息安全的专家们引入了 CA 这个东西，所谓 CA ，全称为 Certificate Authority ，翻译成中文就是<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84">证书授权中心</a>，它是专门负责管理和签发证书的第三方机构。因为证书颁发机构关系到所有互联网通信的身份安全，因此一定要是一个非常权威的机构，像 GeoTrust、GlobalSign 等等，这里有一份<a href="https://www.sslshopper.com/certificate-authority-reviews.html">常见的 CA 清单</a>。如果一个网站需要支持 HTTPS ，它就要一份证书来证明自己的身份，而这个证书必须从 CA 机构申请，大多数情况下申请数字证书的价格都不菲，不过也有一些免费的证书供个人使用，像最近比较火的 <a href="https://letsencrypt.org/">Let’s Encrypt</a> 。从安全性的角度来说，免费的和收费的证书没有任何区别，都可以为你的网站提供足够高的安全性，唯一的区别在于如果你从权威机构购买了付费的证书，一旦由于证书安全问题导致经济损失，可以获得一笔巨额的赔偿。</p>
<p>如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，便形成证书发给申请者。如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。通过这种方式，黑客就不能简单的修改证书中的公钥了，因为现在公钥有了 CA 的数字签名，由 CA 来证明公钥的有效性，不能轻易被篡改，而黑客自己的公钥是很难被 CA 认可的，所以我们无需担心证书被篡改的问题了。</p>
<p>下图显示了证书的申请流程（图片来自<a href="https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/">刘坤的技术博客</a>）：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/3454538623.png" alt="shuzizhengshu_5.png"></p>
<p>CA 证书可以具有层级结构，它建立了自上而下的信任链，下级 CA 信任上级 CA ，下级 CA 由上级 CA 颁发证书并认证。 譬如 Google 的证书链如下图所示：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/3953592763.png" alt="shuzizhengshu_6.png"></p>
<p>可以看出：google.com.hk 的 SSL 证书由 Google Internet Authority G2 这个 CA 来验证，而 Google Internet Authority G2 由 GeoTrust Global CA 来验证，GeoTrust Global CA 由 Equifax Secure Certificate Authority 来验证。这个最顶部的证书，我们称之为根证书（root certificate），那么谁来验证根证书呢？答案是它自己，根证书自己证明自己，换句话来说也就是根证书是不需要证明的。浏览器在验证证书时，从根证书开始，沿着证书链的路径依次向下验证，根证书是整个证书链的安全之本，如果根证书被篡改，整个证书体系的安全将受到威胁。所以不要轻易的相信根证书，当下次你访问某个网站遇到提示说，请安装我们的根证书，它可以让你访问我们网站的体验更流畅通信更安全时，最好留个心眼。在安装之前，不妨看看这几篇博客：<a href="https://www.jayxon.com/12306-certificate/">《12306的证书问题》</a>、<a href="http://www.xieyidian.com/3213">《在线买火车票为什么要安装根证书？》</a>。</p>
<p>最后总结一下，其实上面说的这些，什么非对称加密，数字签名，CA 机构，根证书等等，其实都是 PKI 的核心概念。PKI（Public Key Infrastructure）中文称作公钥基础设施，它提供公钥加密和数字签名服务的系统或平台，方便管理密钥和证书，从而建立起一个安全的网络环境。而数字证书最常见的格式是 X.509 ，所以这种公钥基础设施又称之为 PKIX 。</p>
<p>至此，我们大致弄懂了上面的异常信息，<code>sun.security.validator.ValidatorException: PKIX path building failed</code>，也就是在沿着证书链的路径验证证书时出现异常，验证失败了。</p>
<p>讲了这么多，全都是些理论的东西，下面开始实践吧，看看怎么解决这个异常。</p>
<h3 id="2-4-关于-Java-里的证书"><a href="#2-4-关于-Java-里的证书" class="headerlink" title="2.4 关于 Java 里的证书"></a>2.4 关于 Java 里的证书</h3><p>上面所介绍的是浏览器对证书进行验证的过程，浏览器保存了一个常用的 CA 证书列表，在验证证书链的有效性时，直接使用保存的证书里的公钥进行校验，如果在证书列表中没有找到或者找到了但是校验不通过，那么浏览器会警告用户，由用户决定是否继续。与此类似的，操作系统也一样保存有一份可信的证书列表，譬如在 Windows 系统下，你可以运行 <code>certmgr.msc</code> 打开证书管理器查看，这些证书实际上是存储在 Windows 的注册表中，一般情况下位于：<code>\SOFTWARE\Microsoft\SystemCertificates\</code> 路径下。那么在 Java 程序中是如何验证证书的呢？</p>
<p>和浏览器和操作系统类似，Java 在 JRE 的安装目录下也保存了一份默认可信的证书列表，这个列表一般是保存在 <code>$JRE/lib/security/cacerts</code> 文件中。要查看这个文件，可以使用类似 <a href="http://www.keystore-explorer.org/">KeyStore Explorer</a> 这样的软件，当然也可以使用 JRE 自带的 keytool 工具（后面再介绍），cacerts 文件的默认密码为 <code>changeit</code> （但是我保证，大多数人都不会 change it）。</p>
<p>我们知道，证书有很多种不同的存储格式，譬如 CA 在发布证书时，常常使用 PEM 格式，这种格式的好处是纯文本，内容是 BASE64 编码的，证书中使用 “—–BEGIN CERTIFICATE—–” 和 “—–END CERTIFICATE—–” 来标识。另外还有比较常用的二进制 DER 格式，在 Windows 平台上较常使用的 PKCS#12 格式等等。当然，不同格式的证书之间是可以相互转换的，我们可以使用 <code>openssl</code> 这个命令行工具来转换，参考 <a href="https://www.sslshopper.com/ssl-converter.html">SSL Converter</a> ，另外，想了解更多证书格式的，可以参考这里：<a href="https://blogs.msdn.microsoft.com/kaushal/2010/11/04/various-ssltls-certificate-file-typesextensions/">Various SSL/TLS Certificate File Types/Extensions</a> 。</p>
<p>在 Java 平台下，证书常常被存储在 KeyStore 文件中，上面说的 cacerts 文件就是一个 KeyStore 文件，KeyStore 不仅可以存储数字证书，还可以存储密钥，存储在 KeyStore 文件中的对象有三种类型：Certificate、PrivateKey 和 SecretKey 。Certificate 就是证书，PrivateKey 是非对称加密中的私钥，SecretKey 用于对称加密，是对称加密中的密钥。KeyStore 文件根据用途，也有很多种不同的格式：JKS、JCEKS、PKCS12、DKS 等等，PixelsTech 上有一系列文章对 KeyStore 有深入的介绍，可以学习下：<a href="http://www.pixelstech.net/article/1408345768-Different-types-of-keystore-in-Java----Overview">Different types of keystore in Java</a> 。</p>
<p>到目前为止，我们所说的 KeyStore 其实只是一种文件格式而已，实际上在 Java 的世界里 KeyStore 文件分成两种：KeyStore 和 TrustStore，这是两个比较容易混淆的概念，不过这两个东西从文件格式来看其实是一样的。KeyStore 保存私钥，用来加解密或者为别人做签名；TrustStore 保存一些可信任的证书，访问 HTTPS 时对被访问者进行认证，以确保它是可信任的。所以准确来说，上面的 cacerts 文件应该叫做 TrustStore 而不是 KeyStore，只是它的文件格式是 KeyStore 文件格式罢了。</p>
<p>除了 KeyStore 和 TrustStore ，Java 里还有两个类 KeyManager 和 TrustManager 与此息息相关。<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html">JSSE 的参考手册</a>中有一张示意图，说明了各个类之间的关系：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/4013537635.jpg" alt="jsse-class.jpg"></p>
<p>可以看出如果要进行 SSL 会话，必须得新建一个 <code>SSLSocket</code> 对象，而 SSLSocket 对象是通过 <code>SSLSocketFactory</code> 来管理的，SSLSocketFactory 对象则依赖于 <code>SSLContext</code> ，SSLContext 对象又依赖于 <code>keyManager</code>、<code>TrustManager</code> 和 <code>SecureRandom</code>。我们这里最关心的是 TrustManager 对象，另外两个暂且忽略，因为正是 TrustManager 负责证书的校验，对网站进行认证，要想在访问 HTTPS 时通过认证，不报 <code>sun.security.validator.ValidatorException</code> 异常，必须从这里开刀。</p>
<h2 id="三、自定义-TrustManager-绕过证书检查"><a href="#三、自定义-TrustManager-绕过证书检查" class="headerlink" title="三、自定义 TrustManager 绕过证书检查"></a>三、自定义 TrustManager 绕过证书检查</h2><p>我们知道了 TrustManager 是专门负责校验证书的，那么最容易想到的方法应该就是改写 TrustManager 类，让它不要对证书做校验，这种方法虽然粗暴，但是却相当有效，而且 Java 中的 TrustManager 也确实可以被重写，下面是示例代码：</p>
<pre class="line-numbers language-none"><code class="language-none">@Test
public void basicHttpsGetIgnoreCertificateValidation() throws Exception &#123;
     
    String url &#x3D; &quot;https:&#x2F;&#x2F;kyfw.12306.cn&#x2F;otn&#x2F;&quot;;
     
    &#x2F;&#x2F; Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts &#x3D; new TrustManager[] &#123;
        new X509TrustManager() &#123;
            public X509Certificate[] getAcceptedIssuers() &#123;
                return null;
            &#125;
            public void checkClientTrusted(X509Certificate[] certs, String authType) &#123;
                &#x2F;&#x2F; don&#39;t check
            &#125;
            public void checkServerTrusted(X509Certificate[] certs, String authType) &#123;
                &#x2F;&#x2F; don&#39;t check
            &#125;
        &#125;
    &#125;;
     
    SSLContext ctx &#x3D; SSLContext.getInstance(&quot;TLS&quot;);
    ctx.init(null, trustAllCerts, null);
     
    LayeredConnectionSocketFactory sslSocketFactory &#x3D; new SSLConnectionSocketFactory(ctx);
     
    CloseableHttpClient httpclient &#x3D; HttpClients.custom()
            .setSSLSocketFactory(sslSocketFactory)
            .build();
     
    HttpGet request &#x3D; new HttpGet(url);
    request.setHeader(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) ...&quot;);
     
    CloseableHttpResponse response &#x3D; httpclient.execute(request);
    String responseBody &#x3D; readResponseBody(response);
    System.out.println(responseBody);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们新建了一个匿名类，继承自 <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html#X509TrustManager"><code>X509TrustManager</code></a> 接口，这个接口提供了三个方法用于验证证书的有效性：<code>getAcceptedIssuers</code>、<code>checkClientTrusted</code>、<code>checkServerTrusted</code>，我们在验证的函数中直接返回，不做任何校验，这样在访问 HTTPS 站点时，就算是证书不可信，也不会抛出异常，可以继续执行下去。</p>
<p>这种方法虽然简单，但是却有一个最严重的问题，就是不安全。因为不对证书做任何合法性校验，而且这种处理是全局性的，不管青红皂白，所有的证书都不会做验证，所以就算遇到不信任的证书，代码依然会继续与之通信，至于通信的数据安全不安全就不能保证了。所以如果你只是想在测试环境做个实验，那没问题，但是如果你要将代码发布到生产环境，请慎重。</p>
<h2 id="四、使用证书"><a href="#四、使用证书" class="headerlink" title="四、使用证书"></a>四、使用证书</h2><p>对于有些证书，我们基本上确定是可以信任的，但是这些证书又不在 Java 的 cacerts 文件中，譬如 12306 网站，或者使用了 Let’s Encrypt 证书的一些网站，对于这些网站，我们可以将其添加到信任列表中，而不是使用上面的方法统统都相信，这样程序的安全性仍然可以得到保障。</p>
<h3 id="4-1-使用-keytool-导入证书"><a href="#4-1-使用-keytool-导入证书" class="headerlink" title="4.1 使用 keytool 导入证书"></a>4.1 使用 keytool 导入证书</h3><p>简单的做法是将这些网站的证书导入到 cacerts 文件中，这样 Java 程序在校验证书的时候就可以从 cacerts 文件中找到并成功校验这个证书了。上面我们介绍过 JRE 自带的 keytool 这个工具，这个工具小巧而强悍，拥有很多功能。首先我们可以使用它查看 KeyStore 文件，使用下面的命令可以列出 KeyStore 文件中的所有内容（包括证书、私钥等）：</p>
<pre class="line-numbers language-none"><code class="language-none">$ keytool -list -keystore cacerts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后通过下面的命令，将证书导入到 cacerts 文件中：</p>
<pre class="line-numbers language-none"><code class="language-none">$ keytool -import -alias 12306 -keystore cacerts -file 12306.cer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>要想将网站的证书导入 cacerts 文件中，首先要获取网站的证书，譬如上面命令中的 12306.cer 文件，它是使用浏览器的证书导出向导保存的。如下图所示：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/898222994.png" alt="export-cert.png"></p>
<p>关于 keytool 的更多用法，可以参考 <a href="https://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool 的官网手册</a>，SSLShopper 上也有一篇文章列出了<a href="https://www.sslshopper.com/article-most-common-java-keytool-keystore-commands.html">常用的 keytool 命令</a>。</p>
<h3 id="4-2-使用-KeyStore-动态加载证书"><a href="#4-2-使用-KeyStore-动态加载证书" class="headerlink" title="4.2 使用 KeyStore 动态加载证书"></a>4.2 使用 KeyStore 动态加载证书</h3><p>使用 keytool 导入证书，这种方法不仅简单，而且保证了代码的安全性，最关键的是代码不用做任何修改。所以我比较推荐这种方法。但是这种方法有一个致命的缺陷，那就是你需要修改 JRE 目录下的文件，如果你的程序只是在自己的电脑上运行，那倒没什么，可如果你的程序要部署在其他人的电脑上或者公司的服务器上，而你没有权限修改 JRE 目录下的文件，这该怎么办？如果你的程序是一个分布式的程序要部署在成百上千台机器上，难道还得修改每台机器的 JRE 文件吗？好在我们还有另一种通过编程的手段来实现的思路，在代码中动态的加载 KeyStore 文件来完成证书的校验，抱着知其然知其所以然的态度，我们在最后也实践下这种方法。通过编写代码可以更深刻的了解 <code>KeyStore</code>、<code>TrustManagerFactory</code>、<code>SSLContext</code> 以及 <code>SSLSocketFactory</code> 这几个类之间的关系。</p>
<pre class="line-numbers language-none"><code class="language-none">@Test
public void basicHttpsGetUsingSslSocketFactory() throws Exception &#123;
 
    String keyStoreFile &#x3D; &quot;D:\\code\\ttt.ks&quot;;
    String password &#x3D; &quot;poiuyt&quot;;
    KeyStore ks &#x3D; KeyStore.getInstance(KeyStore.getDefaultType());
    FileInputStream in &#x3D; new FileInputStream(keyStoreFile);
    ks.load(in, password.toCharArray());
     
    System.out.println(KeyStore.getDefaultType().toString());
    System.out.println(TrustManagerFactory.getDefaultAlgorithm().toString());
     
    TrustManagerFactory tmf &#x3D; TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(ks);
    SSLContext ctx &#x3D; SSLContext.getInstance(&quot;TLS&quot;);
    ctx.init(null, tmf.getTrustManagers(), null);
     
    LayeredConnectionSocketFactory sslSocketFactory &#x3D; new SSLConnectionSocketFactory(ctx);
     
    String url &#x3D; &quot;https:&#x2F;&#x2F;ttt.aneasystone.com&quot;;
     
    &#x2F;**
     * Return the page with content:
     *     401 Authorization Required
     *&#x2F;
     
    CloseableHttpClient httpclient &#x3D; HttpClients.custom()
            .setSSLSocketFactory(sslSocketFactory)
            .build();
     
    HttpGet request &#x3D; new HttpGet(url);
    request.setHeader(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) ...&quot;);
     
    CloseableHttpResponse response &#x3D; httpclient.execute(request);
    String responseBody &#x3D; readResponseBody(response);
    System.out.println(responseBody);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的代码使用了 HttpClient ，如果是使用 HttpsURLConnection 只需要改动下面两行即可：</p>
<pre class="line-numbers language-none"><code class="language-none">HttpsURLConnection con &#x3D; (HttpsURLConnection) obj.openConnection();
con.setSSLSocketFactory(ctx.getSocketFactory());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>最后的最后，我们还可以通过下面的属性来指定 trustStore ，这样也不需要编写像上面那样大量繁琐的代码，另外，参考我前面的博客，这些属性还可以通过 JVM 的参数来设置。</p>
<pre class="line-numbers language-none"><code class="language-none">System.setProperty(&quot;javax.net.ssl.trustStore&quot;, &quot;D:\\code\\ttt.ks&quot;);
System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, &quot;poiuyt&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们的 HTTPS 之旅就要告一段落了。在学习 HTTPS 的过程中，我时时不经意的会被 HTTPS 中的一些技术或技巧感触到，特别是证书的认证过程以及非对称加密算法的原理，真的是积累了人类无穷的智慧，让人不得不感叹数学的美妙。而在学习过程中越是刨根问底，越是一发不可收拾，中间牵扯到的细节太多，太深入反而让人不自觉的迷失了方向。这篇博客断断续续的写了一个多月，慢慢的自己也是从对 HTTPS 一知半解，到现在的初窥门径。写的越多，越发觉自己很多东西不清楚，看得资料越多，越是不敢写，怕写错。这篇博客参考资料众多，质量也参差不齐，不能说对读者会起什么作用，但是确实是在我学习过程中帮我理清了很多思路。在这里对这些博客的原作者表示感谢。同时，如果你发现本篇博客中存在什么问题或错误，欢迎斧正。</p>
<p>共勉。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://publib.boulder.ibm.com/tividd/td/TRM/SC23-4822-00/zh_CN/HTML/user277.htm">SSL 如何工作</a></li>
<li><a href="https://segmentfault.com/a/1190000002963044">SSL/TLS 协议简介与实例分析</a></li>
<li><a href="https://segmentfault.com/a/1190000002554673">SSL/TLS原理详解</a></li>
<li><a href="https://imququ.com/post/optimize-tls-handshake.html">TLS 握手优化详解</a></li>
<li><a href="https://imququ.com/post/how-to-decrypt-https.html">三种解密 HTTPS 流量的方法介绍</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">图解SSL/TLS协议</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li>
<li><a href="http://www.oschina.net/news/26228/how-to-config-https">HTTPS 从原理到实战</a></li>
<li><a href="http://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html">HTTPS工作原理和TCP握手机制</a></li>
<li><a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html">扫盲 HTTPS 和 SSL/TLS 协议</a></li>
<li><a href="http://www.guokr.com/post/114121/">HTTPS那些事（一）HTTPS原理</a></li>
<li><a href="http://www.lupaworld.com/article-252898-1.html">理解HTTPS协议</a></li>
<li><a href="http://drops.wooyun.org/tips/6002">SSL/TLS协议安全系列：SSL/TLS概述</a></li>
<li><a href="http://www.pixelstech.net/article/1408345768-Different-types-of-keystore-in-Java----Overview">Different types of keystore in Java – Overview</a></li>
<li><a href="http://www.pixelstech.net/article/1409966488-Different-types-of-keystore-in-Java----JKS">Different types of keystore in Java – JKS</a></li>
<li><a href="http://www.binghe.org/2010/03/use-httpsurlconnection-in-java/">Java中用HttpsURLConnection访问Https链接的问题</a></li>
<li><a href="http://superuser.com/questions/411909/where-is-the-certificate-folder-in-windows-7">Where is the certificate folder in Windows 7?</a></li>
<li><a href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html">数字证书及 CA 的扫盲介绍</a></li>
<li><a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html">数字证书原理</a></li>
<li><a href="https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/">数字证书</a></li>
<li><a href="http://blog.chenxiaosheng.com/posts/2013-12-26/java-use-self_signed_certificate.html">Java 使用自签证书访问https站点</a></li>
<li><a href="https://www.jayxon.com/12306-certificate/">12306的证书问题</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a></li>
<li><a href="http://www.xieyidian.com/3213">在线买火车票为什么要安装根证书？</a></li>
<li><a href="http://snowolf.iteye.com/blog/391931">Java加密技术（八）——数字证书</a></li>
<li><a href="http://snowolf.iteye.com/blog/397693">Java加密技术（九）——初探SSL</a></li>
<li><a href="http://www.cnblogs.com/lzjsky/archive/2010/09/29/1838240.html">常见的数字证书格式</a></li>
<li><a href="http://lukejin.iteye.com/blog/605634">keyStore vs trustStore</a></li>
<li><a href="http://javarevisited.blogspot.jp/2012/09/difference-between-truststore-vs-keyStore-Java-SSL.html">Difference between trustStore and keyStore in Java - SSL</a></li>
<li><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html">Java Secure Socket Extension (JSSE) Reference Guide</a></li>
<li><a href="http://www.nakov.com/blog/2009/07/16/disable-certificate-validation-in-java-ssl-connections/">Disable Certificate Validation in Java SSL Connections</a></li>
<li><a href="http://www.java-samples.com/showtutorial.php?tutorialid=210">javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed</a></li>
<li><a href="http://wsigrid.blogspot.jp/2008/12/how-to-solve-javaxnetsslsslhandshakeexc.html">How to solve javax.net.ssl.SSLHandshakeException?</a></li>
<li><a href="https://www.sslshopper.com/ssl-converter.html">SSL Converter</a></li>
<li><a href="https://www.sslshopper.com/article-most-common-java-keytool-keystore-commands.html">The Most Common Java Keytool Keystore Commands</a></li>
<li><a href="https://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool - Key and Certificate Management Tool</a></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Https</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中一个对象占用多少个字节</title>
    <url>/2022/01/20/java/java-zhong-yi-ge-dui-xiang-zhan-yong-duo-shao-ge-zi-jie/</url>
    <content><![CDATA[<blockquote>
<p>说明：本文内容参考文章:<a href="https://www.cnblogs.com/jajian/p/13681781.html">码辣架构-Java对象的内存布局</a>，详解内容请阅读原文。</p>
</blockquote>
<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>在开发过程中，我们经常使用JVM进行缓存一些数据来提高程序的性能，但是我们需要对缓存的数据进行大小估算，防止产生OOM问题，为保证估算的准确性，需要了解一个Java对象在内存中具体占用多少个字节。</p>
<h1 id="二、一个Java对象的组成"><a href="#二、一个Java对象的组成" class="headerlink" title="二、一个Java对象的组成"></a>二、一个Java对象的组成</h1><table>
<thead>
<tr>
<th>组成部分</th>
<th>对象头（object header）</th>
<th>实例数据（Instance Data）</th>
<th>对齐填充（Padding）</th>
</tr>
</thead>
<tbody><tr>
<td>说明</td>
<td>包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。</td>
<td>主要是存放类的数据信息，父类的信息，对象字段属性信息。</td>
<td>为了字节对齐，填充的数据，不是必须的。</td>
</tr>
<tr>
<td>大小</td>
<td>12 byte</td>
<td>基本类型数据类型和引用类型的大小</td>
<td>对象大小不满足8byte的倍数时进行填充</td>
</tr>
</tbody></table>
<blockquote>
<p>提示：JDK6之后默认都是开始指针压缩的，所以对象头中<code>mark word</code>占用8个byte，<code>klass pointer</code>占用4个byte</p>
</blockquote>
<h2 id="object-header"><a href="#object-header" class="headerlink" title="object header"></a>object header</h2><blockquote>
<p>Common structure at the beginning of every GC-managed heap object. (Every oop points to an object header.) Includes fundamental information about the heap object’s layout, type, GC state, synchronization state, and identity hash code.<br>Consists of two words. In arrays it is immediately followed by a length field. Note that both Java objects and VM-internal objects have a common object header format.</p>
</blockquote>
<h3 id="mark-word"><a href="#mark-word" class="headerlink" title="mark word"></a>mark word</h3><blockquote>
<p>The first word of every object header. Usually a set of bitfields including synchronization state and identity hash code. May also be a pointer (with characteristic low bit encoding) to synchronization related information. During GC, may contain GC state bits.</p>
</blockquote>
<p>用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。</p>
<blockquote>
<p>Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。<br>打开openjdk的源码包，对应路径/openjdk/hotspot/src/share/vm/oops，Mark Word对应到C++的代码markOop.hpp，可以从注释中看到它们的组成，本文所有代码是基于Jdk1.8。</p>
</blockquote>
<p><img src="/2022/01/20/java/java-zhong-yi-ge-dui-xiang-zhan-yong-duo-shao-ge-zi-jie/markoop.png" alt="markoop"><br>Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的<br><img src="/2022/01/20/java/java-zhong-yi-ge-dui-xiang-zhan-yong-duo-shao-ge-zi-jie/markword32.png" alt="markword32"><br>在64位JVM中是这么存的<br><img src="/2022/01/20/java/java-zhong-yi-ge-dui-xiang-zhan-yong-duo-shao-ge-zi-jie/markword64.png" alt="markword64"></p>
<p>虽然它们在不同位数的JVM中长度不一样，但是基本组成内容是一致的。</p>
<ul>
<li>锁标志位（lock）：区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。</li>
<li>biased_lock：是否偏向锁，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。</li>
<li>分代年龄（age）：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。</li>
<li>对象的hashcode（hash）：运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。</li>
<li>偏向锁的线程ID（JavaThread）：偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。</li>
<li>epoch：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。</li>
<li>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。</li>
<li>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。</li>
</ul>
<h3 id="klass-pointer"><a href="#klass-pointer" class="headerlink" title="klass pointer"></a>klass pointer</h3><blockquote>
<p>The second word of every object header. Points to another object (a metaobject) which describes the layout and behavior of the original object. For Java objects, the “klass” contains a C++ style “vtable”.</p>
</blockquote>
<p>即类型指针，是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>JVM默认开启了指针压缩 ，对象头占了12byte，类型指针占4个byte，如果关闭指针压缩则类型指针占8个byte。</p>
<blockquote>
<p>jdk8版本是默认开启指针压缩的，可以通过配置vm参数开启关闭指针压缩，-XX:-UseCompressedOops。</p>
</blockquote>
<h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>如果对象有属性字段，则这里会有数据信息。如果对象无属性字段，则这里就不会有数据。根据字段类型的不同占不同的字节，例如boolean类型占1个字节，int类型占4个字节等等；</p>
<h2 id="对齐数据"><a href="#对齐数据" class="headerlink" title="对齐数据"></a>对齐数据</h2><p>对象可以有对齐数据也可以没有。默认情况下，Java虚拟机堆中对象的起始地址需要对齐至8的倍数。如果一个对象用不到8N个字节则需要对其填充，以此来补齐对象头和实例数据占用内存之后剩余的空间大小。如果对象头和实例数据已经占满了JVM所分配的内存空间，那么就不用再进行对齐填充了。</p>
<p>所有的对象分配的字节总SIZE需要是8的倍数，如果前面的对象头和实例数据占用的总SIZE不满足要求，则通过对齐数据来填满。</p>
<h3 id="为什么要对齐数据？"><a href="#为什么要对齐数据？" class="headerlink" title="为什么要对齐数据？"></a>为什么要对齐数据？</h3><p>字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</p>
<p>至此，我们已经了解了对象在堆内存中的整体结构布局，如下图所示：<br><img src="/2022/01/20/java/java-zhong-yi-ge-dui-xiang-zhan-yong-duo-shao-ge-zi-jie/object-component.png" alt="object-component"></p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>一个Java对象由三部分组成，分别是对象头、实例数据、填充数据：</p>
<ul>
<li>对象头占12个字节（64位JVM），包括<code>mark word</code>、<code>klass pointer</code>两个部分</li>
<li>实例数据中包括基本类型和引用类型，基本类型占对应大小，引用类型占用1个字节</li>
<li>当对象的大小不是8字节的倍数的时候，对齐数据则会进行填充</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote>
<p><a href="https://www.cnblogs.com/jajian/p/13681781.html">Java对象的内存布局</a><br><a href="https://www.jianshu.com/p/ad505f9163b2">如何正确计算Java对象所占内存？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的强引用、软引用、弱引用和虚引用</title>
    <url>/2018/07/26/java/java-zhong-de-qiang-yin-yong-ruan-yin-yong-ruo-yin-yong-he-xu-yin-yong/</url>
    <content><![CDATA[<h1 id="Java中的强引用、软引用、弱引用和虚引用"><a href="#Java中的强引用、软引用、弱引用和虚引用" class="headerlink" title="Java中的强引用、软引用、弱引用和虚引用"></a>Java中的强引用、软引用、弱引用和虚引用</h1><p>Java执行GC判断对象是否存活有两种方式其中一种是引用计数。</p>
<blockquote>
<p>引用计数：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。</p>
</blockquote>
<p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。</p>
<p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。</p>
<blockquote>
<p>Java中4种引用的级别和强度由高到低依次为：强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</p>
</blockquote>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>被垃圾回收时间</th>
<th>用途</th>
<th>生存时间</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时终止</td>
<td>通过new或反射创建的引用对象</td>
</tr>
<tr>
<td>软引用</td>
<td>当内存不足时</td>
<td>对象缓存</td>
<td>内存不足时终止</td>
<td></td>
</tr>
<tr>
<td>弱引用</td>
<td>正常垃圾回收时</td>
<td>对象缓存</td>
<td>垃圾回收后终止</td>
<td></td>
</tr>
<tr>
<td>虚引用</td>
<td>正常垃圾回收时</td>
<td>跟踪对象的垃圾回收</td>
<td>垃圾回收后终止</td>
<td>DirectByteBuffer堆外内存释放</td>
</tr>
</tbody></table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="https://juejin.im/post/6844903665241686029">理解Java的强引用、软引用、弱引用和虚引用</a></p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中锁分类</title>
    <url>/2021/03/01/java/java-zhong-suo-fen-lei/</url>
    <content><![CDATA[<h1 id="一、Java中主流锁"><a href="#一、Java中主流锁" class="headerlink" title="一、Java中主流锁"></a>一、Java中主流锁</h1><p><img src="/2021/03/01/java/java-zhong-suo-fen-lei/Java%E4%B8%BB%E6%B5%81%E9%94%81.png" alt="Java主流锁"></p>
<blockquote>
<p>上图摘自：<a href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术团队：不可不说的Java“锁”事</a></p>
</blockquote>
<h2 id="1-1-乐观锁-VS-悲观锁"><a href="#1-1-乐观锁-VS-悲观锁" class="headerlink" title="1.1 乐观锁 VS 悲观锁"></a>1.1 乐观锁 VS 悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p>
<p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p>
<p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</li>
</ul>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>（1） ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。<br>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。<br>（2） 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。<br>（3）只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<br>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>
<h2 id="1-2-自旋锁-VS-适应性自旋锁"><a href="#1-2-自旋锁-VS-适应性自旋锁" class="headerlink" title="1.2 自旋锁 VS 适应性自旋锁"></a>1.2 自旋锁 VS 适应性自旋锁</h2><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。<br>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。<br>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<h2 id="1-3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#1-3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="1.3 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>1.3 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。<br>首先为什么Synchronized能实现线程同步？</p>
<p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>
<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>
<p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。<br>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>存储内容</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td>对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>10</td>
</tr>
</tbody></table>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>整体的锁状态升级流程如下：</p>
<blockquote>
<p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>偏向锁通过对比Mak Word解决加锁问题，避免进行CAS操作，而轻量级锁是通过CAS操作和自旋锁来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<h2 id="1-4-公平锁-VS-非公平锁"><a href="#1-4-公平锁-VS-非公平锁" class="headerlink" title="1.4 公平锁 VS 非公平锁"></a>1.4 公平锁 VS 非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<p>ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p>
<h2 id="1-5-可重入锁-VS-非可重入锁"><a href="#1-5-可重入锁-VS-非可重入锁" class="headerlink" title="1.5 可重入锁 VS 非可重入锁"></a>1.5 可重入锁 VS 非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
<p>之前我们说过ReentrantLock和synchronized都是重入锁。</p>
<h2 id="1-6-独占锁-VS-共享锁"><a href="#1-6-独占锁-VS-共享锁" class="headerlink" title="1.6 独占锁 VS 共享锁"></a>1.6 独占锁 VS 共享锁</h2><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。<br>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul>
<li>悲观锁访问临界资源预先加锁，如Java中的synchronized和Lock实现类都是悲观锁。</li>
<li>乐观锁访问临界资源不加锁，只有在更新数据的时候检查是否发生了冲突，如果发生冲突则进行重试。ReenterLock内部的AQS，还是各种Atomic开头的原子类，内部都应用到了CAS。</li>
<li>自旋锁通过让线程自旋避免让线程陷入阻塞，便面线程上下文切换带来的性能损耗。</li>
<li>适应性自旋锁通过收集获取锁的线程的自旋次数、自旋时长及锁状态动态判断线程获取锁的可能，最终决定线程进行自旋或阻塞。避免长时间自旋浪费处理器资源。</li>
<li>偏向锁通过对比Mak Word解决加锁问题，避免进行CAS操作，而轻量级锁是通过CAS操作和自旋锁来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</li>
<li>公平锁按照线程申请锁的顺序来获取锁。优点：线程不会饿死；缺点：整体的吞吐效率低。</li>
<li>非公平锁加锁时直接尝试获取锁。优点：系统吞吐量高；缺点：等待队列中的线程可能会饿死。</li>
<li>可重入锁指线程在外层方法获取锁后进入内层方法自动获得锁。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</li>
<li>非可重入锁在持有锁的情况下再次获取锁会导致线程阻塞从而造成死锁。</li>
<li>独占锁指锁只能被一个线程持有，如java中得写锁。</li>
<li>非独占锁则可以被多个线程持有，如java中的读锁。</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用日志框架</title>
    <url>/2018/07/26/java/java-chang-yong-ri-zhi-kuang-jia-jie-shao/</url>
    <content><![CDATA[<h3 id="Java常用日志框架介绍"><a href="#Java常用日志框架介绍" class="headerlink" title="Java常用日志框架介绍"></a>Java常用日志框架介绍</h3><ul>
<li><strong>Log4j</strong>  Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一。 </li>
<li><strong>Log4j2</strong> Apache Log4j 2是apache开发的一款Log4j的升级产品。 </li>
<li><strong>Commons Logging</strong>  Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。 </li>
<li><strong>Slf4j</strong> 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。 </li>
<li><strong>Logback</strong>  一套日志组件的实现(slf4j阵营)。 </li>
<li><strong>Jul</strong> (Java Util Logging),自Java1.4以来的官方日志实现。 </li>
</ul>
<h3 id="Java常用框架历史"><a href="#Java常用框架历史" class="headerlink" title="Java常用框架历史"></a>Java常用框架历史</h3><ul>
<li>1996年早期，欧洲安全电子市场项目组决定编写它自己的程序跟踪API(Tracing API)。经过不断的完善，这个API终于成为一个十分受欢迎的Java日志软件包，即Log4j。后来Log4j成为Apache基金会项目中的一员。 </li>
<li>期间Log4j近乎成了Java社区的日志标准。据说Apache基金会还曾经建议sun引入Log4j到java的标准库中，但Sun拒绝了。 </li>
<li>2002年Java1.4发布，Sun推出了自己的日志库JUL(Java Util Logging),其实现基本模仿了Log4j的实现。在JUL出来以前，log4j就已经成为一项成熟的技术，使得log4j在选择上占据了一定的优势。 </li>
<li>接着，Apache推出了Jakarta Commons Logging，JCL只是定义了一套日志接口(其内部也提供一个Simple Log的简单实现)，支持运行时动态加载日志组件的实现，也就是说，在你应用代码里，只需调用Commons Logging的接口，底层实现可以是log4j，也可以是Java Util Logging。 </li>
<li>后来(2006年)，Ceki Gülcü不适应Apache的工作方式，离开了Apache。然后先后创建了slf4j(日志门面接口，类似于Commons Logging)和Logback(Slf4j的实现)两个项目，并回瑞典创建了QOS公司，QOS官网上是这样描述Logback的：The Generic，Reliable Fast&amp;Flexible Logging Framework(一个通用，可靠，快速且灵活的日志框架)。 </li>
<li>现今，Java日志领域被划分为两大阵营：Commons Logging阵营和SLF4J阵营。 </li>
<li>Apache眼看有被Logback反超的势头，于2012-07重写了log4j 1.x，成立了新的项目Log4j 2。Log4j 2具有logback的所有特性。</li>
</ul>
<h3 id="java常用日志框架之间的关系"><a href="#java常用日志框架之间的关系" class="headerlink" title="java常用日志框架之间的关系"></a>java常用日志框架之间的关系</h3><ul>
<li>Log4j2与Log4j1发生了很大的变化，log4j2不兼容log4j1。 Log4j 2包含基于LMAX Disruptor库的下一代异步记录器。在多线程场景中，异步记录器的吞吐量比Log4j 1.x和Logback高18倍，延迟低。 Log4j 2明显优于Log4j 1.x，Logback和java.util.logging，尤其是在多线程应用程序中。 </li>
<li>Commons Logging和Slf4j是日志门面(门面模式是软件工程中常用的一种软件设计模式，也被称为正面模式、外观模式。它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用)。log4j和Logback则是具体的日志实现方案。可以简单的理解为接口与接口的实现，调用这只需要关注接口而无需关注具体的实现，做到解耦。 </li>
<li>比较常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。 </li>
<li>Logback必须配合Slf4j使用。由于Logback和Slf4j是同一个作者，其兼容性不言而喻。 </li>
</ul>
<h3 id="Commons-Logging与Slf4j实现机制对比"><a href="#Commons-Logging与Slf4j实现机制对比" class="headerlink" title="Commons Logging与Slf4j实现机制对比"></a>Commons Logging与Slf4j实现机制对比</h3><ul>
<li>Commons logging是通过动态查找机制，在程序运行时，使用自己的ClassLoader寻找和载入本地具体的实现。详细策略可以查看commons-logging-*.jar包中的org.apache.commons.logging.impl.LogFactoryImpl.java文件。由于OSGi不同的插件使用独立的ClassLoader，OSGI的这种机制保证了插件互相独立, 其机制限制了commons logging在OSGi中的正常使用。 </li>
<li>Slf4j在编译期间，静态绑定本地的LOG库，因此可以在OSGi中正常使用。它是通过查找类路径下org.slf4j.impl.StaticLoggerBinder，然后绑定工作都在这类里面进。 </li>
</ul>
<h3 id="如何在项目中选择日志框架"><a href="#如何在项目中选择日志框架" class="headerlink" title="如何在项目中选择日志框架"></a>如何在项目中选择日志框架</h3><p>如果是在一个新的项目中建议使用Slf4j与Logback组合，这样有如下的几个优点。 </p>
<ul>
<li><p>Slf4j实现机制决定Slf4j限制较少，使用范围更广。由于Slf4j在编译期间，静态绑定本地的LOG库使得通用性要比Commons logging要好。 </p>
</li>
<li><p>Logback拥有更好的性能。Logback声称：某些关键操作，比如判定是否记录一条日志语句的操作，其性能得到了显著的提高。这个操作在Logback中需要3纳秒，而在Log4J中则需要30纳秒。LogBack创建记录器（logger）的速度也更快：13毫秒，而在Log4J中需要23毫秒。更重要的是，它获取已存在的记录器只需94纳秒，而Log4J需要2234纳秒，时间减少到了1/23。跟JUL相比的性能提高也是显著的。 </p>
</li>
<li><p>Commons Logging开销更高 在使Commons Logging时为了减少构建日志信息的开销，通常的做法是：</p>
<p><code>if(log.isDebugEnabled())&#123; </code></p>
<p>​    <code>log.debug(&quot;User name： &quot; + user.getName() + &quot; buy goods id ：&quot; + good.getId());</code> </p>
<p><code>&#125;</code> </p>
<p>在Slf4j阵营，你只需这么做：</p>
<p> <code>log.debug(&quot;User name：&#123;&#125; ,buy goods id ：&#123;&#125;&quot;, user.getName(),good.getId());</code> </p>
<p>也就是说，slf4j把构建日志的开销放在了它确认需要显示这条日志之后，减少内存和cup的开销，使用占位符号，代码也更为简洁 。</p>
</li>
<li><p>Logback文档免费。Logback的所有文档是全面免费提供的，不象Log4J那样只提供部分免费文档而需要用户去购买付费文档。 </p>
</li>
</ul>
<h3 id="如何在项目中使用self4j"><a href="#如何在项目中使用self4j" class="headerlink" title="如何在项目中使用self4j"></a>如何在项目中使用self4j</h3><p><strong>直接使用slf4j来输入日志的方式</strong></p>
<p><img src="/2018/07/26/java/java-chang-yong-ri-zhi-kuang-jia-jie-shao/concrete-bindings.png" alt="concrete-bindings"></p>
<p>这里引用了slf4j官网的图，<a href="https://www.slf4j.org/manual.html">去官网查阅可以点击这里</a></p>
<p>简单说一下对上图的理解：</p>
<ul>
<li>图中第一层绿色的模块application代表你的应用程序</li>
<li>图中第二层浅蓝色的模块，代表是抽象的日志接口层，这里用的是<em>slf4j</em></li>
<li>图中第三层分为两种：<ul>
<li>一种是深蓝色的，表示的是第二层中<em>slf4j</em>日志接口的直接实现,直接实现了<em>slf4j</em>的日志框架有logback、slf4j-simple（slf4j的简单实现）、 slf4j-nop（丢弃日志不打印）</li>
<li>另外一中湖蓝色的，表示是没有直接实现<em>slf4j</em>的API，而是通过适配器调用其它具体日志框架的API，这里包括<em>slf4j</em>到log4j的适配和<em>slf4j</em>到Jul的适配。</li>
</ul>
</li>
<li>第四层灰色的模块表示具体的日志框架，他们没有直接实现<em>slf4j</em>的API，但是可以通过上层的适配器与<em>slf4j</em>做适配实现日志管理。</li>
</ul>
<p><strong>如果你的应用包含其他模块，但这些模块没有使用slf4j，而是使用了其他日志框架，不要担心，<em>slf4j</em>提供了一些包可以将系统中其他日志转到slf4j做一个统一输出，具体可以参考<em>slf4j</em>官网的这幅图</strong></p>
<p><img src="/2018/07/26/java/java-chang-yong-ri-zhi-kuang-jia-jie-shao/legacy.png" alt="legacy"></p>
<p><a href="https://www.slf4j.org/legacy.html">去官网查阅可以点击这里</a></p>
<p>上图中从左到右再到下分别为图一、图二、图三</p>
<ul>
<li><p>图一表示使用<em>slf4j</em>作为统一日志输出，将程序中原有的Commons Longing、Log4j、Jul日志适配到slf4j</p>
<table>
<thead>
<tr>
<th>jar包名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>log4j-over-slf4j-version.jar</strong></td>
<td>将log4j适配到slf4j</td>
</tr>
<tr>
<td><strong>jcl-over-slf4j-version.jar</strong></td>
<td>将commos logging适配到slf4j</td>
</tr>
<tr>
<td><strong>jul-to-slf4j-version.jar</strong></td>
<td>将Java Util Logging适配到slf4j</td>
</tr>
</tbody></table>
<p>可以通过上面的包将原来的日志适配到<em>slf4j</em>作为统一日志输出，使用logback作为具体日志实现。</p>
</li>
<li><p>图二、三原理类似，只是更换了slf4j的日志实现方式。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<p>如果有其它日志重定向到了<em>slf4j</em>，就不能将该日志再作为<em>slf4j</em>的具体实现了，否则会形成闭环（<em>该日志将输出重定向到slf4j，slf4j又将日志输出到该日志</em>），所以将其它日志重定向到slf4j的方式只有如上三种搭配组合方式。</p>
<hr>
<p><strong>上面介绍使用slf4j作为统一日志输出，将其它日志适配到slf4j，以及slf4j绑定具体日志实现，这些适配功能的jar包和适配器相关的jar包都是由slf4j提供的，Apache作为log4j的维护方，也提供了一些桥接器，更好的支持log4j 2</strong></p>
<table>
<thead>
<tr>
<th>jar包</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>log4j-1.2-api</td>
<td>将log4j 2作为log4j 1.x 的具体实现（<em>两者不兼容</em>）</td>
</tr>
<tr>
<td>log4j-jcl</td>
<td>将log4j 2作为jcl 的具体实现</td>
</tr>
<tr>
<td>log4j-slf4j-impl</td>
<td>将log4j 2作为slf4j的具体实现</td>
</tr>
</tbody></table>
<p><a href="https://logging.apache.org/log4j/2.x/maven-artifacts.html">去log4j 2官网查看点击这里</a></p>
<p><strong>参考链接</strong></p>
<p><a href="https://www.cnblogs.com/chenhongliang/p/5312517.html">Java常用日志框架介绍</a></p>
<p><a href="https://www.slf4j.org/">slf4j官网</a></p>
<p><a href="https://logging.apache.org/log4j/2.x/">log4j 2官网</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/2018/07/30/java/java-lei-jia-zai-ji-zhi/</url>
    <content><![CDATA[<h3 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h3><p>　　 类从被加载到虚拟机内存中开始，直到卸载出内存为止，它的整个生命周期包括了： <strong>加载、验证、准备、解析、初始化、使用和卸载</strong> 这7个阶段。其中， <strong>验证、准备和解析这三个部分统称为连接（linking）</strong> 。</p>
<p><img src="/2018/07/30/java/java-lei-jia-zai-ji-zhi/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p>
<p>  其中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的“开始”（仅仅指的是开始，而非执行或者结束，因为这些阶段通常都是互相交叉的混合进行，通常会在一个阶段执行的过程中调用或者激活另一个阶段），而解析阶段则不一定（它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定)。 </p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>“加载”(Loading)阶段是“类加载”(Class Loading)过程的第一个阶段，在此阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>1、 通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>2、 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>3、 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</li>
</ul>
<p>​      加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器来完成。加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。</p>
<hr>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p> 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>​       Java语言本身是相对安全的语言，使用Java编码是无法做到如访问数组边界以外的数据、将一个对象转型为它并未实现的类型等，如果这样做了，编译器将拒绝编译。但是，Class文件并不一定是由Java源码编译而来，可以使用任何途径，包括用十六进制编辑器(如UltraEdit)直接编写。如果直接编写了有害的“代码”(字节流)，而虚拟机在加载该Class时不进行检查的话，就有可能危害到虚拟机或程序的安全。</p>
<p>​      不同的虚拟机，对类验证的实现可能有所不同，但大致都会完成下面四个阶段的验证 ：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<ul>
<li>1、文件格式验证，是要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。如验证魔数是否0xCAFEBABE；主、次版本号是否正在当前虚拟机处理范围之内；常量池的常量中是否有不被支持的常量类型……该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区中，经过这个阶段的验证后，字节流才会进入内存的方法区中存储，所以后面的三个验证阶段都是基于方法区的存储结构进行的。</li>
<li>2、元数据验证，是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。可能包括的验证如：这个类是否有父类；这个类的父类是否继承了不允许被继承的类；如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法……</li>
<li>3、字节码验证，主要工作是进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。</li>
<li>4、符号引用验证，发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在“解析阶段”中发生。验证符号引用中通过字符串描述的权限定名是否能找到对应的类；在指定类中是否存在符合方法字段的描述符及简单名称所描述的方法和字段；符号引用中的类、字段和方法的访问性(private、protected、public、default)是否可被当前类访问</li>
</ul>
<p>验证阶段对于虚拟机的类加载机制来说，不一定是必要的阶段。如果所运行的全部代码确认是安全的， 可以使用 <strong>-Xverify：none</strong> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间。</p>
<hr>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p> 准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>​        <code>public static int value=123;</code>//在准备阶段value初始值为0 。在初始化阶段才会变为123 。</p>
<hr>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>​       符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p>
<p>​       直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。</p>
<hr>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>　　类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p>
<p>​        初始化阶段是执行类构造器<clinit>()方法的过程。<clinit>()方法是由编译器自动 收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的 。</clinit></clinit></p>
<p>什么情况下需要开始类加载过程的第一个阶段:<em><strong>加载</strong></em>。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于<em><strong>初始化阶段</strong></em>虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。 </p>
<ul>
<li>创建类的实例</li>
<li>访问类的静态变量 (除常量【 被final修辞的静态变量】 原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。</li>
<li>访问类的静态方法</li>
<li>反射 如( <strong>Class.forName(“my.xyz.Test”)</strong> )</li>
<li>当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化</li>
<li>虚拟机启动时，定义了main()方法的那个类先初始化</li>
</ul>
<p>　　以上情况称为称对一个类进行 <strong>“主动引用”</strong> ，除此种情况之外，均不会触发类的初始化，称为<strong>“被动引用”</strong> </p>
<p><em><strong>注意：</strong></em>虚拟机在首次加载Java类时，会对静态初始化块、静态成员变量、静态方法进行一次初始化 ，但非静态方法不被调用是不会执行的。 </p>
<p><em><strong>类初始化顺序：</strong></em> <em>父类静态变量 　-&gt; 　父类静态代码块　-&gt;　子类静态变量　-&gt;　子类静态代码块　-&gt;　父类非静态变量　-&gt;　父类非静态代码块　-&gt;　父类构造方法　-&gt;　子类非静态变量　-&gt;　子类非静态代码块　-&gt;　子类构造方法</em></p>
<p><em><strong>案例：</strong></em></p>
<pre class="line-numbers language-none"><code class="language-none">class SingleTon &#123;
	private static SingleTon singleTon &#x3D; new SingleTon();
	public static int count1;
	public static int count2 &#x3D; 0;

	private SingleTon() &#123;
		count1++;
		count2++;
	&#125;

	public static SingleTon getInstance() &#123;
		return singleTon;
	&#125;
&#125;

public class Test &#123;
	public static void main(String[] args) &#123;
		SingleTon singleTon &#x3D; SingleTon.getInstance();
		System.out.println(&quot;count1&#x3D;&quot; + singleTon.count1);
		System.out.println(&quot;count2&#x3D;&quot; + singleTon.count2);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果：1， 0</p>
<hr>
<h3 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h3><p>　　类加载器是一个用来加载类文件的类。Java源代码通过javac编译器编译成类文件。然后JVM来执行类文件中的字节码来执行程序。类加载器负责加载文件系统、网络或其他来源的类文件。有三种默认使用的类加载器：Bootstrap类加载器、Extension类加载器和System类加载器（或者叫作Application类加载器）。每种类加载器都有设定好从哪里加载类。 </p>
<ul>
<li>**启动类加载器(Bootstrap ClassLoader) **</li>
</ul>
<p>　　负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类, 它是所有类加载器的父加载器。Bootstrap类加载器没有任何父类加载器，如果你调用String.class.getClassLoader()，会返回null，任何基于此的代码会抛出NUllPointerException异常。Bootstrap加载器被称为初始类加载器。 </p>
<ul>
<li><strong>扩展类加载器(Extension ClassLoader)</strong></li>
</ul>
<p>　　负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库,  扩展类加载器（Extension ClassLoader）将加载类的请求委托给他的父加载器（<em>这里的父加载器并非继承关系，而是通过组合关系达到复用父类加载器的代码</em>），也就是Bootstrap类加载器，如果父加载器没有加载成功，则在 JAVA_HOME\lib\ext 目录下加载。Extension加载器由sun.misc.Launcher$ExtClassLoader实现。</p>
<ul>
<li>**应用程序类加载器(Application ClassLoader) **</li>
</ul>
<p>　　它负责从classpath环境变量中加载某些应用相关的类，classpath环境变量通常由-classpath或-cp命令行选项来定义，或者是JAR中的Manifest的classpath属性。Application类加载器是Extension类加载器的子加载器。通过sun.misc.Launcher$AppClassLoader实现。</p>
<p>除了Bootstrap类加载器是大部分由C来写的，其他的类加载器都是通过java.lang.ClassLoader来实现的。 JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p>
<hr>
<h3 id="三、类加载器的工作原理"><a href="#三、类加载器的工作原理" class="headerlink" title="三、类加载器的工作原理"></a>三、类加载器的工作原理</h3><p>类加载器的工作原理基于三个机制：委托、可见性和单一性。 </p>
<ul>
<li><p><strong>委托机制</strong></p>
<p>　　当一个类加载和初始化的时候，类仅在有需要加载的时候被加载。假设你有一个应用需要的类叫作Abc.class，首先加载这个类的请求由Application类加载器委托给它的父类加载器Extension类加载器，然后再委托给Bootstrap类加载器。Bootstrap类加载器会先看看rt.jar中有没有这个类，因为并没有这个类，所以这个请求由回到Extension类加载器，它会查看jre/lib/ext目录下有没有这个类，如果这个类被Extension类加载器找到了，那么它将被加载，而Application类加载器不会加载这个类；而如果这个类没有被Extension类加载器找到，那么再由Application类加载器从classpath中寻找。记住classpath定义的是类文件的加载目录，而PATH是定义的是可执行程序如javac，java等的执行路径。</p>
<p>　　采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。 </p>
<p>　　双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码 。</p>
</li>
<li><p><strong>可见性机制</strong></p>
</li>
</ul>
<p>　　根据可见性机制，子类加载器可以看到父类加载器加载的类，而反之则不行。所以下面的例子中，当Abc.class已经被Application类加载器加载过了，然后如果想要使用Extension类加载器加载这个类，将会抛出java.lang.ClassNotFoundException异常。 </p>
<pre class="line-numbers language-none"><code class="language-none">package test;
import java.util.logging.Level;
import java.util.logging.Logger;
 
&#x2F;**
 * Java program to demonstrate How ClassLoader works in Java,
 * in particular about visibility principle of ClassLoader.
 *
 * @author Javin Paul
 *&#x2F;
 
public class ClassLoaderTest &#123;
 
    public static void main(String args[]) &#123;
        try &#123;          
            &#x2F;&#x2F;printing ClassLoader of this class
            System.out.println(&quot;ClassLoaderTest.getClass().getClassLoader() : &quot;
                                 + ClassLoaderTest.class.getClassLoader());
 
            &#x2F;&#x2F;trying to explicitly load this class again using Extension class loader
            Class.forName(&quot;test.ClassLoaderTest&quot;, true
                            ,  ClassLoaderTest.class.getClassLoader().getParent());
        &#125; catch (ClassNotFoundException ex) &#123;
            Logger.getLogger(ClassLoaderTest.class.getName()).log(Level.SEVERE, null, ex);
        &#125;
    &#125;
 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-none"><code class="language-none">ClassLoaderTest.getClass().getClassLoader() : sun.misc.Launcher$AppClassLoader@601bb1
16&#x2F;08&#x2F;2012 2:43:48 AM test.ClassLoaderTest main
SEVERE: null
java.lang.ClassNotFoundException: test.ClassLoaderTest
        at java.net.URLClassLoader$1.run(URLClassLoader.java:202)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
        at sun.misc.Launcher$ExtClassLoader.findClass(Launcher.java:229)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:247)
        at test.ClassLoaderTest.main(ClassLoaderTest.java:29)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><strong>单一性机制</strong></p>
<p>　　根据这个机制，父加载器加载过的类不能被子加载器加载第二次。虽然重写违反委托和单一性机制的类加载器是可能的，但这样做并不可取。你写自己的类加载器的时候应该严格遵守这三条机制。 </p>
</li>
</ul>
<hr>
<h3 id="四、显示的加载类"><a href="#四、显示的加载类" class="headerlink" title="四、显示的加载类"></a>四、显示的加载类</h3><p>　　Java提供了显式加载类的API：<code>Class.forName(classname)</code>和<code>Class.forName(classname, initialized, classloader)</code>。就像上面的例子中，你可以指定类加载器的名称以及要加载的类的名称。类的加载是通过调用java.lang.ClassLoader的loadClass()方法，而loadClass()方法则调用了findClass()方法来定位相应类的字节码。在这个例子中Extension类加载器使用了java.net.URLClassLoader，它从JAR和目录中进行查找类文件，所有以”/”结尾的查找路径被认为是目录。如果findClass()没有找到那么它会抛出java.lang.ClassNotFoundException异常，而如果找到的话则会调用defineClass()将字节码转化成类实例，然后返回。 </p>
<hr>
<p><em><strong>参考文章</strong></em></p>
<p><a href="https://www.tuicool.com/articles/QZnENv">从一道面试题来认识java类加载时机与过程</a></p>
<p><a href="http://www.importnew.com/25295.html">JVM 类加载机制详解</a></p>
<p><a href="http://www.importnew.com/6581.html">类加载器的工作原理</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2018/07/30/java/java-ji-he/</url>
    <content><![CDATA[<p>​    早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。</p>
<p>虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。</p>
<p>集合框架被设计成要满足以下几个目标。</p>
<ul>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。</li>
</ul>
<p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： <strong>LinkedList</strong>, <strong>HashSet</strong>, 和 <strong>TreeSet</strong> 等,除此之外你也可以通过这些接口实现自己的集合。</p>
<p><img src="/2018/07/30/java/java-ji-he/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Java集合框架图"></p>
<p>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。 </p>
<ul>
<li><p><strong>Collection接口</strong></p>
<p>​    Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的<em>元素</em>。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何<em>直接</em> 实现：它提供更具体的子接口（如 <code>Set</code> 和 <code>List</code>）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 </p>
</li>
</ul>
<p><em><strong>方法摘要</strong></em></p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code> boolean</code></td>
<td><strong><code>add(E e)</code></strong><br>            确保此 collection 包含指定的元素（可选操作）。</td>
</tr>
<tr>
<td><code> boolean</code></td>
<td><strong><code>addAll(Collection&lt;? extends E&gt; c)</code></strong><br>            将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。</td>
</tr>
<tr>
<td><code> void</code></td>
<td><strong><code>clear()</code></strong><br>          移除此 collection 中的所有元素（可选操作）。</td>
</tr>
<tr>
<td><code> boolean</code></td>
<td><strong><code>contains(Object o)</code></strong><br>            如果此 collection 包含指定的元素，则返回 <code>true</code>。</td>
</tr>
<tr>
<td><code> boolean</code></td>
<td><strong><code>containsAll(Collection&lt;?&gt; c)</code></strong><br>            如果此 collection 包含指定 collection 中的所有元素，则返回 <code>true</code>。</td>
</tr>
<tr>
<td><code> boolean</code></td>
<td><strong><code>equals(Object o)</code></strong><br>            比较此 collection 与指定对象是否相等。</td>
</tr>
<tr>
<td><code> int</code></td>
<td><strong><code>hashCode()</code></strong><br>            返回此 collection 的哈希码值。</td>
</tr>
<tr>
<td><code> boolean</code></td>
<td><strong><code>isEmpty()</code></strong><br>            如果此 collection 不包含元素，则返回 <code>true</code>。</td>
</tr>
<tr>
<td><code> Iterator&lt;E&gt;</code></td>
<td><strong><code>iterator()</code></strong><br>            返回在此 collection 的元素上进行迭代的迭代器。</td>
</tr>
<tr>
<td><code> boolean</code></td>
<td><strong><code>remove(Object o)</code></strong><br>            从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。</td>
</tr>
<tr>
<td><code> boolean</code></td>
<td><strong><code>removeAll(Collection&lt;?&gt; c)</code></strong><br>            移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。</td>
</tr>
<tr>
<td><code> boolean</code></td>
<td><strong><code>retainAll(Collection&lt;?&gt; c)</code></strong><br>           仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。</td>
</tr>
<tr>
<td><code> int</code></td>
<td><strong><code>size()</code></strong><br>            返回此 collection 中的元素数。</td>
</tr>
<tr>
<td><code> Object[]</code></td>
<td><strong><code>toArray()</code></strong><br>            返回包含此 collection 中所有元素的数组。</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><strong><code>toArray(T[] a)</code></strong><br>            返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>List接口</strong></p>
<p>​    List接口通常表示一个列表（数组、队列、链表、栈等），是一个有序的 collection（也称为<em>序列</em>）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 </p>
<p>​    与 set 不同，列表通常允许重复的元素。更确切地讲，列表通常允许满足 <code>e1.equals(e2)</code> 的元素对 <code>e1</code> 和 <code>e2</code>，并且如果列表本身允许 null 元素的话，通常它们允许多个 null 元素。难免有人希望通过在用户尝试插入重复元素时抛出运行时异常的方法来禁止重复的列表，但我们希望这种用法越少越好。 </p>
<p>​     <code>List</code> 接口提供了特殊的迭代器，称为 <code>ListIterator</code>，除了允许 <code>Iterator</code> 接口提供的正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法来获取从列表中指定位置开始的列表迭代器。 </p>
</li>
<li><p><strong>Set接口</strong></p>
<p>​    一个不包含重复元素的 collection。更确切地讲，set 不包含满足 <code>e1.equals(e2)</code> 的元素对 <code>e1</code> 和 <code>e2</code>，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 <em>set</em> 抽象。 </p>
<p>​    </p>
</li>
<li><p><strong>Map接口</strong></p>
<p>​    Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。 </p>
</li>
<li><p><strong>Iterator接口</strong></p>
<p>​    Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），除了Map系列的集合，Collection集合都实现了 Iterator 接口，这是一个用于遍历集合中元素的接口，主要有hashNext()、next()、remove()三种方法。它的一个子接口ListIterator在它的基础上又添加了三种方法，分别是 add()、previous()、hasPrevious()方法。也就是说如果实现Iterator接口，那么在遍历集合中元素的时候，只能往后遍历，被遍历后的元素不会再被遍历到，通常无序集合实现的都是这个接口，比如HashSet；而那些元素有序的集合，实现的一般都是ListIterator接口，实现这个接口的集合可以双向遍历，既可以通过next()访问下一个元素，又可以通过previous()访问前一个 元素，比如ArrayList。</p>
<p>​    Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。 </p>
</li>
<li><p>**Arrays和Collections **</p>
<p>​    Arrays和Collections是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选Concurrent并发包下的对应的集合类。     </p>
</li>
</ul>
<h2 id="Java集合实现类"><a href="#Java集合实现类" class="headerlink" title="Java集合实现类"></a>Java集合实现类</h2><p>​    Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。 </p>
<ul>
<li><strong>ArrayList</strong></li>
<li><strong>LinkedList</strong></li>
<li><strong>Vector</strong></li>
<li><strong>Stack</strong></li>
<li><strong>HashSet</strong></li>
<li><strong>TreeSet</strong></li>
<li><strong>LinkedHashSet</strong></li>
<li><strong>ArrayBlockingQueue</strong></li>
<li><strong>LinkedBlockingQueue</strong></li>
<li><strong>DelayQueue</strong></li>
<li><strong>HashMap</strong></li>
<li><strong>TreeMap</strong></li>
<li><strong>Hashtable</strong></li>
<li><strong>LinkedHashMap</strong></li>
<li><strong>WeakHashMap</strong></li>
<li><strong>IdentityHashMap</strong></li>
</ul>
<hr>
<p>接下来介绍的几个类不是结合实现类，但对集合操作比较重要</p>
<ul>
<li><strong>Arrays</strong></li>
<li><strong>Collections</strong></li>
</ul>
<p><em><strong>参考文章</strong></em></p>
<p><a href="https://blog.csdn.net/ns_code/article/details/35564663">Java集合框架</a></p>
<p><a href="http://www.runoob.com/java/java-collections.html">Java集合框架</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap源码分析</title>
    <url>/2021/03/06/java/linkedhashmap-yuan-ma-fen-xi/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>LinkedHashMap继承了HashMap，并通过双向列表来维护元素的顺序，本文结合HashMap的源码探究一下LinkedHashMap是如何维护元素的顺序的。</p>
<h2 id="1-1-构造方法"><a href="#1-1-构造方法" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    
    <span class="token comment">/**
     * The iteration ordering method for this linked hash map: &lt;tt>true&lt;/tt>
     * for access-order, &lt;tt>false&lt;/tt> for insertion-order.
     *
     * @serial
     */</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>
    
    <span class="token comment">/**
     * Constructs an empty insertion-ordered &lt;tt>LinkedHashMap&lt;/tt> instance
     * with the specified initial capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * Constructs an empty insertion-ordered &lt;tt>LinkedHashMap&lt;/tt> instance
     * with the specified initial capacity and a default load factor (0.75).
     *
     * @param  initialCapacity the initial capacity
     * @throws IllegalArgumentException if the initial capacity is negative
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * Constructs an empty insertion-ordered &lt;tt>LinkedHashMap&lt;/tt> instance
     * with the default initial capacity (16) and load factor (0.75).
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * Constructs an insertion-ordered &lt;tt>LinkedHashMap&lt;/tt> instance with
     * the same mappings as the specified map.  The &lt;tt>LinkedHashMap&lt;/tt>
     * instance is created with a default load factor (0.75) and an initial
     * capacity sufficient to hold the mappings in the specified map.
     *
     * @param  m the map whose mappings are to be placed in this map
     * @throws NullPointerException if the specified map is null
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * Constructs an empty &lt;tt>LinkedHashMap&lt;/tt> instance with the
     * specified initial capacity, load factor and ordering mode.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @param  accessOrder     the ordering mode - &lt;tt>true&lt;/tt> for
     *         access-order, &lt;tt>false&lt;/tt> for insertion-order
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>
                         <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span>
                         <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>LinkedHashMap的构造方法和HashMap相比多了一个accessOrder参数，LinkedHashMap基于双向列表来记录元素的顺序。元素的排序方式根据accessOrder参数来进行控制：</p>
<ul>
<li>accessOrder = false ：根据元素的插入顺序排序</li>
<li>accessOrder = true ： 根据元素的访问顺序排序</li>
</ul>
<h2 id="1-2-主要属性"><a href="#1-2-主要属性" class="headerlink" title="1.2 主要属性"></a>1.2 主要属性</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * HashMap.Node subclass for normal LinkedHashMap entries.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>
    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">3801124242820219131L</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * The head (eldest) of the doubly linked list.
 */</span>
<span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> head<span class="token punctuation">;</span>

<span class="token comment">/**
 * The tail (youngest) of the doubly linked list.
 */</span>
<span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> tail<span class="token punctuation">;</span>

<span class="token comment">/**
 * The iteration ordering method for this linked hash map: &lt;tt>true&lt;/tt>
 * for access-order, &lt;tt>false&lt;/tt> for insertion-order.
 *
 * @serial
 */</span>
<span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>LinkedHashMap的静态内部类<code>Entry&lt;K,V&gt;</code>继承了HashMap的<code>HashMap.Node&lt;K,V&gt;</code>,<code>Entry</code>内部新增了before和after两个属性，实现了双向列表。</li>
<li><code>head</code>和<code>tail</code>两个字段用于记录队列的头节点和尾节点。</li>
<li><code>accessOrder</code>控制列表的顺序是根据插入顺序排序还是根据访问顺序进行排序。<h2 id="1-3-主要方法"><a href="#1-3-主要方法" class="headerlink" title="1.3 主要方法"></a>1.3 主要方法</h2>LinkedHashMap并没有重写父类HashMap的put方法，而是重写了HashMap中空的钩子方法，HashMap源码如下：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Callbacks to allow LinkedHashMap post-actions</span>
<span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
这些钩子方法在HashMap的<code>put</code>等方法中进行了调用，如：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// existing mapping for key</span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="afterNodeInsertion-boolean-evict-方法"><a href="#afterNodeInsertion-boolean-evict-方法" class="headerlink" title="afterNodeInsertion(boolean evict)方法"></a>afterNodeInsertion(boolean evict)方法</h3>这个方法的主要作用就是在元素添加到Map中后，判断是否要移除最老的元素，默认返回false。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// possibly remove eldest</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> first<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">K</span> key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
我们来看一下removeEldestEntry(first)方法的实现：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Returns &lt;tt>true&lt;/tt> if this map should remove its eldest entry.
 * This method is invoked by &lt;tt>put&lt;/tt> and &lt;tt>putAll&lt;/tt> after
 * inserting a new entry into the map.  It provides the implementor
 * with the opportunity to remove the eldest entry each time a new one
 * is added.  This is useful if the map represents a cache: it allows
 * the map to reduce memory consumption by deleting stale entries.
 *
 * &lt;p>Sample use: this override will allow the map to grow up to 100
 * entries and then delete the eldest entry each time a new entry is
 * added, maintaining a steady state of 100 entries.
 * &lt;pre>
 *     private static final int MAX_ENTRIES = 100;
 *
 *     protected boolean removeEldestEntry(Map.Entry eldest) &#123;
 *        return size() > MAX_ENTRIES;
 *     &#125;
 * &lt;/pre>
 *
 * &lt;p>This method typically does not modify the map in any way,
 * instead allowing the map to modify itself as directed by its
 * return value.  It &lt;i>is&lt;/i> permitted for this method to modify
 * the map directly, but if it does so, it &lt;i>must&lt;/i> return
 * &lt;tt>false&lt;/tt> (indicating that the map should not attempt any
 * further modification).  The effects of returning &lt;tt>true&lt;/tt>
 * after modifying the map from within this method are unspecified.
 *
 * &lt;p>This implementation merely returns &lt;tt>false&lt;/tt> (so that this
 * map acts like a normal map - the eldest element is never removed).
 *
 * @param    eldest The least recently inserted entry in the map, or if
 *           this is an access-ordered map, the least recently accessed
 *           entry.  This is the entry that will be removed it this
 *           method returns &lt;tt>true&lt;/tt>.  If the map was empty prior
 *           to the &lt;tt>put&lt;/tt> or &lt;tt>putAll&lt;/tt> invocation resulting
 *           in this invocation, this will be the entry that was just
 *           inserted; in other words, if the map contains a single
 *           entry, the eldest entry is also the newest.
 * @return   &lt;tt>true&lt;/tt> if the eldest entry should be removed
 *           from the map; &lt;tt>false&lt;/tt> if it should be retained.
 */</span>
<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
当我们将LinkedHashMap用作LRU缓存，我们需要限制缓存的大小，这时我们需要重写LinkedHashMap的removeEldestEntry方法，当元素个数超过设置的最大值后，则移除最老的元素，代码如下：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ENTRIES <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> eldest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> MAX_ENTRIES<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="afterNodeAccess-Node-lt-K-V-gt-e-方法"><a href="#afterNodeAccess-Node-lt-K-V-gt-e-方法" class="headerlink" title="afterNodeAccess(Node&lt;K,V&gt; e)方法"></a>afterNodeAccess(Node&lt;K,V&gt; e)方法</h3><p>首先来看一下afterNodeAccess方法被调用的时机：</p>
<ul>
<li>LinkedHashMap中调用<code>public V get(Object key)</code>方法时，且accessOrder=true</li>
<li>LinkedHashMap中调用<code>public V getOrDefault(Object key, V defaultValue)</code>方法时，且accessOrder=true</li>
<li>HashMap中调用<code>put</code>方法添加一个Key已经存在的元素</li>
<li>HashMap中调用<code>public boolean replace(K key, V oldValue, V newValue)</code>方法时</li>
<li>HashMap中调用<code>public V replace(K key, V value)</code>方法时</li>
<li>HashMap中调用<code>public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</code>方法时，对应Key的值存且在不为null</li>
<li>HashMap中调用<code>public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>方法时</li>
<li>HashMap中调用<code>public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) </code>方法时</li>
<li>HashMap中调用<code>public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</code>方法时</li>
</ul>
<p>该方法的主要作用是在accessOrder=true的情况下，将e节点转移至双向队列末尾。  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// move node to last</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> last<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span>
            <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            last <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="afterNodeRemoval-Node-lt-K-V-gt-e-方法"><a href="#afterNodeRemoval-Node-lt-K-V-gt-e-方法" class="headerlink" title="afterNodeRemoval(Node&lt;K,V&gt; e)方法"></a>afterNodeRemoval(Node&lt;K,V&gt; e)方法</h3><p>该方法的作用是在元素被移除后将列表中的元素也进行移除。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// unlink</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span>
        <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
    p<span class="token punctuation">.</span>before <span class="token operator">=</span> p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        head <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        tail <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LinkedHashMap继承了HashMap，通过<code>Entry</code>对象构建了一个双向队列，并通过重写HashMap中预留的空的钩子方法维护元素的顺序。当accessOrder=false，默认根据元素的插入顺序排序；accessOrder=true，根据元素的访问顺序进行排序。<br>根据LinkedHashMap的特点，能够很方便的实现一个LRU缓存算法，如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMapLRUCache</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> CACHE_MAX_COUNT<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMapLRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        CACHE_MAX_COUNT <span class="token operator">=</span> initialCapacity<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> eldest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> CACHE_MAX_COUNT<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>LinkedHashMap</tag>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈“伪共享”问题</title>
    <url>/2022/01/20/java/qian-tan-wei-gong-xiang-wen-ti/</url>
    <content><![CDATA[<blockquote>
<p>非原创，转载于：<a href="https://www.liuyj.top/false_sharing.html">https://www.liuyj.top/false_sharing.html</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习的过程中遇到了一个名词——伪共享，出于对知识的兴趣，上网查阅了一些博文，研究了伪共享的问题，写此文章总结记录。</p>
<p>要很好的理解伪共享问题，我们要先从CPU的缓存开始说起。</p>
<h2 id="CPU缓存架构"><a href="#CPU缓存架构" class="headerlink" title="CPU缓存架构"></a>CPU缓存架构</h2><p>CPU 是计算机的心脏，所有运算和程序最终都要由它来执行。</p>
<p>主内存（RAM）是数据存放的地方，CPU 和主内存之间有好几级缓存，因为即使直接访问主内存也是非常慢的。</p>
<p><img src="/2022/01/20/java/qian-tan-wei-gong-xiang-wen-ti/%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.png" alt="缓存架构"></p>
<p>如果对一块数据做相同的运算多次，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了，比如一个循环计数，你不想每次循环都跑到主内存去取这个数据来增长它吧。</p>
<p>再对缓存的概念做一些说明：</p>
<blockquote>
<p>越靠近 CPU 的缓存越快也越小。<br>所以 L1 缓存很小但很快，并且紧靠着在使用它的 CPU 内核。<br>L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。<br>L3 在现代多核机器中更普遍，仍然更大，更慢，并且被<code>单个插槽上的所有 CPU 核共享</code>。<br>最后，主存保存着程序运行的所有数据，它更大，更慢，由<code>全部插槽上的所有 CPU 核共享</code>。</p>
</blockquote>
<p>当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。</p>
<p>走得越远，运算耗费的时间就越长。</p>
<p>所以如果进行一些很频繁的运算，要确保数据在 L1 缓存中。</p>
<h2 id="CPU缓存行"><a href="#CPU缓存行" class="headerlink" title="CPU缓存行"></a>CPU缓存行</h2><p>缓存是由缓存行组成的，通常是 64 字节（常用处理器的缓存行是 64 字节的，比较旧的处理器缓存行是 32 字节），并且它有效地引用主内存中的一块地址。</p>
<p>一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。</p>
<p><img src="/2022/01/20/java/qian-tan-wei-gong-xiang-wen-ti/cpu%E7%BC%93%E5%AD%98%E8%A1%8C.png" alt="cpu缓存行"></p>
<p>在程序运行的过程中，缓存每次更新都从主内存中加载连续的 64 个字节。因此，如果访问一个 long 类型的数组时，当数组中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中。</p>
<p>但是，如果使用的数据结构中的项在内存中不是彼此相邻的，比如链表，那么将得不到免费缓存加载带来的好处。</p>
<p>不过，这种免费加载也有一个坏处。设想如果我们有个 long 类型的变量 a，它不是数组的一部分，而是一个单独的变量，并且还有另外一个 long 类型的变量 b 紧挨着它，那么当加载 a 的时候将免费加载 b。</p>
<p>看起来似乎没有什么毛病，但是如果一个 CPU 核心的线程在对 a 进行修改，另一个 CPU 核心的线程却在对 b 进行读取。</p>
<p>当前者修改 a 时，会把 a 和 b 同时加载到前者核心的缓存行中，更新完 a 后其它所有包含 a 的缓存行都将失效，因为其它缓存中的 a 不是最新值了。</p>
<p>而当后者读取 b 时，发现这个缓存行已经失效了，需要从主内存中重新加载。</p>
<p>请记住，我们的缓存都是以缓存行作为一个单位来处理的，所以失效 a 的缓存的同时，也会把 b 失效，反之亦然。</p>
<p><img src="/2022/01/20/java/qian-tan-wei-gong-xiang-wen-ti/cpu%E7%BC%93%E5%AD%98%E8%A1%8C-1.png" alt="cpu缓存行-1"></p>
<p>这样就出现了一个问题，b 和 a 完全不相干，每次却要因为 a 的更新需要从主内存重新读取，它被缓存未命中给拖慢了。</p>
<p>这就是传说中的<code>伪共享</code>。</p>
<h2 id="何为伪共享（False-Sharing）"><a href="#何为伪共享（False-Sharing）" class="headerlink" title="何为伪共享（False Sharing）"></a>何为伪共享（False Sharing）</h2><p>从上面我们的原理讲解中，对<code>伪共享</code>有了理性的认识。</p>
<p>这里我们先给<code>伪共享</code>下个定义：</p>
<blockquote>
<p>当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>
</blockquote>
<p>我们从一个例子来看”伪共享”产生的作用：</p>
<pre class="line-numbers language-none"><code class="language-none">public class FalseSharingTest &#123;  
    public static void main(String[] args) throws InterruptedException &#123;  
        testPointer(new Pointer());  
    &#125;  

    private static void testPointer(Pointer pointer) throws InterruptedException &#123;  
        long start &#x3D; System.currentTimeMillis();  
        Thread t1 &#x3D; new Thread(() -&gt; &#123;  
            for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;  
                pointer.x++;  
            &#125;  
        &#125;);  
        Thread t2 &#x3D; new Thread(() -&gt; &#123;  
            for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;  
                pointer.y++;  
            &#125;  
        &#125;);  
        tstart();  
        tstart();  
        tjoin();  
        tjoin();  
        System.out.println(System.currentTimeMillis() - start);  
        System.out.println(&quot;x: &quot;+pointer.x);  
        System.out.println(&quot;y: &quot;+pointer.y);  
    &#125;  
&#125;  

class Pointer &#123;  
    volatile long x;  
    volatile long y;  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们声明了一个 Pointer 的类，它包含 x 和 y 两个变量（必须声明为volatile，保证可见性），一个线程对 x 进行自增1亿次，一个线程对 y 进行自增1亿次。</p>
<p>可以看到，x 和 y 完全没有任何关系，但是更新 x 的时候会把其它包含 x 的缓存行失效，同时也就失效了 y，运行这段程序输出的时间为 <code>3458ms</code>。</p>
<p>运行结果：</p>
<pre class="line-numbers language-none"><code class="language-none">3458  
x: 100000000  
y: 100000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>运行了多次，结果都是在3000ms左右。</p>
<p>虽然从这个时间上我们好像看不出来有什么伪共享的问题，无非可能有点慢而已，但我们没有别的证据。别急，我们下面会有答案的。</p>
<h2 id="避免伪共享"><a href="#避免伪共享" class="headerlink" title="避免伪共享"></a>避免伪共享</h2><p>伪共享的原理我们知道了，一个缓存行是 64 个字节，一个 long 类型是 8 个字节，所以避免伪共享也很简单，大概有以下三种方式。</p>
<h2 id="方法一-填充-Padding"><a href="#方法一-填充-Padding" class="headerlink" title="方法一 填充(Padding)"></a>方法一 填充(Padding)</h2><p>顾名思义，填充的思想就是在两个变量之间填充到64个字节，把第二个变量挤到下一个缓存行。</p>
<p>我们的例子中在两个 long 类型的变量之间再加 7 个 long 类型，把Pointer改成下面的结构之后：</p>
<pre class="line-numbers language-none"><code class="language-none">class Pointer &#123;  
    volatile long x;  
    long p1, p2, p3, p4, p5, p6, p7;  
    volatile long y;  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现时间神奇的缩短了4分之一，多次试验，大概都在800ms左右：</p>
<pre class="line-numbers language-none"><code class="language-none">720  
x: 100000000  
y: 100000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这个结果也充分证明了<code>伪共享</code>的存在。</p>
<p><code>注意</code>：在考虑使用填充之前，必须要了解的一点是JVM可能会清除无用字段或重排无用字段的位置，这样的话，可能无形中又会引入伪共享。我们也没有办法指定对象在堆内驻留的位置。</p>
<h2 id="方法二-自己创建对象"><a href="#方法二-自己创建对象" class="headerlink" title="方法二 自己创建对象"></a>方法二 自己创建对象</h2><p>我们尝试使用另外一种方式，我们重新创建自己的long类型，而不是Java自带的long：</p>
<pre class="line-numbers language-none"><code class="language-none">class Pointer &#123;  
    MyLong x&#x3D;new MyLong();  
    MyLong y&#x3D;new MyLong();  
&#125;  

class MyLong&#123;  
    volatile long value;  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时把 <code>pointer.x++;</code> 修改为 <code>pointer.x.value++;</code>，把 <code>pointer.y++;</code> 修改为 <code>pointer.y.value++;</code>，再次运行程序发现时间是 <code>752ms</code>。<br>可以看到也解决了伪共享问题。</p>
<h2 id="方法三-使用-sun-misc-Contended-注解（java8）"><a href="#方法三-使用-sun-misc-Contended-注解（java8）" class="headerlink" title="方法三 使用 @sun.misc.Contended 注解（java8）"></a>方法三 使用 @sun.misc.Contended 注解（java8）</h2><p>除了对字段进行填充之外，还有一个比较清爽的方法，那就是对需要避免陷入伪共享的字段进行注解，这个注解暗示JVM应当将字段放入不同的缓存行。</p>
<p>如下添加@Contended注解：</p>
<pre class="line-numbers language-none"><code class="language-none">import sun.misc.Contended;  
class Pointer &#123;  
   @Contended  
   volatile long x;  

   volatile long y;  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>默认使用这个注解是无效的，需要在JVM启动参数加上 <code>-XX:-RestrictContended</code>才会生效：</p>
<p>再次运行程序发现时间是 749ms：</p>
<pre class="line-numbers language-none"><code class="language-none">749  
x: 100000000  
y: 100000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>说明：引入了<code>@Contented</code>注解，被这个注解修饰的字段应当和其他的字段驻留在不同的位置。上面的代码将x和y置于不同的缓存行。@Contented注解将y移动到远离对象头部的地方，(以避免和x一起被加载到同一个缓存行)。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>杂谈 什么是伪共享（false sharing）？ （注：这篇文章中的避免伪共享的方案中的代码及解释有误，本文已纠正）<br>Java8中@Contended和伪共享</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）CPU具有多级缓存，越接近CPU的缓存越小也越快；</p>
<p>（2）CPU缓存中的数据是以缓存行为单位处理的；</p>
<p>（3）CPU缓存行能带来免费加载数据的好处，所以处理数组性能非常高；</p>
<p>（4）CPU缓存行也带来了弊端，多线程处理不相干的变量时会相互影响，也就是伪共享；</p>
<p>（5）避免伪共享的主要思路就是让不相干的变量不要出现在同一个缓存行中，常见的有填充、创建自己的变量、使用注解三种方式避免伪共享。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>伪共享</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java线程池：ThreadPoolExecutor</title>
    <url>/2019/05/06/java/shen-ru-li-jie-java-xian-cheng-chi-threadpoolexecutor/</url>
    <content><![CDATA[<p>看完ThreadPoolExecutor线程池源码准备写博客记录一下，但是发现一篇博客对ThreadPoolExecutor源码分析很详细，这里不再重复造轮子，所以直接转载了这篇文章。</p>
<blockquote>
<p>原文地址：<a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a></p>
</blockquote>
<h2 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h2><p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p>
<p><strong>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</strong></p>
<p>那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p>
<p>这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p>
<p><strong>什么时候使用线程池？</strong></p>
<ul>
<li>单个任务处理时间比较短</li>
<li>需要处理的任务数量很大</li>
</ul>
<p><strong>使用线程池的好处</strong></p>
<p>引用自 <a href="http://ifeve.com/java-threadpool/">http://ifeve.com/java-threadpool/</a> 的说明：</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>Java中的线程池是用ThreadPoolExecutor类来实现的. 本文就结合JDK 1.8对该类的源码来分析一下这个类内部对于线程的创建, 管理以及后台任务的调度等方面的执行原理。</p>
<p>先看一下线程池的类图：</p>
<p><img src="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/QQ20170331-004227.png" alt="ThreadPoolExecutor.png"></p>
<h2 id="Executor框架接口"><a href="#Executor框架接口" class="headerlink" title="Executor框架接口"></a>Executor框架接口</h2><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。</p>
<p>J.U.C中有三个Executor接口：</p>
<ul>
<li><strong>Executor</strong>：一个运行新任务的简单接口；</li>
<li><strong>ExecutorService</strong>：扩展了Executor接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；</li>
<li><strong>ScheduledExecutorService</strong>：扩展了ExecutorService。支持Future和定期执行任务。</li>
</ul>
<h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><pre class="line-numbers language-none"><code class="language-none">public interface Executor &#123;
    void execute(Runnable command);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。例如，使用Thread来创建并启动线程的代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Thread t &#x3D; new Thread();
t.start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用Executor来启动线程执行任务的代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Thread t &#x3D; new Thread();
executor.execute(t);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。</p>
<h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><p>ExecutorService接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。增加了shutDown()，shutDownNow()，invokeAll()，invokeAny()和submit()等方法。如果需要支持即时关闭，也就是shutDownNow()方法，则任务需要正确处理中断。</p>
<h3 id="ScheduledExecutorService接口"><a href="#ScheduledExecutorService接口" class="headerlink" title="ScheduledExecutorService接口"></a>ScheduledExecutorService接口</h3><p>ScheduledExecutorService扩展ExecutorService接口并增加了schedule方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的scheduleAtFixedRate()方法和scheduleWithFixedDelay()方法。</p>
<h2 id="ThreadPoolExecutor分析"><a href="#ThreadPoolExecutor分析" class="headerlink" title="ThreadPoolExecutor分析"></a>ThreadPoolExecutor分析</h2><p>ThreadPoolExecutor继承自AbstractExecutorService，也是实现了ExecutorService接口。</p>
<h3 id="几个重要的字段"><a href="#几个重要的字段" class="headerlink" title="几个重要的字段"></a>几个重要的字段</h3><pre class="line-numbers language-none"><code class="language-none">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;
private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;

&#x2F;&#x2F; runState is stored in the high-order bits
private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;
private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;
private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>ctl</code>是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p>
<p>下面再介绍下线程池的运行状态. 线程池一共有五种状态, 分别是:</p>
<ol>
<li><p><strong>RUNNING</strong> ：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p>
</li>
<li><p><strong>SHUTDOWN</strong>：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；</p>
</li>
<li><p><strong>STOP</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</p>
</li>
<li><p><strong>TIDYING</strong>：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</p>
</li>
<li><p>TERMINATED</p>
<p>：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。</p>
<p>进入TERMINATED的条件如下：</p>
<ul>
<li>线程池不是RUNNING状态；</li>
<li>线程池状态不是TIDYING状态或TERMINATED状态；</li>
<li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li>
<li>workerCount为0；</li>
<li>设置TIDYING状态成功。</li>
</ul>
</li>
</ol>
<p>下图为线程池的状态转换过程：</p>
<p><img src="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/threadpool-status.png" alt="threadpool-status.png"></p>
<h3 id="ctl相关方法"><a href="#ctl相关方法" class="headerlink" title="ctl相关方法"></a>ctl相关方法</h3><p>这里还有几个对ctl进行计算的方法：</p>
<pre class="line-numbers language-none"><code class="language-none">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;
private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;
private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>runStateOf</strong>：获取运行状态；</li>
<li><strong>workerCountOf</strong>：获取活动线程数；</li>
<li><strong>ctlOf</strong>：获取运行状态和活动线程数的值。</li>
</ul>
<h3 id="ThreadPoolExecutor构造方法"><a href="#ThreadPoolExecutor构造方法" class="headerlink" title="ThreadPoolExecutor构造方法"></a>ThreadPoolExecutor构造方法</h3><pre class="line-numbers language-none"><code class="language-none">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) &#123;
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;&#x3D; 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)
        throw new NullPointerException();
    this.corePoolSize &#x3D; corePoolSize;
    this.maximumPoolSize &#x3D; maximumPoolSize;
    this.workQueue &#x3D; workQueue;
    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);
    this.threadFactory &#x3D; threadFactory;
    this.handler &#x3D; handler;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>构造方法中的字段含义如下：</p>
<ul>
<li><p><strong>corePoolSize</strong>：核心线程数量，当有新任务在execute()方法提交时，会执行以下判断：</p>
<ol>
<li>如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li>
<li>如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；</li>
<li>如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；</li>
<li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；</li>
</ol>
<p>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</p>
</li>
<li><p><strong>maximumPoolSize</strong>：最大线程数量；</p>
</li>
<li><p><strong>workQueue</strong>：等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列；</p>
</li>
<li><p>workQueue</p>
<p>：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:</p>
<ol>
<li><p><strong>直接切换</strong>：这种方式常用的队列是SynchronousQueue，但现在还没有研究过该队列，这里暂时还没法介绍；</p>
</li>
<li><p><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</p>
</li>
<li><p>使用有界队列</p>
<p>：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</p>
<ul>
<li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li>
<li>如果提交的任务经常发生阻塞，那么可以考虑通过调用 setMaximumPoolSize() 方法来重新设定线程池的容量。</li>
<li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>keepAliveTime</strong>：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</p>
</li>
<li><p><strong>threadFactory</strong>：它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</p>
</li>
<li><p>handler</p>
<p>：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：</p>
<ol>
<li>AbortPolicy：直接抛出异常，这是默认策略；</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>DiscardPolicy：直接丢弃任务；</li>
</ol>
</li>
</ul>
<h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><p>execute()方法用来提交任务，代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">public void execute(Runnable command) &#123;
    if (command &#x3D;&#x3D; null)
        throw new NullPointerException();
    &#x2F;*
     * clt记录着runState和workerCount
     *&#x2F;
    int c &#x3D; ctl.get();
    &#x2F;*
     * workerCountOf方法取出低29位的值，表示当前活动的线程数；
     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；
     * 并把任务添加到该线程中。
     *&#x2F;
    if (workerCountOf(c) &lt; corePoolSize) &#123;
        &#x2F;*
         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；
         * 如果为true，根据corePoolSize来判断；
         * 如果为false，则根据maximumPoolSize来判断
         *&#x2F;
        if (addWorker(command, true))
            return;
        &#x2F;*
         * 如果添加失败，则重新获取ctl值
         *&#x2F;
        c &#x3D; ctl.get();
    &#125;
    &#x2F;*
     * 如果当前线程池是运行状态并且任务添加到队列成功
     *&#x2F;
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;
        &#x2F;&#x2F; 重新获取ctl值
        int recheck &#x3D; ctl.get();
        &#x2F;&#x2F; 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，
        &#x2F;&#x2F; 这时需要移除该command
        &#x2F;&#x2F; 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        &#x2F;*
         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法
         * 这里传入的参数表示：
         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；
         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；
         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。
         *&#x2F;
        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)
            addWorker(null, false);
    &#125;
    &#x2F;*
     * 如果执行到这里，有两种情况：
     * 1. 线程池已经不是RUNNING状态；
     * 2. 线程池是RUNNING状态，但workerCount &gt;&#x3D; corePoolSize并且workQueue已满。
     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；
     * 如果失败则拒绝该任务
     *&#x2F;
    else if (!addWorker(command, false))
        reject(command);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>简单来说，在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：</p>
<ol>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>这里要注意一下<code>addWorker(null, false);</code>，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在<code>workerCountOf(recheck) == 0</code>时执行<code>addWorker(null, false);</code>也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。</p>
<p>execute方法执行流程如下：</p>
<p><img src="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/executor.png" alt="executor.png"></p>
<h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">private boolean addWorker(Runnable firstTask, boolean core) &#123;
    retry:
    for (;;) &#123;
        int c &#x3D; ctl.get();
        &#x2F;&#x2F; 获取运行状态
        int rs &#x3D; runStateOf(c);
        
        &#x2F;*
         * 这个if判断
         * 如果rs &gt;&#x3D; SHUTDOWN，则表示此时不再接收新任务；
         * 接着判断以下3个条件，只要有1个不满足，则返回false：
         * 1. rs &#x3D;&#x3D; SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务
         * 2. firsTask为空
         * 3. 阻塞队列不为空
         * 
         * 首先考虑rs &#x3D;&#x3D; SHUTDOWN的情况
         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；
         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，
         * 因为队列中已经没有任务了，不需要再添加线程了
         *&#x2F;
        &#x2F;&#x2F; Check if queue empty only if necessary.
        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;
            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;
               firstTask &#x3D;&#x3D; null &amp;&amp;
               ! workQueue.isEmpty()))
            return false;

        for (;;) &#123;
            &#x2F;&#x2F; 获取线程数
            int wc &#x3D; workerCountOf(c);
            &#x2F;&#x2F; 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；
            &#x2F;&#x2F; 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，
            &#x2F;&#x2F; 如果为false则根据maximumPoolSize来比较。
            &#x2F;&#x2F; 
            if (wc &gt;&#x3D; CAPACITY ||
                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))
                return false;
            &#x2F;&#x2F; 尝试增加workerCount，如果成功，则跳出第一个for循环
            if (compareAndIncrementWorkerCount(c))
                break retry;
            &#x2F;&#x2F; 如果增加workerCount失败，则重新获取ctl的值
            c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl
            &#x2F;&#x2F; 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行
            if (runStateOf(c) !&#x3D; rs)
                continue retry;
            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop
        &#125;
    &#125;

    boolean workerStarted &#x3D; false;
    boolean workerAdded &#x3D; false;
    Worker w &#x3D; null;
    try &#123;
        &#x2F;&#x2F; 根据firstTask来创建Worker对象
        w &#x3D; new Worker(firstTask);
        &#x2F;&#x2F; 每一个Worker对象都会创建一个线程
        final Thread t &#x3D; w.thread;
        if (t !&#x3D; null) &#123;
            final ReentrantLock mainLock &#x3D; this.mainLock;
            mainLock.lock();
            try &#123;
                &#x2F;&#x2F; Recheck while holding lock.
                &#x2F;&#x2F; Back out on ThreadFactory failure or if
                &#x2F;&#x2F; shut down before lock acquired.
                int rs &#x3D; runStateOf(ctl.get());
                &#x2F;&#x2F; rs &lt; SHUTDOWN表示是RUNNING状态；
                &#x2F;&#x2F; 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。
                &#x2F;&#x2F; 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务
                if (rs &lt; SHUTDOWN ||
                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;
                    if (t.isAlive()) &#x2F;&#x2F; precheck that t is startable
                        throw new IllegalThreadStateException();
                    &#x2F;&#x2F; workers是一个HashSet
                    workers.add(w);
                    int s &#x3D; workers.size();
                    &#x2F;&#x2F; largestPoolSize记录着线程池中出现过的最大线程数量
                    if (s &gt; largestPoolSize)
                        largestPoolSize &#x3D; s;
                    workerAdded &#x3D; true;
                &#125;
            &#125; finally &#123;
                mainLock.unlock();
            &#125;
            if (workerAdded) &#123;
                &#x2F;&#x2F; 启动线程
                t.start();
                workerStarted &#x3D; true;
            &#125;
        &#125;
    &#125; finally &#123;
        if (! workerStarted)
            addWorkerFailed(w);
    &#125;
    return workerStarted;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意一下这里的<code>t.start()</code>这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p>
<h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义：</p>
<pre class="line-numbers language-none"><code class="language-none">private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
&#123;
    &#x2F;**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     *&#x2F;
    private static final long serialVersionUID &#x3D; 6138294804551838833L;

    &#x2F;** Thread this worker is running in.  Null if factory fails. *&#x2F;
    final Thread thread;
    &#x2F;** Initial task to run.  Possibly null. *&#x2F;
    Runnable firstTask;
    &#x2F;** Per-thread task counter *&#x2F;
    volatile long completedTasks;

    &#x2F;**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     *&#x2F;
    Worker(Runnable firstTask) &#123;
        setState(-1); &#x2F;&#x2F; inhibit interrupts until runWorker
        this.firstTask &#x3D; firstTask;
        this.thread &#x3D; getThreadFactory().newThread(this);
    &#125;

    &#x2F;** Delegates main run loop to outer runWorker  *&#x2F;
    public void run() &#123;
        runWorker(this);
    &#125;

    &#x2F;&#x2F; Lock methods
    &#x2F;&#x2F;
    &#x2F;&#x2F; The value 0 represents the unlocked state.
    &#x2F;&#x2F; The value 1 represents the locked state.

    protected boolean isHeldExclusively() &#123;
        return getState() !&#x3D; 0;
    &#125;

    protected boolean tryAcquire(int unused) &#123;
        if (compareAndSetState(0, 1)) &#123;
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        &#125;
        return false;
    &#125;

    protected boolean tryRelease(int unused) &#123;
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    &#125;

    public void lock()        &#123; acquire(1); &#125;
    public boolean tryLock()  &#123; return tryAcquire(1); &#125;
    public void unlock()      &#123; release(1); &#125;
    public boolean isLocked() &#123; return isHeldExclusively(); &#125;

    void interruptIfStarted() &#123;
        Thread t;
        if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123;
            try &#123;
                t.interrupt();
            &#125; catch (SecurityException ignore) &#123;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p>
<p>在调用构造方法时，需要把任务传入，这里通过<code>getThreadFactory().newThread(this);</code>来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p>
<p>Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li>
<li>如果正在执行任务，则不应该中断线程；</li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li>
<li>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</li>
</ol>
<p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。</p>
<p>此外，在构造方法中执行了<code>setState(-1);</code>，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p>
<pre class="line-numbers language-none"><code class="language-none">protected boolean tryAcquire(int unused) &#123;
    if (compareAndSetState(0, 1)) &#123;
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
    &#125;
    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>tryAcquire方法是根据state是否是0来判断的，所以，<code>setState(-1);</code>将state设置为-1是为了禁止在执行任务前对线程进行中断。</p>
<p>正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0.</p>
<h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">final void runWorker(Worker w) &#123;
    Thread wt &#x3D; Thread.currentThread();
    &#x2F;&#x2F; 获取第一个任务
    Runnable task &#x3D; w.firstTask;
    w.firstTask &#x3D; null;
    &#x2F;&#x2F; 允许中断
    w.unlock(); &#x2F;&#x2F; allow interrupts
    &#x2F;&#x2F; 是否因为异常退出循环
    boolean completedAbruptly &#x3D; true;
    try &#123;
        &#x2F;&#x2F; 如果task为空，则通过getTask来获取任务
        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;
            w.lock();
            &#x2F;&#x2F; If pool is stopping, ensure thread is interrupted;
            &#x2F;&#x2F; if not, ensure thread is not interrupted.  This
            &#x2F;&#x2F; requires a recheck in second case to deal with
            &#x2F;&#x2F; shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;&amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())
                wt.interrupt();
            try &#123;
                beforeExecute(wt, task);
                Throwable thrown &#x3D; null;
                try &#123;
                    task.run();
                &#125; catch (RuntimeException x) &#123;
                    thrown &#x3D; x; throw x;
                &#125; catch (Error x) &#123;
                    thrown &#x3D; x; throw x;
                &#125; catch (Throwable x) &#123;
                    thrown &#x3D; x; throw new Error(x);
                &#125; finally &#123;
                    afterExecute(task, thrown);
                &#125;
            &#125; finally &#123;
                task &#x3D; null;
                w.completedTasks++;
                w.unlock();
            &#125;
        &#125;
        completedAbruptly &#x3D; false;
    &#125; finally &#123;
        processWorkerExit(w, completedAbruptly);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里说明一下第一个if判断，目的是：</p>
<ul>
<li>如果线程池正在停止，那么要保证当前线程是中断状态；</li>
<li>如果不是的话，则要保证当前线程不是中断状态；</li>
</ul>
<p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p>
<blockquote>
<p>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。</p>
</blockquote>
<p>STOP状态要中断线程池中的所有线程，而这里使用<code>Thread.interrupted()</code>来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</p>
<p>总结一下runWorker方法的执行过程：</p>
<ol>
<li>while循环不断地通过getTask()方法获取任务；</li>
<li>getTask()方法从阻塞队列中取任务；</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li>
<li>调用<code>task.run()</code>执行任务；</li>
<li>如果task为null则跳出循环，执行processWorkerExit()方法；</li>
<li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li>
</ol>
<p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</p>
<p>completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p>
<h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><p>getTask方法用来从阻塞队列中取任务，代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">private Runnable getTask() &#123;
    &#x2F;&#x2F; timeOut变量的值表示上次从阻塞队列中取任务时是否超时
    boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?

    for (;;) &#123;
        int c &#x3D; ctl.get();
        int rs &#x3D; runStateOf(c);

        &#x2F;&#x2F; Check if queue empty only if necessary.
        &#x2F;*
         * 如果线程池状态rs &gt;&#x3D; SHUTDOWN，也就是非RUNNING状态，再进行以下判断：
         * 1. rs &gt;&#x3D; STOP，线程池是否正在stop；
         * 2. 阻塞队列是否为空。
         * 如果以上条件满足，则将workerCount减1并返回null。
         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。
         *&#x2F;
        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;
            decrementWorkerCount();
            return null;
        &#125;

        int wc &#x3D; workerCountOf(c);

        &#x2F;&#x2F; Are workers subject to culling?
        &#x2F;&#x2F; timed变量用于判断是否需要进行超时控制。
        &#x2F;&#x2F; allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；
        &#x2F;&#x2F; wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；
        &#x2F;&#x2F; 对于超过核心线程数量的这些线程，需要进行超时控制
        boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;
        
        &#x2F;*
         * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；
         * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时
         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；
         * 如果减1失败，则返回重试。
         * 如果wc &#x3D;&#x3D; 1时，也就说明当前线程是线程池中唯一的一个线程了。
         *&#x2F;
        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        &#125;

        try &#123;
            &#x2F;*
             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；
             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。
             * 
             *&#x2F;
            Runnable r &#x3D; timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r !&#x3D; null)
                return r;
            &#x2F;&#x2F; 如果 r &#x3D;&#x3D; null，说明已经超时，timedOut设置为true
            timedOut &#x3D; true;
        &#125; catch (InterruptedException retry) &#123;
            &#x2F;&#x2F; 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试
            timedOut &#x3D; false;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</p>
<p>什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</p>
<p>getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</p>
<h3 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h3><pre class="line-numbers language-none"><code class="language-none">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;
    &#x2F;&#x2F; 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；
    &#x2F;&#x2F; 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。  
    if (completedAbruptly) &#x2F;&#x2F; If abrupt, then workerCount wasn&#39;t adjusted
        decrementWorkerCount();

    final ReentrantLock mainLock &#x3D; this.mainLock;
    mainLock.lock();
    try &#123;
        &#x2F;&#x2F;统计完成的任务数
        completedTaskCount +&#x3D; w.completedTasks;
        &#x2F;&#x2F; 从workers中移除，也就表示着从线程池中移除了一个工作线程
        workers.remove(w);
    &#125; finally &#123;
        mainLock.unlock();
    &#125;

    &#x2F;&#x2F; 根据线程池状态进行判断是否结束线程池
    tryTerminate();

    int c &#x3D; ctl.get();
    &#x2F;*
     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；
     * 如果allowCoreThreadTimeOut&#x3D;true，并且等待队列有任务，至少保留一个worker；
     * 如果allowCoreThreadTimeOut&#x3D;false，workerCount不少于corePoolSize。
     *&#x2F;
    if (runStateLessThan(c, STOP)) &#123;
        if (!completedAbruptly) &#123;
            int min &#x3D; allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min &#x3D;&#x3D; 0 &amp;&amp; ! workQueue.isEmpty())
                min &#x3D; 1;
            if (workerCountOf(c) &gt;&#x3D; min)
                return; &#x2F;&#x2F; replacement not needed
        &#125;
        addWorker(null, false);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：</p>
<p><img src="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/threadpool-lifecycle.png" alt="threadpool-lifecycle.png"></p>
<h3 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h3><p>tryTerminate方法根据线程池状态进行判断是否结束线程池，代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">final void tryTerminate() &#123;
    for (;;) &#123;
        int c &#x3D; ctl.get();
        &#x2F;*
         * 当前线程池的状态为以下几种情况时，直接返回：
         * 1. RUNNING，因为还在运行中，不能停止；
         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；
         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；
         *&#x2F;
        if (isRunning(c) ||
            runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) &#x3D;&#x3D; SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))
            return;
        &#x2F;&#x2F; 如果线程数量不为0，则中断一个空闲的工作线程，并返回
        if (workerCountOf(c) !&#x3D; 0) &#123; &#x2F;&#x2F; Eligible to terminate
            interruptIdleWorkers(ONLY_ONE);
            return;
        &#125;

        final ReentrantLock mainLock &#x3D; this.mainLock;
        mainLock.lock();
        try &#123;
            &#x2F;&#x2F; 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;
                try &#123;
                    &#x2F;&#x2F; terminated方法默认什么都不做，留给子类实现
                    terminated();
                &#125; finally &#123;
                    &#x2F;&#x2F; 设置状态为TERMINATED
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll();
                &#125;
                return;
            &#125;
        &#125; finally &#123;
            mainLock.unlock();
        &#125;
        &#x2F;&#x2F; else retry on failed CAS
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>interruptIdleWorkers(ONLY_ONE);</code>的作用是因为在getTask方法中执行<code>workQueue.take()</code>时，如果不执行中断会一直阻塞。在下面介绍的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了getTask方法，这时如果workQueue中没有任务了，调用<code>workQueue.take()</code>时就会一直阻塞。所以每次在工作线程结束时调用tryTerminate方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。</p>
<h3 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h3><p>shutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。</p>
<pre class="line-numbers language-none"><code class="language-none">public void shutdown() &#123;
    final ReentrantLock mainLock &#x3D; this.mainLock;
    mainLock.lock();
    try &#123;
        &#x2F;&#x2F; 安全策略判断
        checkShutdownAccess();
        &#x2F;&#x2F; 切换状态为SHUTDOWN
        advanceRunState(SHUTDOWN);
        &#x2F;&#x2F; 中断空闲线程
        interruptIdleWorkers();
        onShutdown(); &#x2F;&#x2F; hook for ScheduledThreadPoolExecutor
    &#125; finally &#123;
        mainLock.unlock();
    &#125;
    &#x2F;&#x2F; 尝试结束线程池
    tryTerminate();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里思考一个问题：在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？</p>
<p>下面仔细分析一下：</p>
<ul>
<li>在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；</li>
<li>shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；</li>
<li>在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用<code>workQueue.take()</code>进行阻塞；</li>
<li>如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了<code>workQueue.take()</code>后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；</li>
<li>由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；</li>
<li>解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用<code>workQueue.take()</code>时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；</li>
<li>但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；</li>
<li>所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。</li>
</ul>
<p>下面就来分析一下interruptIdleWorkers方法。</p>
<h3 id="interruptIdleWorkers方法"><a href="#interruptIdleWorkers方法" class="headerlink" title="interruptIdleWorkers方法"></a>interruptIdleWorkers方法</h3><pre class="line-numbers language-none"><code class="language-none">private void interruptIdleWorkers() &#123;
    interruptIdleWorkers(false);
&#125;

private void interruptIdleWorkers(boolean onlyOne) &#123;
    final ReentrantLock mainLock &#x3D; this.mainLock;
    mainLock.lock();
    try &#123;
        for (Worker w : workers) &#123;
            Thread t &#x3D; w.thread;
            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;
                try &#123;
                    t.interrupt();
                &#125; catch (SecurityException ignore) &#123;
                &#125; finally &#123;
                    w.unlock();
                &#125;
            &#125;
            if (onlyOne)
                break;
        &#125;
    &#125; finally &#123;
        mainLock.unlock();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>interruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。</p>
<p>为什么需要持有mainLock？因为workers是HashSet类型的，不能保证线程安全。</p>
<h3 id="shutdownNow方法"><a href="#shutdownNow方法" class="headerlink" title="shutdownNow方法"></a>shutdownNow方法</h3><pre class="line-numbers language-none"><code class="language-none">public List&lt;Runnable&gt; shutdownNow() &#123;
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock &#x3D; this.mainLock;
    mainLock.lock();
    try &#123;
        checkShutdownAccess();
        advanceRunState(STOP);
        &#x2F;&#x2F; 中断所有工作线程，无论是否空闲
        interruptWorkers();
        &#x2F;&#x2F; 取出队列中没有被执行的任务
        tasks &#x3D; drainQueue();
    &#125; finally &#123;
        mainLock.unlock();
    &#125;
    tryTerminate();
    return tasks;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>shutdownNow方法与shutdown方法类似，不同的地方在于：</p>
<ol>
<li>设置状态为STOP；</li>
<li>中断所有工作线程，无论是否是空闲的；</li>
<li>取出阻塞队列中没有被执行的任务并返回。</li>
</ol>
<p>shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。</p>
<h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li><strong>getTaskCount</strong>：线程池已经执行的和未执行的任务总数；</li>
<li><strong>getCompletedTaskCount</strong>：线程池已完成的任务数量，该值小于等于taskCount；</li>
<li><strong>getLargestPoolSize</strong>：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li>
<li><strong>getPoolSize</strong>：线程池当前的线程数量；</li>
<li><strong>getActiveCount</strong>：当前线程池中正在执行任务的线程数量。</li>
</ul>
<p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文比较详细的分析了线程池的工作流程，总体来说有如下几个内容：</p>
<ul>
<li>分析了线程的创建，任务的提交，状态的转换以及线程池的关闭；</li>
<li>这里通过execute方法来展开线程池的工作流程，execute方法通过corePoolSize，maximumPoolSize以及阻塞队列的大小来判断决定传入的任务应该被立即执行，还是应该添加到阻塞队列中，还是应该拒绝任务。</li>
<li>介绍了线程池关闭时的过程，也分析了shutdown方法与getTask方法存在竞态条件；</li>
<li>在获取任务时，要通过线程池的状态来判断应该结束工作线程还是阻塞线程等待新的任务，也解释了为什么关闭线程池时要中断工作线程以及为什么每一个worker都需要lock。</li>
</ul>
<p>在向线程池提交任务时，除了execute方法，还有一个submit方法，submit方法会返回一个Future对象用于获取返回值，有关Future和Callable请自行了解一下相关的文章，这里就不介绍了。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA在不同数据库类下ID生成策略适配方案</title>
    <url>/2020/01/26/jpa/jpa-zai-bu-tong-shu-ju-ku-lei-xia-id-sheng-cheng-ce-lue-gua-pei-fang-an/</url>
    <content><![CDATA[<h1 id="JPA在不同数据库类下ID生成策略适配方案——技术解决方案"><a href="#JPA在不同数据库类下ID生成策略适配方案——技术解决方案" class="headerlink" title="JPA在不同数据库类下ID生成策略适配方案——技术解决方案"></a>JPA在不同数据库类下ID生成策略适配方案——技术解决方案</h1><span id="more"></span>


	<div class="row">
    <embed src="./JPA在不同数据库类下ID生成策略适配方案.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的CommitLimit与OOM Killer</title>
    <url>/2020/11/19/linux/linux-zhong-de-commitlimit-yu-oomkiller/</url>
    <content><![CDATA[<h1 id="一、背景说明"><a href="#一、背景说明" class="headerlink" title="一、背景说明"></a>一、背景说明</h1><p>在测试过程中遇到一个Java进程由于申请内存过大导致被Linux OOM killer杀掉的问题，所以来分析一下Linux中的CommitLimit与OMM killer机制。</p>
<h1 id="二、Linux内存分配机制"><a href="#二、Linux内存分配机制" class="headerlink" title="二、Linux内存分配机制"></a>二、Linux内存分配机制</h1><p>　　Linux系统允许程序申请比系统可用内存更多的内存空间，这个特性叫做 <code>overcommit</code> 特性，这样做可能是为了系统的优化，因为不是所有的程序申请了内存就会立刻使用，当真正的使用时，系统可能已经回收了一些内存。为了避免内存的浪费，在分配页面时，Linux 采用的是按需分配物理页面的方式。譬如说，某个进程调用malloc()申请了一块小内存，这时内核会分配一个虚拟页面，但这个页面不会映射到实际的物理页面。<br><img src="/2020/11/19/linux/linux-zhong-de-commitlimit-yu-oomkiller/oom1.png" alt="OS内存分配"><br>从图中可以看到，当程序首次访问这个虚拟页面时，会触发一个缺页异常 (page fault)。这时内核会分配一个物理页面，让虚拟页面映射到这个物理页面，同时更新进程的页表 (page table)。</p>
<h2 id="2-1-Linux的Memory-Overcommit"><a href="#2-1-Linux的Memory-Overcommit" class="headerlink" title="2.1 Linux的Memory Overcommit"></a>2.1 Linux的Memory Overcommit</h2><p>这种按需分配物理页面的方式，可以大大节省物理内存的使用，但有时会导致 Memory Overcommit。所谓 Memory Overcommit，也就是说，所有进程使用的虚拟内存超过了系统的物理内存和交换空间的总和。默认情况下，Linux 是允许 Memory Overcommit 的。并且在大多数情况下，Memory Overcommit 也是安全的，因为很多进程只是申请了很多内存，但实际使用到的内存并不多。</p>
<p>但万一很多进程都使用了申请来的大部分内存，就可能导致物理内存和交换空间不够用了，这时内核的 OOM Killer 就会出马，它会选择杀掉一个或多个进程，这样就能腾出一些内存给其它进程使用。</p>
<p>Linux设计了一个OOM killer机制(out of memory killer)来处理这种危机：挑选一个进程出来杀死，以腾出部分内存，如果还不够就继续杀…也可通过设置内核参数 vm.panic_on_oom 使得发生OOM时自动重启系统。</p>
<p>Linux 2.6之后允许通过内核参数 vm.overcommit_memory 禁止memory overcommit。<br>内核参数 vm.overcommit_memory 接受三种取值：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Heuristic overcommit handling. 这是缺省值，它允许overcommit，但过于明目张胆的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。</td>
</tr>
<tr>
<td>1</td>
<td>Always overcommit. 允许overcommit，对内存申请来者不拒</td>
</tr>
<tr>
<td>2</td>
<td>Don’t overcommit. 禁止overcommit。</td>
</tr>
</tbody></table>
<h3 id="如何才算-overcommit？"><a href="#如何才算-overcommit？" class="headerlink" title="如何才算 overcommit？"></a>如何才算 overcommit？</h3><p>Linux 设定了一个阈值，叫做 CommitLimit，如果所有进程申请的总内存超过了 CommitLimit，那就算是 overcommit 了。在/proc/meminfo中可以看到 CommitLimit 的大小：</p>
<pre class="line-numbers language-none"><code class="language-none">$ grep -i commit &#x2F;proc&#x2F;meminfo
CommitLimit:    32905144 kB
Committed_AS:   30462700 kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>CommitLimit ： overcommit的阈值</li>
<li> Committed_AS : 表示所有进程已经申请的内存总大小</li>
</ul>
<blockquote>
<p>注意 Committed_AS是已经申请的，不是已经分配的，如果 Committed_AS 超过 CommitLimit 就表示发生了 overcommit，超出越多表示 overcommit 越严重。</p>
</blockquote>
<h3 id="CommitLimit计算方式"><a href="#CommitLimit计算方式" class="headerlink" title="CommitLimit计算方式"></a>CommitLimit计算方式</h3><pre class="line-numbers language-none"><code class="language-none">CommitLimit &#x3D; [swap size] + [RAM size] * vm.overcommit_ratio &#x2F; 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>[swap size] : 交换区空间大小</li>
<li>[RAM size] : 内存空间大小</li>
<li>vm.overcommit_ratio : vm.overcommit_ratio 是内核参数，缺省值是50，表示物理内存的50%</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">$ free
              total        used        free      shared  buff&#x2F;cache   available
Mem:       32780152    16704624     2104672     1442992    13970856    14124620
Swap:      16515068      127488    16387580<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>CommitLimit = 16515068 + 32780152 * 50 / 100 = 32905144</p>
</blockquote>
<h2 id="2-2-Linux-OOM-Killer"><a href="#2-2-Linux-OOM-Killer" class="headerlink" title="2.2 Linux OOM Killer"></a>2.2 Linux OOM Killer</h2><p>当物理内存严重不足时，Linux内核调用OOM Killer来检查所有正在运行的进程并杀死其中一个或多个进程，以释放系统内存并保持系统运行。</p>
<h3 id="OOM-Killer如何选择进程？"><a href="#OOM-Killer如何选择进程？" class="headerlink" title="OOM Killer如何选择进程？"></a>OOM Killer如何选择进程？</h3><p>Linux内核给每个正在运行的进程评分oom_score，该评分显示了在可用内存不足的情况下终止该进程的可能性。</p>
<pre class="line-numbers language-none"><code class="language-none">oom_score &#x3D; 10 x [percent of memory used by process]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>oom_score最大得分为<code>100% x 10 = 1000</code> 。此外，如果进程以root用户身份运行，则与普通用户进程使用相同的内存相比，该进程的oom_score略低。</p>
</blockquote>
<p>Linux 的每个进程都有一个<code>oom_score</code> (位于/proc/$pid/oom_score)，这个值越大，就越有可能被 OOM Killer 选中。<br>这个值是系统综合进程的内存消耗量、CPU时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高，存活时间越长分越低。</p>
<h3 id="如何避免进程被OOM-Killer杀死？"><a href="#如何避免进程被OOM-Killer杀死？" class="headerlink" title="如何避免进程被OOM Killer杀死？"></a>如何避免进程被OOM Killer杀死？</h3><h4 id="oom-score-adj"><a href="#oom-score-adj" class="headerlink" title="oom_score_adj"></a>oom_score_adj</h4><p> OOM killer检查oom_score_adj以调整其最终计算出的分数。该文件位于/proc/$pid/oom_score_adj中,所以我们可以通过在这个文件中给一个大的负数，以降低该进程被选中并终止的可能性。oom_score_adj取值范围在-1000到1000之间。如果你给了-1000，进程即使使用了100%的内存也不会被OOM Killer杀死。</p>
<blockquote>
<p>修改pid为42的进程的oom_score_adj的方法：</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">sudo echo -200 &gt; &#x2F;proc&#x2F;42&#x2F;oom_score_adj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>需要以root用户或sudo的身份执行此操作，因为Linux不允许普通用户降低OOM分数。您可以在没有任何特殊权限的情况下以普通用户身份提高OOM分数。例如:</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">echo 100&gt; &#x2F;proc&#x2F;42&#x2F;oom_score_adj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="oom-adj"><a href="#oom-adj" class="headerlink" title="oom_adj"></a>oom_adj</h4><p> 另外还有一个较细粒度的分数，称为oom_adj，该文件位于/proc/$pid/oom_adj，范围从-16到15。与oom_score_adj类似。 实际上，设置oom_score_adj时，内核会自动将其按比例缩小并计算oom_adj。<br> 当oom_adj的魔术值为-17，指示给定的进程永远不能被OOM杀手杀死。</p>
<h4 id="显示所有正在运行的进程的OOM分数"><a href="#显示所有正在运行的进程的OOM分数" class="headerlink" title="显示所有正在运行的进程的OOM分数"></a>显示所有正在运行的进程的OOM分数</h4><p> 该脚本以OOM分数的降序显示所有正在运行的进程的OOM分数和OOM调整后的分数：</p>
 <pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bash
# Displays running processes in descending order of OOM score
printf &#39;PID\tOOM Score\tOOM Adj\tCommand\n&#39;
while read -r pid comm; do [ -f &#x2F;proc&#x2F;$pid&#x2F;oom_score ] &amp;&amp; [ $(cat &#x2F;proc&#x2F;$pid&#x2F;oom_score) !&#x3D; 0 ] &amp;&amp; printf &#39;%d\t%d\t\t%d\t%s\n&#39; &quot;$pid&quot; &quot;$(cat &#x2F;proc&#x2F;$pid&#x2F;oom_score)&quot; &quot;$(cat &#x2F;proc&#x2F;$pid&#x2F;oom_score_adj)&quot; &quot;$comm&quot;; done &lt; &lt;(ps -e -o pid&#x3D; -o comm&#x3D;) | sort -k 2nr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="检查进程是否已被OOM杀死"><a href="#检查进程是否已被OOM杀死" class="headerlink" title="检查进程是否已被OOM杀死"></a>检查进程是否已被OOM杀死</h4> <pre class="line-numbers language-none"><code class="language-none"> $ egrep -i &#39;killed process&#39; &#x2F;var&#x2F;log&#x2F;messages
Nov 19 16:24:31 localhost kernel: Killed process 26980 (java) total-vm:14316628kB, anon-rss:6138236kB, file-rss:0kB, shmem-rss:0kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://linuxperf.com/?p=102">理解LINUX的MEMORY OVERCOMMIT</a><br><a href="http://senlinzhan.github.io/2017/07/03/oom-killer/">Linux 的 OOM Killer 机制分析</a><br><a href="https://learning-kernel.readthedocs.io/en/latest/mem-management.html">内存管理</a><br><a href="https://dev.to/rrampage/surviving-the-linux-oom-killer-2ki9">Surviving the Linux OOM Killer</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Linux</tag>
        <tag>CommitLimit</tag>
        <tag>OOM killer</tag>
      </tags>
  </entry>
  <entry>
    <title>一次Java进程物理内存占用超过最大堆内存分析</title>
    <url>/2020/11/30/linux/yi-ci-java-jin-cheng-wu-li-nei-cun-zhan-yong-chao-guo-zui-da-dui-nei-cun-fen-xi/</url>
    <content><![CDATA[<h1 id="一、背景说明"><a href="#一、背景说明" class="headerlink" title="一、背景说明"></a>一、背景说明</h1><p>项目测试过程中，测试人员反馈使用Excel导入100万号码时报错，通过Top命令查看到该java进程占用物理内存大小为3.4G，而且内存持续占用，一直没有释放，怀疑是不是有内存泄露的情况。</p>
<p><img src="/2020/11/30/linux/yi-ci-java-jin-cheng-wu-li-nei-cun-zhan-yong-chao-guo-zui-da-dui-nei-cun-fen-xi/top.jpg" alt="top结果"></p>
<p><em>PS：上图为后续重新截的图,比第一次物理内存占用小</em></p>
<blockquote>
<p>JVM配置参数如下：</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">server.java.opts&#x3D;-d64 -XX:MaxPermSize&#x3D;192M -Xms3000M -Xmx3000M -XX:+HeapDumpOnOutOfMemoryError<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="二、问题排查"><a href="#二、问题排查" class="headerlink" title="二、问题排查"></a>二、问题排查</h1><p>查看日志发现出现了<code>OOM</code>, 报错信息未：<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>，并生成了堆内存快照文件java_pid31734.hprof。<br>通过jVisualVM工具分析<code>java_pid31734.hprof</code>文件。</p>
<p><img src="/2020/11/30/linux/yi-ci-java-jin-cheng-wu-li-nei-cun-zhan-yong-chao-guo-zui-da-dui-nei-cun-fen-xi/hprof.jpg" alt="hprof"></p>
<p>java进程发生OOM时生成的堆内存快照文件大小为3.4G。</p>
<p><img src="/2020/11/30/linux/yi-ci-java-jin-cheng-wu-li-nei-cun-zhan-yong-chao-guo-zui-da-dui-nei-cun-fen-xi/hprof_class.jpg" alt="hprof_class"></p>
<p>由于在项目中使用<code>POI</code>去读取Excel文件的，从内存快照中可以看到大量的内存被<code>POI</code>相关的对象占用。</p>
<p>发生OOM后java进程并没有退出，仍可以正常访问。接下来看一下Java进程的堆内存使用情况：</p>
<p><img src="/2020/11/30/linux/yi-ci-java-jin-cheng-wu-li-nei-cun-zhan-yong-chao-guo-zui-da-dui-nei-cun-fen-xi/jmap.jpg" alt="jmap result"></p>
<p>通过<code>jmap</code>查看JVM堆内存使用总计约为152.8 MB：100.07（年轻代） + 52.73（老年代），说明出现<code>OOM</code>后，占用的堆内存已经正常释放。</p>
<h2 id="2-1-为什么堆内存释放后java进程占用的物理内存没有收缩？"><a href="#2-1-为什么堆内存释放后java进程占用的物理内存没有收缩？" class="headerlink" title="2.1 为什么堆内存释放后java进程占用的物理内存没有收缩？"></a>2.1 为什么堆内存释放后java进程占用的物理内存没有收缩？</h2><p>项目启动后，该java进程占用内存也就1G多一点，进行导入Excel文件操作后，出现了OOM，但是后面堆内存已经正常释放，为什么该java进程占用物理内存没有释放？</p>
<h3 id="操作系统内存分配机制"><a href="#操作系统内存分配机制" class="headerlink" title="操作系统内存分配机制"></a>操作系统内存分配机制</h3><blockquote>
<p>进程向操作系统申请内存时，操作系统分配给进程的是虚拟内存空间，只有进程真正访问这块内存时，操作系统才会给进程分配物理内存。</p>
</blockquote>
<p>JVM启动时，向操作系统申请了<code>3000M</code>的内存，但是这<code>3000M</code>内存空间是虚拟内存空间，只有在java进程真正使用这些内存时操作系统才会去分配物理内。<br>由于JVM启动后，没有进行耗内存的操作，实际使用的内存空间较小，所以操作系统只分配真正使用到的物理内存给JVM，所以通过Top命令查看到的物理内存占用小于<code>3000M</code>。<br>但是在处理Excel导入时发生了OOM，说明java进程已经使用了全部的堆内存，此时操作系统会将堆内存大小的物理内存全部分配给JVM。<br>上述JVM启动参数配置为<code>-Xms3000M -Xmx3000M</code>, <code>Xms</code>为最小堆内存，<code>Xmx</code>为最大堆大小，由于这两个参数配置相同，所以JVM在堆内存空闲时仍不会归还物理内存给操作系统。<br>可以通过<code>pmap</code>命令看一下进程内存占用情况:</p>
<p><img src="/2020/11/30/linux/yi-ci-java-jin-cheng-wu-li-nei-cun-zhan-yong-chao-guo-zui-da-dui-nei-cun-fen-xi/pmap.jpg" alt="pmap"></p>
<p>从上图可以看出堆内存释放后，JVM底层并未将物理内存归还给操作系统。</p>
<h2 id="2-2-为什么java进程占用的内存大小超过了堆内存大小？"><a href="#2-2-为什么java进程占用的内存大小超过了堆内存大小？" class="headerlink" title="2.2 为什么java进程占用的内存大小超过了堆内存大小？"></a>2.2 为什么java进程占用的内存大小超过了堆内存大小？</h2><p>JVM 的内存大概分为下面这几个部分</p>
<ul>
<li><p>堆（Heap）：eden、survivor、old 区域等</p>
</li>
<li><p>线程栈（Thread Stack）：每个线程栈预留 1M 的线程栈大小</p>
</li>
<li><p>非堆（Non-heap）：包括 code_cache、metaspace 等</p>
</li>
<li><p>堆外内存：unsafe.allocateMemory 和 DirectByteBuffer申请的堆外内存</p>
</li>
<li><p>native （C/C++ 代码）申请的内存</p>
</li>
<li><p>还有 JVM 运行本身需要的内存，比如 GC 等。</p>
</li>
</ul>
<p>除去JVM堆内存外，java进程本身会占用一些内存，所以会出现java进程的占用的总内存会比最大堆内存大的情况。</p>
<h1 id="三、POI读取超大Excel文件OOM问题"><a href="#三、POI读取超大Excel文件OOM问题" class="headerlink" title="三、POI读取超大Excel文件OOM问题"></a>三、POI读取超大Excel文件OOM问题</h1><p><code>POI</code>是读写Excel的常用工具包，功能非常丰富。但是<code>POI</code>的缺点也非常明显，在导入100万手机号码的Excel文件时，即使最大堆设置为<code>4000M</code>也还是会发生OOM的。<br>所以项目后续采用了阿里开源的<code>easyexcel</code>，<code>easyexcel</code><a href="https://github.com/alibaba/easyexcel">官网</a>给出的数据为：64M内存1分钟内读取75M(46W行25列)的Excel。<br>使用<code>easyexcel</code>后成功解决读取百万以上Excel数据OOM问题。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://club.perfma.com/article/1709425">一次 Java 进程 OOM 的排查分析（glibc 篇）</a><br><a href="https://club.perfma.com/article/1850399">记一次堆外内存泄漏排查过程</a><br><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">Understanding glibc malloc</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存泄露</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title>突然消失的Java进程</title>
    <url>/2020/11/19/linux/tu-ran-xiao-shi-de-java-jin-cheng/</url>
    <content><![CDATA[<h1 id="一、背景说明"><a href="#一、背景说明" class="headerlink" title="一、背景说明"></a>一、背景说明</h1><p>在一次大批量数据测试时，一个Java服务模块突然宕掉，并且连续出现了好几次。检查服务已经开启了打印堆栈信息<code>-XX:+HeapDumpOnOutOfMemoryError</code>,<br>但是在服务器运行目录下并没有发现.hprof文件生成。服务器总内存为16G，当前Java服务设置的内存为：<code>-Xms5000M -Xmx8000M</code>。</p>
<h1 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h1><p>Java进程突然被干掉无外乎以下三种情况：</p>
<ul>
<li>Linux OOM killer 杀死了Java进程</li>
<li>JVM自身故障</li>
<li>JVM OOM导致进程退出</li>
</ul>
<h2 id="2-1-Linux-的OOM-killer"><a href="#2-1-Linux-的OOM-killer" class="headerlink" title="2.1 Linux 的OOM killer"></a>2.1 Linux 的OOM killer</h2><p>Linux内核有一个OOM(out of memory) killer机制，当系统内存严重不足时，OOM killer会选择一个或多个进程杀死。关于OOM killer机制可参考上一篇文章<a href="https://www.mpoom.cn/2020/11/19/Linux%E4%B8%AD%E7%9A%84CommitLimit%E4%B8%8EOOMKiller/">Linux中的CommitLimit与OOM Killer</a>.。<br>因此，当java进程突然消失时，首先怀疑是不是被OOM killer杀掉了。</p>
<blockquote>
<p>查看系统日志文件<code>/var/log/messages</code></p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">$egrep -i &#39;killed process&#39; &#x2F;var&#x2F;log&#x2F;messages
Nov 19 16:24:31 localhost kernel: Killed process 26980 (java) total-vm:14316628kB, anon-rss:6138236kB, file-rss:0kB, shmem-rss:0kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>查看linux系统内核日志</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">$dmesg | grep java
[3571149.337671] Out of memory: Kill process 26980 (java) score 243 or sacrifice child
[3571149.338458] Killed process 26980 (java) total-vm:14316628kB, anon-rss:6138236kB, file-rss:0kB, shmem-rss:0kB
[3571149.395860] java: page allocation failure: order:0, mode:0x201da
[3571149.395864] CPU: 0 PID: 26980 Comm: java Kdump: loaded Tainted: G             L ------------ T 3.10.0-957.el7.x86_64 #1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-2-JVM的自身故障"><a href="#2-2-JVM的自身故障" class="headerlink" title="2.2 JVM的自身故障"></a>2.2 JVM的自身故障</h2><p>当JVM发生致命错误导致崩溃时，会生成一个hs_err_pid_xxx.log这样的文件，该文件包含了导致 JVM crash 的重要信息，我们可以通过分析该文件定位到导致 JVM Crash 的原因，从而修复保证系统稳定。<br>默认情况下，该文件是生成在工作目录下的，当然也可以通过 JVM 参数指定生成路径：</p>
<pre class="line-numbers language-none"><code class="language-none">-XX:ErrorFile&#x3D;&#x2F;var&#x2F;log&#x2F;hs_err_pid&lt;pid&gt;.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个文件主要包含如下内容：</p>
<ul>
<li>日志头文件</li>
<li>导致 crash 的线程信息</li>
<li>所有线程信息</li>
<li>安全点和锁信息</li>
<li>堆信息</li>
<li>本地代码缓存</li>
<li>编译事件</li>
<li>gc 相关记录</li>
<li>jvm 内存映射</li>
<li>jvm 启动参数</li>
<li>服务器信息</li>
</ul>
<h2 id="2-3-JVM的OOM"><a href="#2-3-JVM的OOM" class="headerlink" title="2.3 JVM的OOM"></a>2.3 JVM的OOM</h2><p>JVM由于有GC机制，一般很少发生OOM，但是如果出现内存泄露，就可能发生OOM导致java进程退出。<br>可以根据JVM的下面两个参数查找堆内存快照文件定位问题。</p>
<pre class="line-numbers language-none"><code class="language-none">-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath&#x3D;*&#x2F;java.hprof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>找到dump快照文件，借助一些MAT或VisualVM这一类可视化工具分析问题原因。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>当java进程突然消失时，可以先查看是否有dump文件；如果没有dump文件，再查看是否有hs_err_pid.log日志；如果也没有，则查看内核日志。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/rjzheng/p/11317889.html">JAVA进程突然消失的原因?</a><br><a href="https://www.jianshu.com/p/7652f931cafd">JVM致命错误日志(hs_err_pid.log)分析</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos简介及使用</title>
    <url>/2021/08/25/middleware/nacos-jian-jie-ji-shi-yong/</url>
    <content><![CDATA[<h1 id="《Nacos简介及使用》"><a href="#《Nacos简介及使用》" class="headerlink" title="《Nacos简介及使用》"></a>《Nacos简介及使用》</h1><span id="more"></span>


	<div class="row">
    <embed src="./Nacos简介及使用.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx代理配置中的DNS缓存问题</title>
    <url>/2020/08/04/nginx/nginx-dai-li-pei-zhi-zhong-de-dns-huan-cun-wen-ti/</url>
    <content><![CDATA[<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>客户内网环境不允许应用服务器直接访问外网，必须通过跳板机访问外网，所在使用Nginx代理访问外网，部署架构图可参考<a href="https://www.mpoom.cn/2020/07/31/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86HTTP%E7%9A%84header%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/">Nginx反向代理HTTP header自定义参数丢失问题</a>。<br>在部署完成后，测试代理接口都正常，但是一段时间过后，就出现了外网接口访问超时的问题。</p>
<h1 id="二、问题排查"><a href="#二、问题排查" class="headerlink" title="二、问题排查"></a>二、问题排查</h1><p>Nginx代理的外网接口都是通过域名进行访问，发现请求超时后，直接在服务器上ping请求地址中的域名，发现域名是可以ping通的，后面继续观察请求超时的情况，发现每次出现请求超时时，在服务器都是能直接ping通请求中的域名，但是服务器每次ping命令解析后的IP与上一次不同，在服务器则无法ping通上次解析后的IP，所以怀疑是不是Nginx缓存了DNS解析。通过查阅文档，发现Nginx在启动时会检查域名是否能够解析，在第一次请求时会缓存DNS解析记录，并且忽略了DNS中的TTL值永久缓存。</p>
<blockquote>
<p>注意：在使用Nginx进行反向代理时，如果配置的是域名，突然出现了404问题时，可以查看域名绑定的IP是否发生了变更，如果这种变更不频繁，可以重启Nginx解决，重启Nginx后域名会重新进行解析。</p>
</blockquote>
<h1 id="三、问题分析与解决"><a href="#三、问题分析与解决" class="headerlink" title="三、问题分析与解决"></a>三、问题分析与解决</h1><p>外网接口中的域名是动态解析的，不同时间访问时域名解析后的IP是动态变化的，客户内网环境只能访问域名实时解析后的IP地址（外网环境验证过没有这个问题），上次解析后的IP会有无法访问的情况。刚开始发现请求超时后，重启Nginx即可解决超时问题，但这只能作为临时的解决方法。</p>
<p>通过查阅文档得知，nginx提供了<code>resolver</code>配置项，可以设置域名解析服务器，并设置缓存的有效期：</p>
<p>Nginx文档地址：<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver">http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver</a></p>
<pre class="line-numbers language-none"><code class="language-none">Syntax:	resolver address ... [valid&#x3D;time] [ipv6&#x3D;on|off] [status_zone&#x3D;zone];
Default:	—
Context:	http, server, location
Configures name servers used to resolve names of upstream servers into addresses, for example:

resolver 127.0.0.1 [::1]:5353;
The address can be specified as a domain name or IP address, with an optional port (1.3.1, 1.2.2). If port is not specified, the port 53 is used. Name servers are queried in a round-robin fashion.

Before version 1.1.7, only a single name server could be configured. Specifying name servers using IPv6 addresses is supported starting from versions 1.3.1 and 1.2.2.
By default, nginx will look up both IPv4 and IPv6 addresses while resolving. If looking up of IPv6 addresses is not desired, the ipv6&#x3D;off parameter can be specified.

Resolving of names into IPv6 addresses is supported starting from version 1.5.8.
By default, nginx caches answers using the TTL value of a response. An optional valid parameter allows overriding it:

resolver 127.0.0.1 [::1]:5353 valid&#x3D;30s;
Before version 1.1.9, tuning of caching time was not possible, and nginx always cached answers for the duration of 5 minutes.
To prevent DNS spoofing, it is recommended configuring DNS servers in a properly secured trusted local network.
The optional status_zone parameter (1.17.1) enables collection of DNS server statistics of requests and responses in the specified zone. The parameter is available as part of our commercial subscription.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修改Nginx配置文件如下：</p>
<pre class="line-numbers language-none"><code class="language-none">server &#123;
    listen       9000;
    server_name  localhost;
    resolver 114.114.114.114 valid&#x3D;60s;

    location &#x2F;ncs&#x2F;mobile&#x2F;phone-verify &#123;
        set $mobile www.cmpassport.com;
        proxy_pass https:&#x2F;&#x2F;$mobile&#x2F;openapi&#x2F;rs&#x2F;tokenValidate;
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        proxy_redirect off;
    
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>注意：需要将代理的域名设置为变量，否则域名无法动态解析</p>
</blockquote>
<h1 id="四、验证"><a href="#四、验证" class="headerlink" title="四、验证"></a>四、验证</h1><p>上述配置中我们设置DNS解析缓存时间为60s，通过tcpdump抓取请求114.114.114.114 DNS服务器的包，在请求过程中，发现每间隔一分钟Nginx就会去重新请求DNS服务器，问题解决。</p>
<p><img src="/2020/08/04/nginx/nginx-dai-li-pei-zhi-zhong-de-dns-huan-cun-wen-ti/dns%E8%A7%A3%E6%9E%90.jpg" alt="DNS解析抓包"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理404问题</title>
    <url>/2020/07/13/nginx/nginx-fan-xiang-dai-li-404-wen-ti/</url>
    <content><![CDATA[<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>   在测试web应用的时候，前端需要进行跨域访问后端接口，由于服务端跨域访问功能不完善，所以打算通过反向代理临时解决跨域问题，但是反向代理配置成功后，访问时浏览器端返回404，在nginx的访问日志中也提示404，Nginx配置如下。</p>
<h2 id="1-1-Nginx反向代理配置"><a href="#1-1-Nginx反向代理配置" class="headerlink" title="1.1 Nginx反向代理配置"></a>1.1 Nginx反向代理配置</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server &#123;
    listen     80;
    server_name h5-verify.mpoom.cn;
    location &#x2F; &#123;
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;
    &#125;
&#125;

server &#123;
    listen       8000;
    server_name  127.0.0.1 localhost;

    set $root_path &quot;&#x2F;home&#x2F;ytx&#x2F;jiyan-h5&quot;;

    #charset koi8-r;

    location &#x2F; &#123;
        root   $root_path;
        index  index.html index.htm;
        try_files $uri $uri&#x2F; &#x2F;index.html;
    &#125;

    location &#x2F;ytx-api&#x2F; &#123;
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        proxy_buffering off;
        proxy_connect_timeout 300s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        client_max_body_size 100M;

        proxy_pass  https:&#x2F;&#x2F;www.139130.com;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="1-2-浏览器请求及响应"><a href="#1-2-浏览器请求及响应" class="headerlink" title="1.2 浏览器请求及响应"></a>1.2 浏览器请求及响应</h2><p>（1）headers</p>
<p>General</p>
<blockquote>
<p>Request URL: <a href="http://h5-verify.mpoom.cn/ytx-api/v1.0.0/phone/carrier-info">http://h5-verify.mpoom.cn/ytx-api/v1.0.0/phone/carrier-info</a><br>Request Method: GET<br>Status Code: 404 Not Found<br>Remote Address: 106.54.197.193:80<br>Referrer Policy: no-referrer-when-downgrade</p>
</blockquote>
<p>Response Headers</p>
<blockquote>
<p>Connection: keep-alive<br>Content-Length: 315<br>Content-Type: text/html; charset=iso-8859-1<br>Date: Mon, 13 Jul 2020 09:24:37 GMT<br>Server: nginx/1.9.9</p>
</blockquote>
<p>Request Headers</p>
<blockquote>
<p>Accept: <em>/</em><br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q=0.9<br>Cache-Control: no-cache<br>Connection: keep-alive<br>Content-Type: application/json;charset=UTF-8<br>Host: h5-verify.mpoom.cn<br>Pragma: no-cache<br>Referer: <a href="http://h5-verify.mpoom.cn/phone-verify">http://h5-verify.mpoom.cn/phone-verify</a><br>User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36</p>
</blockquote>
<p>(2)preview</p>
<pre class="line-numbers language-none"><code class="language-none">Not Found
The requested URL &#x2F;ytx-api&#x2F;v1.0.0&#x2F;phone&#x2F;carrier-info was not found on this server.

Apache&#x2F;2.2.15 (CentOS) Server at h5-verify.mpoom.cn Port 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="1-3-Nginx-access-log日志"><a href="#1-3-Nginx-access-log日志" class="headerlink" title="1.3 Nginx access.log日志"></a>1.3 Nginx access.log日志</h2><pre class="line-numbers language-none"><code class="language-none">127.0.0.1 - - [13&#x2F;Jul&#x2F;2020:17:32:33 +0800] &quot;GET &#x2F;ytx-api&#x2F;v1.0.0&#x2F;phone&#x2F;carrier-info HTTP&#x2F;1.0&quot; 404 315 &quot;http:&#x2F;&#x2F;h5-verify.mpoom.cn&#x2F;phone-verify&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.116 Safari&#x2F;537.36&quot; &quot;183.238.58.120&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h1><p>在服务器上有类似反向代理配置，但都是可以正常访问的，唯一与上述配置有区别的是，能正常访问的被反向代理的应用和Nginx部署在同一台机器，而上述被反向代理的应用部署在一台公网服务器。<br>该问的主要原因在于配置反向代理时<code>proxy_set_header Host</code>的配置.</p>
<h2 id="2-1-Host定义"><a href="#2-1-Host定义" class="headerlink" title="2.1 Host定义"></a>2.1 Host定义</h2><blockquote>
<p>Host 请求头指明了请求将要发送到的服务器主机名和端口号。<br>组成：域名+端口号<br>例子：test.com:1998<br>如果没有包含端口号，会自动使用被请求服务的默认端口（比如HTTPS URL使用443端口，HTTP URL使用80端口）<br>所有HTTP/1.1 请求报文中必须包含一个Host头字段。对于缺少Host头或者含有超过一个Host头的HTTP/1.1 请求，可能会收到400（Bad Request）状态码。</p>
</blockquote>
<p><strong>http1.1中不能缺失host字段，但host字段可以是空值</strong><br>上述问题是由于web前端使用二级域名<code>h5-verify.mpoom.cn</code>去访问，被反向代理的应用接口部署在另外一台服务器并且使用了<code>www.139130.com</code>域名进行访问，上述反向代理配置将Host设置为了<code>h5-verify.mpoom.cn</code>，去访问远程应用接口时服务器时无法解析<code>h5-verify.mpoom.cn</code>返回404。</p>
<h1 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h1><blockquote>
<p>（1）解决方法一<br>修改反向代理中的Host配置</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">proxy_set_header Host &quot;www.139130.com&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>（2）解决方法二<br>注释掉nginx配置文件中的Host配置</p>
</blockquote>
<blockquote>
<p>参考文章：</p>
</blockquote>
<p><a href="https://zh.wikipedia.org/zh-hans/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5">https://zh.wikipedia.org/zh-hans/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5</a><br><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.23">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.23</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理HTTP header自定义参数丢失问题</title>
    <url>/2020/07/31/nginx/nginx-fan-xiang-dai-li-http-de-header-zi-ding-yi-can-shu-diu-shi-wen-ti/</url>
    <content><![CDATA[<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>客户内网服务器不能直接访问外网，需要通过一台跳板机才能访问外网，在跳板机安装Nginx反向代理外网接口服务，架构图如下：<br><img src="/2020/07/31/nginx/nginx-fan-xiang-dai-li-http-de-header-zi-ding-yi-can-shu-diu-shi-wen-ti/nginx_proxy_pass_architecture_diagram.png" alt="nginx反向代理结构图"><br>代理设置完成后，在联调过程中请求外网接口返回参数错误，但是外网环境下不经过Nginx代理直接访问外网接口则能正常访问，说明在经过Nginx代理时，部分参数丢失了。</p>
<h1 id="二、问题排查"><a href="#二、问题排查" class="headerlink" title="二、问题排查"></a>二、问题排查</h1><p>根据接口报错，定位到是HTTPheader中的一个自定义参数<code>client_id</code>参数经过Nginx代理时没有转发出去,问题出现在Nginx代理上。</p>
<blockquote>
<p>Nginx主配置文件nginx.conf内容如下</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">user  root;
worker_processes  1;

error_log  logs&#x2F;error.log;
error_log  logs&#x2F;error.log  notice;
error_log  logs&#x2F;error.log  info;

pid        logs&#x2F;nginx.pid;


events &#123;
    worker_connections  1024;
&#125;


http &#123;
    include       mime.types;
    default_type  application&#x2F;octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    access_log  logs&#x2F;access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  0;
    #keepalive_timeout  65;

    gzip  on;
    include &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;conf.d&#x2F;*.conf;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>Nginx代理配置内容如下:</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">server &#123;
    listen       9000;
    server_name  localhost;
 
    location &#x2F;mobile&#x2F;verify &#123;
        proxy_pass https:&#x2F;&#x2F;www.cmpassport.com&#x2F;openapi&#x2F;rs&#x2F;tokenValidate;
        proxy_read_timeout 60;
        proxy_connect_timeout 60;
        proxy_redirect off;
    
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过查阅文档得知，Nginx默认会忽略http header中带有下划线的参数：<br><img src="/2020/07/31/nginx/nginx-fan-xiang-dai-li-http-de-header-zi-ding-yi-can-shu-diu-shi-wen-ti/nginx-underscores-syntax.jpg" alt="Nginx Syntax"></p>
<h1 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h1><p>在nginx配置文件的http或server模块设置<code>underscores_in_headers</code>为<code>on</code>:</p>
<pre class="line-numbers language-none"><code class="language-none">#该属性默认为off，表示如果header name中包含下划线，则忽略掉。
underscores_in_headers on;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>更新配置文件后重启Nginx，问题解决。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx离线安装</title>
    <url>/2020/05/24/nginx/nginx-chi-xian-an-zhuang/</url>
    <content><![CDATA[<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><blockquote>
<p>服务器无法访问外网的情况下，Nginx只能离线安装，安装主要步骤如下：</p>
</blockquote>
<ul>
<li>安装gcc、g++</li>
<li>安装pcre、zlib</li>
<li>安装nginx</li>
</ul>
<h1 id="二、安装gcc、g"><a href="#二、安装gcc、g" class="headerlink" title="二、安装gcc、g++"></a>二、安装gcc、g++</h1><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gcc --version
g++ --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用<code>gcc --version</code> <code>g++ --version</code>查看服务器是否已经安装过<strong>gcc</strong>、**g++**。</p>
<h3 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h3><p>如果未安装，请下载<strong>gcc</strong>、**g++**及其依赖包进行安装，下面为Centos7 x86_64下 <strong>gcc</strong> 与 **g++ ** 4.8.5的依赖包:</p>
<blockquote>
<p>gcc依赖包详见:<a href="https://centos.pkgs.org/7/centos-x86_64/gcc-4.8.5-39.el7.x86_64.rpm.html">gcc-4.8.5-39.el7.x86_64.rpm</a> </p>
</blockquote>
<p><img src="/2020/05/24/nginx/nginx-chi-xian-an-zhuang/gcc-requires.png" alt="gcc 依赖包"></p>
<blockquote>
<p>g++依赖包详见：<a href="https://centos.pkgs.org/7/centos-x86_64/gcc-c++-4.8.5-39.el7.x86_64.rpm.html">gcc-c++-4.8.5-39.el7.x86_64.rpm</a></p>
</blockquote>
<p><img src="/2020/05/24/nginx/nginx-chi-xian-an-zhuang/g++_requires.png" alt="g++ 依赖包"></p>
<p>根据上述依赖包列表下载安装包，下载地址：<a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/">Centos Mirrors</a> 、 <a href="http://mirrors.aliyun.com/centos/7/os/x86_64/Packages/">阿里云</a> 、<a href="http://mirrors.163.com/centos/6/os/x86_64/Packages/">网易</a>,下载后的依赖包如下图所示：</p>
<p><img src="/2020/05/24/nginx/nginx-chi-xian-an-zhuang/gcc_g++_rpm%E5%AE%89%E8%A3%85%E5%8C%85.png" alt="gcc  g++ rpm安装包"></p>
<p>上述安装包已分享至天翼云盘<a href="https://cloud.189.cn/t/2M7vuyra6vM3">gcc g++ rpm安装包</a></p>
<blockquote>
<p><em><strong>注意</strong></em></p>
<p><em>上图下载的依赖包有一些是<code>gcc</code> <code>g++</code>依赖包列表中不存在的，是因为那部分安装包是<code>gcc</code> <code>g++</code> 依赖包的依赖包，这里参考网上下载了缺少的一些包</em></p>
</blockquote>
<h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><p>进入安装包下载路径</p>
<pre class="line-numbers language-none"><code class="language-none">rpm  -ivh  *.rpm --nodeps --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>–nodeps: do not verify package dependencies</p>
<p>–force:  short hand for –replacepkgs –replacefiles</p>
<p>–replacefiles : ignore file conflicts between packages</p>
<p>–replacepkgs: reinstall if the package is already present</p>
</blockquote>
<h3 id="2-3-检查"><a href="#2-3-检查" class="headerlink" title="2.3 检查"></a>2.3 检查</h3><p>执行<code>gcc --version</code> 、<code>g++ version</code>检测是否安装成功。</p>
<h1 id="三、安装pcre、zlib"><a href="#三、安装pcre、zlib" class="headerlink" title="三、安装pcre、zlib"></a>三、安装pcre、zlib</h1><p>Nginx的gzip模块需要zlib库，rewrite模块需要pcre库，ssl模块需要openssl库.</p>
<p>下载地址：<a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/">http://mirror.centos.org/centos/7/os/x86_64/Packages/</a></p>
<h2 id="3-1-安装pcre"><a href="#3-1-安装pcre" class="headerlink" title="3.1 安装pcre"></a>3.1 安装pcre</h2><p>检查服务器是否已经安装了<code>pcre</code>：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rpm -q pcre<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下载地址：<a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/pcre-8.32-17.el7.x86_64.rpm">http://mirror.centos.org/centos/7/os/x86_64/Packages/pcre-8.32-17.el7.x86_64.rpm</a></p>
<pre class="line-numbers language-none"><code class="language-none">rpm -ivh pcre-8.32-17.el7.x86_64.rpm --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>进入文件存放路径执行上述命令安装，最后执行<code>rpm -q pcre</code>检测是否安装成功。</p>
<h2 id="3-2-安装zlib"><a href="#3-2-安装zlib" class="headerlink" title="3.2 安装zlib"></a>3.2 安装zlib</h2><p>检查服务器是否已经安装<code>zlib</code></p>
<pre class="line-numbers language-none"><code class="language-none">rpm -q zlib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下载地址：<a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/zlib-1.2.7-18.el7.x86_64.rpm">http://mirror.centos.org/centos/7/os/x86_64/Packages/zlib-1.2.7-18.el7.x86_64.rpm</a></p>
<pre class="line-numbers language-none"><code class="language-none">rpm -ivh zlib-1.2.7-18.el7.x86_64.rpm --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>进入文件下载路径执行上面命令进行安装，最后执行<code>rpm -q zlib</code>检测是否安装成功。</p>
<h1 id="四、安装Nginx"><a href="#四、安装Nginx" class="headerlink" title="四、安装Nginx"></a>四、安装Nginx</h1><p>从<a href="https://nginx.org/">Nginx官网</a>下载<strong>Stable version</strong>，当前的Stable version为<code>nginx-1.18.0</code></p>
<p>下载地址：<a href="https://nginx.org/download/nginx-1.18.0.tar.gz">https://nginx.org/download/nginx-1.18.0.tar.gz</a></p>
<h2 id="3-1-编译安装"><a href="#3-1-编译安装" class="headerlink" title="3.1 编译安装"></a>3.1 编译安装</h2><pre class="line-numbers language-none"><code class="language-none">tar -zxvf nginx-1.18.0.tar.gz
cd nginx-1.18.0
.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx
make
make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下载解压后进入Nginx解压目录进行编译安装, 上面讲Nginx安装到了/usr/local/nginx目录下。</p>
<blockquote>
<p>查看Nginx版本</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3-2-配置环境变量"><a href="#3-2-配置环境变量" class="headerlink" title="3.2 配置环境变量"></a>3.2 配置环境变量</h2><p>编辑/etc/profile添加下面内容：</p>
<pre class="line-numbers language-none"><code class="language-none">export NGINX_HOME&#x3D; &#x2F;usr&#x2F;local&#x2F;nginx
export PATH&#x3D;$PATH:$NGINX_HOME&#x2F;sbin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>完成后执行<code>source /etc/profile</code>,之后就可以直接执行<code>nginx -v</code>查看Nginx版本。</p>
<h2 id="3-3-设置开机自启动"><a href="#3-3-设置开机自启动" class="headerlink" title="3.3 设置开机自启动"></a>3.3 设置开机自启动</h2><p>1、在系统服务目录里创建nginx.service文件</p>
<pre class="line-numbers language-none"><code class="language-none">vim  &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2、在文中添加下面内容</p>
<pre class="line-numbers language-none"><code class="language-none">[Unit]
Description&#x3D;nginx
After&#x3D;network.target
  
[Service]
Type&#x3D;forking
ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx
ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload
ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit
PrivateTmp&#x3D;true
  
[Install]
WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Description:描述服务<br>After:描述服务类别<br>[Service]服务运行参数的设置<br>Type=forking是后台运行的形式<br>ExecStart为服务的具体运行命令<br>ExecReload为重启命令<br>ExecStop为停止命令<br>PrivateTmp=True表示给服务分配独立的临时空间<br>注意：[Service]的启动、重启、停止命令全部要求使用绝对路径<br>[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</p>
</blockquote>
<p>3、设置开机自启动</p>
<pre class="line-numbers language-none"><code class="language-none">systemctl enable nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>至此Nginx的安装已经完成了。</p>
<h1 id="五、下载"><a href="#五、下载" class="headerlink" title="五、下载"></a>五、下载</h1><blockquote>
<p>Nginx离线安装下载：</p>
</blockquote>
<p><a href="https://cloud.189.cn/t/2M7vuyra6vM3">gcc、g++安装包</a></p>
<p><a href="https://cloud.189.cn/t/IZNN3yFVZZne">nginx离线安装包</a></p>
<p><em><strong>参考文章</strong></em></p>
<p><em><a href="%5Bhttps://linking.fun/2019/04/20/CentOS7%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Nginx/%5D(https://linking.fun/2019/04/20/CentOS7%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Nginx/)">CentOS7离线安装Nginx</a></em></p>
<p><em><a href="https://blog.csdn.net/qq_29480353/article/details/80006246">linux的离线安装nginx</a></em></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx负载均衡失败重试</title>
    <url>/2021/04/26/nginx/nginx-fu-zai-jun-heng-shi-bai-chong-shi/</url>
    <content><![CDATA[<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>在对一个接口进行反向代理时，nginx总是会打印error日志，但是请求是正常的。根据nginx的error日志，发现是请求到ipv6地址失败，但是最终的代理请求是成功的，所以接下来分析一下nginx的负载均衡及失败重试机制。</p>
<p>nginx配置文件如下：</p>
<pre class="line-numbers language-none"><code class="language-none">server &#123;
    listen       9000;
    server_name  localhost;
    #proxy_next_upstream off;
    location &#x2F;ncs&#x2F;telecom&#x2F;phone-verify &#123;
        proxy_pass https:&#x2F;&#x2F;open.e.189.cn&#x2F;auth&#x2F;verifyinfo.do;
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        proxy_redirect off;
    
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host &#39;open.e.189.cn&#39;;
        proxy_set_header X-Real-IP $remote_addr;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>nginx error日志内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">[error] 3587705#0: *3471 connect() to [240e:698:100::2]:443 failed (101: Network is unreachable) while connecting to upstream, client: 127.0.0.1, server: localhost, request: &quot;GET &#x2F;ncs&#x2F;telecom&#x2F;phone-verify HTTP&#x2F;1.1&quot;, upstream: &quot;https:&#x2F;&#x2F;[240e:698:100::2]:443&#x2F;auth&#x2F;verifyinfo.do&quot;, host: &quot;localhost:9000&quot;
[error] 3587705#0: *3471 connect() to [240e:698:100::4]:443 failed (101: Network is unreachable) while connecting to upstream, client: 127.0.0.1, server: localhost, request: &quot;GET &#x2F;ncs&#x2F;telecom&#x2F;phone-verify HTTP&#x2F;1.1&quot;, upstream: &quot;https:&#x2F;&#x2F;[240e:698:100::4]:443&#x2F;auth&#x2F;verifyinfo.do&quot;, host: &quot;localhost:9000&quot;
[error] 3587705#0: *3471 connect() to [240e:698:100::5]:443 failed (101: Network is unreachable) while connecting to upstream, client: 127.0.0.1, server: localhost, request: &quot;GET &#x2F;ncs&#x2F;telecom&#x2F;phone-verify HTTP&#x2F;1.1&quot;, upstream: &quot;https:&#x2F;&#x2F;[240e:698:100::5]:443&#x2F;auth&#x2F;verifyinfo.do&quot;, host: &quot;localhost:9000&quot;
[error] 3587705#0: *3471 connect() to [240e:698:100::3]:443 failed (101: Network is unreachable) while connecting to upstream, client: 127.0.0.1, server: localhost, request: &quot;GET &#x2F;ncs&#x2F;telecom&#x2F;phone-verify HTTP&#x2F;1.1&quot;, upstream: &quot;https:&#x2F;&#x2F;[240e:698:100::3]:443&#x2F;auth&#x2F;verifyinfo.do&quot;, host: &quot;localhost:9000&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="二、proxy-pass"><a href="#二、proxy-pass" class="headerlink" title="二、proxy_pass"></a>二、<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass">proxy_pass</a></h1><blockquote>
<p>Syntax:    proxy_pass URL;<br>Default:    —<br>Context:    location, if in location, limit_except</p>
</blockquote>
<p>Sets the protocol and address of a proxied server and an optional URI to which a location should be mapped. As a protocol, “http” or “https” can be specified. The address can be specified as a domain name or IP address, and an optional port:</p>
<blockquote>
<p>proxy_pass <a href="http://localhost:8000/uri/">http://localhost:8000/uri/</a>;</p>
</blockquote>
<p>or as a UNIX-domain socket path specified after the word “unix” and enclosed in colons:</p>
<blockquote>
<p>proxy_pass <a href="http://unix/tmp/backend.socket:/uri/">http://unix:/tmp/backend.socket:/uri/</a>;</p>
</blockquote>
<p>If a domain name resolves to several addresses, all of them will be used in a round-robin fashion. In addition, an address can be specified as a server group.</p>
<p>Parameter value can contain variables. In this case, if an address is specified as a domain name, the name is searched among the described server groups, and, if not found, is determined using a resolver.</p>
<p>根据<code>proxy_pass</code>的说明，我们的代理地址可以是域名或IP地址，如果地址是域名并且这个域名被解析到多个地址时，nginx以轮询的方式访问解析后的这些地址。<br>此外，可以将这个地址指定为一个server group，即我们的代理地址时一个域名的时候，域名解析后的地址将会被转换为一个<code>upstream</code>服务组，以默认轮询的方式提供服务。</p>
<p>代理地址的参数中可以包含变量，当代理地址被指定为一个域名的时候，则在描述的服务器组中搜索该名称，如果没有找到，则使用域名解析器确定。</p>
<h1 id="三、resolver"><a href="#三、resolver" class="headerlink" title="三、resolver"></a>三、<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver">resolver</a></h1><blockquote>
<p>Syntax:    resolver address … [valid=time] [ipv6=on|off] [status_zone=zone];<br>Default:    —<br>Context:    http, server, location</p>
</blockquote>
<p>Configures name servers used to resolve names of upstream servers into addresses, for example:</p>
<blockquote>
<p>resolver 127.0.0.1 [::1]:5353;</p>
</blockquote>
<p>The address can be specified as a domain name or IP address, with an optional port (1.3.1, 1.2.2). If port is not specified, the port 53 is used. Name servers are queried in a round-robin fashion.</p>
<blockquote>
<p>Before version 1.1.7, only a single name server could be configured. Specifying name servers using IPv6 addresses is supported starting from versions 1.3.1 and 1.2.2.</p>
</blockquote>
<p>By default, nginx will look up both IPv4 and IPv6 addresses while resolving. If looking up of IPv6 addresses is not desired, the ipv6=off parameter can be specified.</p>
<blockquote>
<p>Resolving of names into IPv6 addresses is supported starting from version 1.5.8.</p>
</blockquote>
<p>By default, nginx caches answers using the TTL value of a response. An optional valid parameter allows overriding it:</p>
<blockquote>
<p>resolver 127.0.0.1 [::1]:5353 valid=30s;</p>
</blockquote>
<p>通过<code>proxy_pass</code>的说明我们知道，在nginx中可以配置resolver对域名进行解析，并关闭ipv6的解析。</p>
<p>所以nginx代理的的配置文件如下：</p>
<pre class="line-numbers language-none"><code class="language-none">server &#123;
    listen       9000;
    server_name  localhost;
    resolver 114.114.114.114 valid&#x3D;60s ipv6&#x3D;off;
    
    location &#x2F;ncs&#x2F;telecom&#x2F;phone-verify &#123;
        set $telecom open.e.189.cn;
        proxy_pass https:&#x2F;&#x2F;$telecom&#x2F;auth&#x2F;verifyinfo.do;
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        proxy_redirect off;

        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host &#39;open.e.189.cn&#39;;
        proxy_set_header X-Real-IP $remote_addr;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过上述配置（注意：必须将<code>proxy_pass</code>参数中的域名设置为变量)，我们指定代理地址中的域名每间隔60s进行解析一次，解析时排除掉域名中的ipv6地址。</p>
<p>域名open.e.189.cn解析后的IP地址如下：</p>
<pre class="line-numbers language-none"><code class="language-none">[root@10-13-149-183 conf.d]# nslookup open.e.189.cn
Server:         10.13.255.1
Address:        10.13.255.1#53

Non-authoritative answer:
open.e.189.cn   canonical name &#x3D; open.e-189.21cn.com.
Name:   open.e-189.21cn.com
Address: 42.123.76.75
Name:   open.e-189.21cn.com
Address: 42.123.76.52
Name:   open.e-189.21cn.com
Address: 42.123.76.87
Name:   open.e-189.21cn.com
Address: 240e:698:100::3
Name:   open.e-189.21cn.com
Address: 240e:698:100::2
Name:   open.e-189.21cn.com
Address: 240e:698:100::5
Name:   open.e-189.21cn.com
Address: 240e:698:100::4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改nginx配置后重启，发现error日志中已经没有报错了，至此nginx代理请求ipv6报错的问题已经解决了。</p>
<p>前面我们看到，即使在nginx打印了请求ipv6的失败的情况下，但我们的请求最后仍是成功的，这是由于nginx的失败重试机制，接下来我们分析一下nginx的失败重试机制。</p>
<h1 id="四、upstream"><a href="#四、upstream" class="headerlink" title="四、upstream"></a>四、<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">upstream</a></h1><p>nginx的<code>ngx_http_upstream_module</code>的模块时用来定义一个服务组的，这个服务组可以被<code>proxy_pass</code>等模块引用。<br>前面在<code>proxy_pass</code>中提到，当我们的代理地址是一个域名的时候，域名解析后的地址将被转换位一个<code>upstream</code>服务组。<br><code>upstream</code>的配置示例如下：</p>
<pre class="line-numbers language-none"><code class="language-none">resolver 10.0.0.1;

upstream dynamic &#123;
    zone upstream_dynamic 64k;

    server backend1.example.com      weight&#x3D;5;
    server backend2.example.com:8080 fail_timeout&#x3D;5s slow_start&#x3D;30s;
    server 192.0.2.1                 max_fails&#x3D;3;
    server backend3.example.com      resolve;
    server backend4.example.com      service&#x3D;http resolve;

    server backup1.example.com:8080  backup;
    server backup2.example.com:8080  backup;
&#125;

server &#123;
    location &#x2F; &#123;
        proxy_pass http:&#x2F;&#x2F;dynamic;
        health_check;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>Syntax:    server address [parameters];<br>Default:    —<br>Context:    upstream</p>
</blockquote>
<ul>
<li><p>max_fails=number<br>sets the number of unsuccessful attempts to communicate with the server that should happen in the duration set by the fail_timeout parameter to consider the server unavailable for a duration also set by the fail_timeout parameter. By default, the number of unsuccessful attempts is set to 1. The zero value disables the accounting of attempts. What is considered an unsuccessful attempt is defined by the proxy_next_upstream, fastcgi_next_upstream, uwsgi_next_upstream, scgi_next_upstream, memcached_next_upstream, and grpc_next_upstream directives.</p>
</li>
<li><p>fail_timeout=time<br>sets the time during which the specified number of unsuccessful attempts to communicate with the server should happen to consider the server unavailable;<br>and the period of time the server will be considered unavailable.<br>By default, the parameter is set to 10 seconds.</p>
</li>
</ul>
<p>nginx默认使用轮询机制请求server group中服务，通过<code>max_fails</code>和<code>fail_timeout</code>两个参数控制<code>upstream</code>下的服务是否可用。<br>这个两个参数表示在<code>fail_timeout</code>时间内，一个服务累计的失败次数超过<code>max_fails</code>，则这个服务在接一下来的<code>fail_timeout</code>时间内不可用。<br><code>max_fails</code>默认值为1，设置为0表示不限制。<code>fail_timeout</code>默认值为10，即默认一个服务在10s内失败一次，则在接一下来的10s内，这个服务将变为不可用。</p>
<p>当server group中的一个server请求失败时，nginx的会进行失败重试，参见<code>proxy_next_upstream</code>模块。</p>
<h1 id="五、proxy-next-upstream"><a href="#五、proxy-next-upstream" class="headerlink" title="五、proxy_next_upstream"></a>五、<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream">proxy_next_upstream</a></h1><blockquote>
<p>Syntax:    proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off …;<br>Default:<br>proxy_next_upstream error timeout;<br>Context:    http, server, location</p>
</blockquote>
<p>Specifies in which cases a request should be passed to the next server:</p>
<ul>
<li>error<br>an error occurred while establishing a connection with the server, passing a request to it, or reading the response header;</li>
<li>timeout<br>a timeout has occurred while establishing a connection with the server, passing a request to it, or reading the response header;</li>
</ul>
<p>One should bear in mind that passing a request to the next server is only possible if nothing has been sent to a client yet. That is, if an error or timeout occurs in the middle of the transferring of a response, fixing this is impossible.</p>
<p>The directive also defines what is considered an unsuccessful attempt of communication with a server. The cases of error, timeout and invalid_header are always considered unsuccessful attempts, even if they are not specified in the directive. The cases of http_500, http_502, http_503, http_504, and http_429 are considered unsuccessful attempts only if they are specified in the directive. The cases of http_403 and http_404 are never considered unsuccessful attempts.</p>
<p>根据上述说明nginx遇到<code>error</code>、<code>timeout</code>等错误时，会下一个server进行重试。我们之前遇到的请求的ipv6的错误属于<code>errror</code>情况，nignx会进行重试。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据上述说明，我们对域名地址进行反向代理时，域名解析后的地址会被转为一个<code>upstream</code>的server group，并以轮询的方式进行访问；我们可以通过配置<code>resolver</code>来设置域名解析服务器地址、同时可以关闭ipv6的解析；<br>nginx对server group中的server进行访问时，会根据<code>max_fails</code>和<code>fail_timeout</code>连个参数判断服务是否可用，在server请求失败后，会根据错误类型判断是否使用下一个server进行失败重试。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass">Nginx官网——proxy_pass</a><br><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver">Nginx官网——resolver</a><br><a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">Nginx官网——upstream</a><br><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream">Nginx官网——proxy_next_upstream</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Nginx实现三级域名访问和https访问</title>
    <url>/2018/10/26/nginx/ji-yu-nginx-shi-xian-san-ji-yu-ming-fang-wen-he-https-fang-wen/</url>
    <content><![CDATA[<h1 id="Nginx实现三级域名访问"><a href="#Nginx实现三级域名访问" class="headerlink" title="Nginx实现三级域名访问"></a>Nginx实现三级域名访问</h1><p>我的VPS上部署了<a href="https://www.mpoom.cn/">MPOOM工作台</a>、<a href="http://blog.mpoom.cn/">个人博客</a>、<a href="http://m.mpoom.cn/">文件共享平台</a>三个系统，并且在阿里云平台购买了域名，想要通过nginx实现不同的三级域名访问不同的系统，例如：</p>
<ul>
<li><p>MPOOM工作台：<a href="http://www.mpoon.cn/">http://www.mpoon.cn</a></p>
</li>
<li><p>个人博客： <a href="http://blog.mpoom.cn/">http://blog.mpoom.cn</a></p>
</li>
<li><p>文件共享平台：<a href="http://m.mpoom.cn/">http://m.mpoom.cn</a></p>
</li>
</ul>
<p><em>ps：如果域名要解析到国内云服务器，域名要提前在工信部进行备案，但是如果解析到国外，则没有这个限制.</em></p>
<blockquote>
<p>配置文件mpoom.conf如下:</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none"># mpoom工作台
server &#123;
    listen       80;
    server_name  mpoom.cn www.mpoom.cn;
    location &#x2F; &#123;
        proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8090;
    &#125;
&#125;
# 个人博客
server &#123;
    listen       80;
    server_name  blog.mpoom.cn;

    set $root_path &quot;&#x2F;usr&#x2F;local&#x2F;webserver&#x2F;blog&#x2F;public&quot;;

    #charset koi8-r;
    access_log  &#x2F;home&#x2F;running&#x2F;blog&#x2F;blog-logs&#x2F;host.access.log;
    error_log  &#x2F;home&#x2F;running&#x2F;blog&#x2F;blog-logs&#x2F;error.log;
    # 个人博客系统是由hexo生成的静态页面
    location &#x2F; &#123;
        root   $root_path;
        index  index.html index.htm;
    &#125;
&#125;
# 文件共享平台
server &#123;
    listen       80;
    server_name  m.mpoom.cn;

    set $root_path &quot;&#x2F;home&#x2F;running&#x2F;web&#x2F;open-web&#x2F;&quot;;

    #charset koi8-r;
    access_log  &#x2F;home&#x2F;running&#x2F;web&#x2F;openweb-logs&#x2F;host.access.log;
    error_log  &#x2F;home&#x2F;running&#x2F;blog&#x2F;blog-logs&#x2F;error.log;

    location &#x2F; &#123;
        root   $root_path;
        index  index.html index.htm;
    &#125;

    location ~ ^&#x2F;service&#x2F; &#123;
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Cookie $http_cookie;
        proxy_cookie_path &#x2F;service&#x2F; &#x2F;;

        proxy_buffering off;
        proxy_connect_timeout 300s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        proxy_pass  http:&#x2F;&#x2F;127.0.0.1:9000;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>工作台和文件共享平台进行了前后端分离，且两者共用后台系统，前端使用nginx作为服务器，后台使用nginx作为反向代理服务器。</p>
<p>然后在nginx主配置文件nginx.conf的http模块引入上面mpoom.conf配置文件</p>
<pre class="line-numbers language-none"><code class="language-none">include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;mpoom.conf;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h1 id="Nginx实现https访问"><a href="#Nginx实现https访问" class="headerlink" title="Nginx实现https访问"></a>Nginx实现https访问</h1><p>为保障MPOOM工作台访问安全性，且在阿里云购可以购买免费的SSL证书，所以决定使用https来进行访问。</p>
<blockquote>
<p>Nginx服务器安装SSL证书步骤如下</p>
</blockquote>
<ul>
<li><p>在阿里云购买免费的SSL证书，验证通过后，下载Nginx版本证书。</p>
</li>
<li><p>进入nginx安装目录下的conf目录，在conf目录下创建cert目录，将下载解压后的证书上传到cert目录，下载到本地的证书压缩文件包解压后包含：</p>
<ul>
<li><strong>.crt</strong>文件：是证书文件，crt是pem文件的扩展名。</li>
<li><strong>.key</strong>文件：证书的私钥文件。</li>
</ul>
</li>
<li><p>在nginx配置文件的http模块下新增一个server模块,配置如下：</p>
<pre class="line-numbers language-none"><code class="language-none">server &#123;
    listen 443;
    server_name mpoom.cn;
    ssl on;
    ssl_certificate  cert&#x2F;***_www.mpoom.cn.pem;
    ssl_certificate_key cert&#x2F;***_www.mpoom.cn.key;
    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;

    location &#x2F; &#123;
        proxy_pass  http:&#x2F;&#x2F;127.0.0.1:8090;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>强制http跳转至https，将工作台的server模块更新为如下：</p>
<pre class="line-numbers language-none"><code class="language-none">server &#123;
    listen       80;
    server_name  mpoom.cn www.mpoom.cn;
    return 301 https:&#x2F;&#x2F;www.mpoom.cn$request_uri;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>重启nginx。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Forecasting Research on the Wireless Mesh Network Throughput Based on the Support Vector Machine</title>
    <url>/2017/12/26/paper/ji-yu-zhi-chi-xiang-liang-ji-de-wu-xian-mesh-wang-luo-tun-tu-liang-yu-ce/</url>
    <content><![CDATA[<h1 id="《基于支持向量机的无线Mesh网络吞吐量预测》-——-论文"><a href="#《基于支持向量机的无线Mesh网络吞吐量预测》-——-论文" class="headerlink" title="《基于支持向量机的无线Mesh网络吞吐量预测》 —— 论文"></a>《基于支持向量机的无线Mesh网络吞吐量预测》 —— 论文</h1><span id="more"></span>


	<div class="row">
    <embed src="./基于支持向量机的无线Mesh网络吞吐量预测.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵模式和集群模式</title>
    <url>/2020/12/25/redis/redis-shao-bing-mo-shi-he-ji-qun-mo-shi/</url>
    <content><![CDATA[<h1 id="一、Redis哨兵模式搭建"><a href="#一、Redis哨兵模式搭建" class="headerlink" title="一、Redis哨兵模式搭建"></a>一、Redis哨兵模式搭建</h1><h2 id="1-1-Redis-的-主从复制模式-和-Sentinel-高可用架构-的示意图"><a href="#1-1-Redis-的-主从复制模式-和-Sentinel-高可用架构-的示意图" class="headerlink" title="1.1 Redis 的 主从复制模式 和 Sentinel 高可用架构 的示意图"></a>1.1 Redis 的 主从复制模式 和 Sentinel 高可用架构 的示意图</h2><p><img src="/2020/12/25/redis/redis-shao-bing-mo-shi-he-ji-qun-mo-shi/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8F%8Asentinel%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="redis主从复制及sentinel高可用架构图"></p>
<h2 id="1-2-基于Docker换件搭建Redis哨兵模式"><a href="#1-2-基于Docker换件搭建Redis哨兵模式" class="headerlink" title="1.2 基于Docker换件搭建Redis哨兵模式"></a>1.2 基于Docker换件搭建Redis哨兵模式</h2><p>本次搭建Redis哨兵模式仅为测试使用，且因资源有限，在一台云主机上安装docker引擎，通过docker容器搭建哨兵模式。</p>
<h3 id="1-2-1-安装环境"><a href="#1-2-1-安装环境" class="headerlink" title="1.2.1 安装环境"></a>1.2.1 安装环境</h3><p>云主机配置：1核2G</p>
<p>所需软件及环境：docker， docker-compose， redis镜像</p>
<h3 id="1-2-2-Redis主从复制"><a href="#1-2-2-Redis主从复制" class="headerlink" title="1.2.2 Redis主从复制"></a>1.2.2 Redis主从复制</h3><p>创建docker-compose.yml配置文件：</p>
<blockquote>
<p>docker-compose.yml</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">version: &#39;3&#39;
services:
  master:
    image: redis
    container_name: redis-master
    command: redis-server --requirepass redis_hyk  --masterauth redis_hyk
    ports:
      - 6379:6379
  slave1:
    image: redis
    container_name: redis-slave-1
    ports:
      - 6380:6379
    command:  redis-server --slaveof 172.16.16.37 6379 --requirepass redis_hyk --masterauth redis_hyk --replica-announce-ip 172.16.16.37 --replica-announce-port 6380
  slave2:
    image: redis
    container_name: redis-slave-2
    ports:
      - 6381:6379
    command: redis-server --slaveof 172.16.16.37 6379 --requirepass redis_hyk --masterauth redis_hyk --replica-announce-ip 172.16.16.37 --replica-announce-port 6381<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意：使用dockers容器配置主从时，slave节点默认使用的时容器内部的ip，会导致在容器外部无法访问，可以通过以下配置指定ip及端口<br>详情参考：<a href="https://redis.io/topics/replication">Redis官网 Replication</a><br>replica-announce-ip 172.16.16.37<br>replica-announce-port 6380</p>
</blockquote>
<p>执行docker-compose up -d 启动容器。</p>
<h3 id="1-2-3-Redis-Sentinel"><a href="#1-2-3-Redis-Sentinel" class="headerlink" title="1.2.3 Redis Sentinel"></a>1.2.3 Redis Sentinel</h3><p>创建docker-compose.yml配置文件：</p>
<blockquote>
<p>docker-compose.yml</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">version: &#39;3&#39;
services:
  sentinel1:
    image: redis
    container_name: redis-sentinel-1
    ports:
      - 26379:26379
    command: redis-sentinel &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf
    volumes:
      - .&#x2F;sentinel1.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf
      - .&#x2F;26379&#x2F;:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;
  sentinel2:
    image: redis
    container_name: redis-sentinel-2
    ports:
    - 26380:26379
    command: redis-sentinel &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf
    volumes:
      - .&#x2F;sentinel2.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf
      - .&#x2F;26380&#x2F;:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;
  sentinel3:
    image: redis
    container_name: redis-sentinel-3
    ports:
      - 26381:26379
    command: redis-sentinel &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf
    volumes:
      - .&#x2F;sentinel3.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;sentinel.conf
      - .&#x2F;26381:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;
networks:
  default:
    external:
      name: redis_default
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>挂载Sentinel配置文件：</p>
<blockquote>
<p>sentinel1.conf</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">port 26379
dir &#x2F;tmp
# 172.18.0.3是redis的主节点ip
# 指示 Sentinel 去监视一个名为 mymaster 的主服务器， 这个主服务器的 IP 地址为 172.18.0.3 （docker inspect [containerIP]可以获取） 端口号为 6379
# 将这个主服务器判断为失效至少需要 2 个 Sentinel 同意 （只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）
sentinel monitor mymaster 172.18.0.3 6379 2
#
sentinel auth-pass mymaster redis_pwd
# 指定了 Sentinel 认为服务器已经断线所需的毫秒数。
sentinel down-after-milliseconds mymaster 30000
# 指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步，
# 这个数字越小， 完成故障转移所需的时间就越长。
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
sentinel deny-scripts-reconfig yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>PS:由于sentinel启动会对sentinel.conf文件做修改，我们启动了3个sentinel节点，所以配置文件需要复制3份分别对应每一个节点</p>
<p>执行docker-compose up -d 启动容器。</p>
<h3 id="1-2-4-验证"><a href="#1-2-4-验证" class="headerlink" title="1.2.4 验证"></a>1.2.4 验证</h3><p>查看docker容器状态：<br><img src="/2020/12/25/redis/redis-shao-bing-mo-shi-he-ji-qun-mo-shi/docker%E5%AE%B9%E5%99%A8%E7%8A%B6%E6%80%81.png" alt="docker容器状态"></p>
<p>查看Reids Master节点状态：<br><img src="/2020/12/25/redis/redis-shao-bing-mo-shi-he-ji-qun-mo-shi/Master%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81.png" alt="Master节点状态"></p>
<p>查看sentinel节点状态：<br><img src="/2020/12/25/redis/redis-shao-bing-mo-shi-he-ji-qun-mo-shi/sentinel%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81.png" alt="sentinel节点状态"><br><img src="/2020/12/25/redis/redis-shao-bing-mo-shi-he-ji-qun-mo-shi/sentinel%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%812.png" alt="sentinel节点状态2"></p>
<h2 id="1-3-Redis哨兵模式故障转移测试"><a href="#1-3-Redis哨兵模式故障转移测试" class="headerlink" title="1.3 Redis哨兵模式故障转移测试"></a>1.3 Redis哨兵模式故障转移测试</h2><h3 id="1-3-1-新建SpringBoot项目连接到Redis"><a href="#1-3-1-新建SpringBoot项目连接到Redis" class="headerlink" title="1.3.1 新建SpringBoot项目连接到Redis"></a>1.3.1 新建SpringBoot项目连接到Redis</h3><h4 id="创建一个SpringBoot项目，添加Redis依赖："><a href="#创建一个SpringBoot项目，添加Redis依赖：" class="headerlink" title="创建一个SpringBoot项目，添加Redis依赖："></a>创建一个SpringBoot项目，添加Redis依赖：</h4><pre class="line-numbers language-none"><code class="language-none">   &lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;
	&lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h4><pre class="line-numbers language-none"><code class="language-none">spring:
  redis:
    password: redis_hyk
    sentinel:
      master: mymaster
      nodes: 172.16.16.37:26379,172.16.16.37:26380,172.16.16.37:26381<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="在SpringBoot项目中持续进行写入操作"><a href="#在SpringBoot项目中持续进行写入操作" class="headerlink" title="在SpringBoot项目中持续进行写入操作"></a>在SpringBoot项目中持续进行写入操作</h4><pre class="line-numbers language-none"><code class="language-none">@Component
public class RedisService &#123;

    @Autowired
    private RedisTemplate&lt;String, String&gt; stringRedisTemplate;

    @PostConstruct
    public void writeRedis() &#123;
        DateTimeFormatter formatter &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        while(true) &#123;
            try &#123;
                String time &#x3D; ZonedDateTime.now().format(formatter);
                stringRedisTemplate.opsForValue().set(&quot;master-failover&quot;, time);
                Thread.sleep(1000);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="停止掉Redis的Master节点"><a href="#停止掉Redis的Master节点" class="headerlink" title="停止掉Redis的Master节点"></a>停止掉Redis的Master节点</h4><p><code>docker container stop 881</code></p>
<h4 id="SpringBoot项目日志输入"><a href="#SpringBoot项目日志输入" class="headerlink" title="SpringBoot项目日志输入"></a>SpringBoot项目日志输入</h4><pre class="line-numbers language-none"><code class="language-none">20:02:59.584  INFO 15128 --- [xecutorLoop-1-3] i.l.core.protocol.ConnectionWatchdog     : Reconnecting, last destination was &#x2F;172.16.16.37:6379
20:03:01.657  WARN 15128 --- [ioEventLoop-4-4] i.l.core.protocol.ConnectionWatchdog     : Cannot reconnect to [172.16.16.37:6379]: Connection refused: no further information: &#x2F;172.16.16.37:6379
20:03:05.957  INFO 15128 --- [xecutorLoop-1-2] i.l.core.protocol.ConnectionWatchdog     : Reconnecting, last destination was 172.16.16.37:6379
20:03:07.997  WARN 15128 --- [ioEventLoop-4-2] i.l.core.protocol.ConnectionWatchdog     : Cannot reconnect to [172.16.16.37:6379]: Connection refused: no further information: &#x2F;172.16.16.37:6379
20:03:12.464  INFO 15128 --- [xecutorLoop-1-4] i.l.core.protocol.ConnectionWatchdog     : Reconnecting, last destination was 172.16.16.37:6379
20:03:14.517  WARN 15128 --- [ioEventLoop-4-4] i.l.core.protocol.ConnectionWatchdog     : Cannot reconnect to [172.16.16.37:6379]: Connection refused: no further information: &#x2F;172.16.16.37:6379
20:03:19.659  INFO 15128 --- [xecutorLoop-1-2] i.l.core.protocol.ConnectionWatchdog     : Reconnecting, last destination was 172.16.16.37:6379
20:03:21.714  WARN 15128 --- [ioEventLoop-4-2] i.l.core.protocol.ConnectionWatchdog     : Cannot reconnect to [172.16.16.37:6379]: Connection refused: no further information: &#x2F;172.16.16.37:6379
20:03:26.961  INFO 15128 --- [xecutorLoop-1-2] i.l.core.protocol.ConnectionWatchdog     : Reconnecting, last destination was 172.16.16.37:6379
20:03:29.030  WARN 15128 --- [ioEventLoop-4-2] i.l.core.protocol.ConnectionWatchdog     : Cannot reconnect to [172.16.16.37:6379]: Connection refused: no further information: &#x2F;172.16.16.37:6379
20:03:33.167  INFO 15128 --- [xecutorLoop-1-4] i.l.core.protocol.ConnectionWatchdog     : Reconnecting, last destination was 172.16.16.37:6379
20:03:33.184  INFO 15128 --- [ioEventLoop-4-4] i.l.core.protocol.ReconnectionHandler    : Reconnected to 172.16.16.37:6381<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Sentinel节点日志输出"><a href="#Sentinel节点日志输出" class="headerlink" title="Sentinel节点日志输出"></a>Sentinel节点日志输出</h4><pre class="line-numbers language-none"><code class="language-none">04:01:34.181 # +sdown master mymaster 172.16.16.37 6379
04:01:34.309 # +new-epoch 1
04:01:34.325 # +vote-for-leader a1d392603fe93637b2194b0f67f38cf1946efdc2 1
04:01:35.280 # +odown master mymaster 172.16.16.37 6379 #quorum 3&#x2F;2
04:01:35.281 # Next failover delay: I will not start a failover before 04:07:35 2021
04:01:35.449 # +config-update-from sentinel a1d392603fe93637b2194b0f67f38cf1946efdc2 172.16.16.37 26380 @ mymaster 172.16.16.37 6379
04:01:35.449 # +switch-master mymaster 172.16.16.37 6379 172.16.16.37 6381
04:01:35.449 * +slave slave 172.16.16.37:6380 172.16.16.37 6380 @ mymaster 172.16.16.37 6381
04:01:35.449 * +slave slave 172.16.16.37:6379 172.16.16.37 6379 @ mymaster 172.16.16.37 6381
04:02:05.508 # +sdown slave 172.16.16.37:6379 172.16.16.37 6379 @ mymaster 172.16.16.37 6381
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据日志输出可以看到redis哨兵模式在3分内完成了故障转移操作。<br><code>sentinel failover-timeout mymaster 180000</code></p>
<h1 id="二、Redis集群模式搭建"><a href="#二、Redis集群模式搭建" class="headerlink" title="二、Redis集群模式搭建"></a>二、Redis集群模式搭建</h1><h2 id="2-1Redis集群模式架构图"><a href="#2-1Redis集群模式架构图" class="headerlink" title="2.1Redis集群模式架构图"></a>2.1Redis集群模式架构图</h2><p><img src="/2020/12/25/redis/redis-shao-bing-mo-shi-he-ji-qun-mo-shi/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Redis集群模式架构图"></p>
<p>Redis的集群实现方案：<br>(1)官方的 redis cluster 的方案<br>(2)类 codis 的架构</p>
<h2 id="2-2-虚拟机环境下搭建Redis集群模式"><a href="#2-2-虚拟机环境下搭建Redis集群模式" class="headerlink" title="2.2 虚拟机环境下搭建Redis集群模式"></a>2.2 虚拟机环境下搭建Redis集群模式</h2><h3 id="2-2-1-下载编译Redis"><a href="#2-2-1-下载编译Redis" class="headerlink" title="2.2.1 下载编译Redis"></a>2.2.1 下载编译Redis</h3><p>从redis官网下载Redis源码并进行编译。Redis官网：<a href="https://redis.io/download">https://redis.io/download</a></p>
<p>注意：在Centos7上编译Redis6.x需要gcc的版本在5.0以上，Centos7默认的gcc版本为4.8.5。gcc目前最新版本为9.3.1</p>
<h3 id="2-2-2-搭建Redis集群模式"><a href="#2-2-2-搭建Redis集群模式" class="headerlink" title="2.2.2 搭建Redis集群模式"></a>2.2.2 搭建Redis集群模式</h3><p>根据Redis官方文档，测试搭建Redis集群模式：</p>
<p>（1）手动创建redis.conf配置文件启动redis实例，最后通过redis-cli 的集群命令创建集群</p>
<p>（2）通过Redis源码包下的utils工具包下的脚本创建（脚本创建更方便，但是手动创建有助于了解集群创建的过程）</p>
<p>关于集群创建的操作步骤可以参考Redis的官方文档：<a href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial</a></p>
<h2 id="2-3-Redis集群总结"><a href="#2-3-Redis集群总结" class="headerlink" title="2.3 Redis集群总结"></a>2.3 Redis集群总结</h2><p>（1）Redis集群拓扑结构<br>Redis集群是一个网状结构，每个节点都通过TCP连接跟其它每个节点连接。</p>
<p>在一个有N个节点的集群中，每个节点都有N-1个流出的TCP连接和N-1个流入的TCP连接，这些TCP连接会永久保持，并不是按需创建的</p>
<p>（2）Redis 集群的数据分片<br>Redis集群的实现方案：</p>
<ul>
<li><p>客户端分区，代表为 Redis Sharding</p>
</li>
<li><p>代理分区方案，主流实现的有方案有 Twemproxy 和 Codis</p>
</li>
<li><p>查询路由方案，Redis默认实现方案。</p>
</li>
</ul>
<p>Redis 集群没有使用一致性hash, 而是引入了 哈希槽的概念.</p>
<p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<p>节点 A 包含 0 到 5500号哈希槽.<br>节点 B 包含5501 到 11000 号哈希槽.<br>节点 C 包含11001 到 16384号哈希槽.<br>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
<p>（3）Redis集群的主从复制模型<br>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<p>在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.</p>
<p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了</p>
<p>不过当B和B1 都失败后，集群是不可用的.</p>
<p>（4）Redis集群的一致性保证<br>Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p>
<p>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<p>客户端向主节点B写入一条命令.<br>主节点B向客户端回复命令状态.<br>主节点将写操作复制给他得从节点 B1, B2 和 B3.<br>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p>
<p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p>
<p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项。</p>
<p>（5）Redis集群在线重配置<br>Redis 集群支持在集群运行过程中添加或移除节点。实际上，添加或移除节点都被抽象为同一个操作，那就是把哈希槽从一个节点移到另一个节点。</p>
<p>向集群添加一个新节点，就是把一个空节点加入到集群中并把某些哈希槽从已存在的节点移到新节点上。<br>从集群中移除一个节点，就是把该节点上的哈希槽移到其他已存在的节点上。<br>所以实现这个的核心是能把哈希槽移来移去。从实际角度看，哈希槽就只是一堆键，所以 Redis 集群在重组碎片（reshard）时做的就是把键从一个节点移到另一个节点。<br>为了理解这是怎么工作的，我们需要介绍 CLUSTER 的子命令，这些命令是用来操作 Redis 集群节点上的哈希槽转换表（slots translation table）。</p>
<p>以下是可用的子命令：</p>
<p>CLUSTER ADDSLOTS slot1 [slot2] … [slotN]<br>CLUSTER DELSLOTS slot1 [slot2] … [slotN]<br>CLUSTER SETSLOT slot NODE node<br>CLUSTER SETSLOT slot MIGRATING node<br>CLUSTER SETSLOT slot IMPORTING node<br>头两个命令，ADDSLOTS 和 DELSLOTS，就是简单地用来给一个 Redis 节点指派（assign）或移除哈希槽。 在哈希槽被指派后，节点会将这个消息通过 gossip 协议向整个集群传播。ADDSLOTS 命令通常是用于在一个集群刚建立的时候快速给所有节点指派哈希槽。<br>当 SETSLOT 子命令使用 NODE 形式的时候，用来给指定 ID 的节点指派哈希槽。 除此之外哈希槽能通过两个特殊的状态来设定，MIGRATING 和 IMPORTING：</p>
<p>当一个槽被设置为 MIGRATING，原来持有该哈希槽的节点仍会接受所有跟这个哈希槽有关的请求，但只有当查询的键还存在原节点时，原节点会处理该请求，否则这个查询会通过一个 -ASK 重定向（-ASK redirection）转发到迁移的目标节点。<br>当一个槽被设置为 IMPORTING，只有在接受到 ASKING 命令之后节点才会接受所有查询这个哈希槽的请求。如果客户端一直没有发送 ASKING 命令，那么查询都会通过 -MOVED 重定向错误转发到真正处理这个哈希槽的节点那里。<br>这么讲可能显得有点奇怪，现在我们用实例让它更清晰些。假设我们有两个 Redis 节点，称为 A 和 B。我们想要把哈希槽 8 从 节点A 移到 节点B，所以我们发送了这样的命令：</p>
<p>我们向 节点B 发送：CLUSTER SETSLOT 8 IMPORTING A<br>我们向 节点A 发送：CLUSTER SETSLOT 8 MIGRATING B<br>其他所有节点在每次被询问到的一个键是属于哈希槽 8 的时候，都会把客户端引向节点”A”。具体如下：</p>
<p>所有关于已存在的键的查询都由节点”A”处理。<br>所有关于不存在于节点 A 的键都由节点”B”处理。<br>这种方式让我们可以不用在节点 A 中创建新的键。同时，一个叫做 redis-trib 的特殊客户端，它也是 Redis 集群的配置程序（configuration utility），会确保把已存在的键从节点 A 移到节点 B。这通过以下命令实现：</p>
<p>CLUSTER GETKEYSINSLOT slot count<br>上面这个命令会返回指定的哈希槽中 count 个键。对于每个返回的键，redis-trib 向节点 A 发送一个 MIGRATE 命令，这样会以原子性的方式（在移动键的过程中两个节点都被锁住，以免出现竞争状况）把指定的键从节点 A 移到节点 B。以下是 MIGRATE 的工作原理：</p>
<p>MIGRATE target_host target_port key target_database id timeout<br>执行 MIGRATE 命令的节点会连接到目标节点，把序列化后的 key 发送过去，一旦收到 OK 回复就会从它自己的数据集中删除老的 key。所以从一个外部客户端看来，在某个时间点，一个 key 要不就存在于节点 A 中要不就存在于节点 B 中。</p>
<p>在 Redis 集群中，不需要指定一个除了 0 号之外的数据库，但 MIGRATE 命令能用于其他跟 Redis 集群无关的的任务，所以它是一个足够通用的命令。MIGRATE 命令被优化了，使得即使在移动像长列表这样的复杂键仍然能做到快速。 不过当在重配置一个拥有很多键且键的数据量都很大的集群的时候，这个过程就并不那么好了，对于使用数据库的应用程序来说就会有延时这个限制。</p>
<p>（6）Redis集群失效检测<br>Redis 集群失效检测是用来识别出大多数节点何时无法访问某一个主节点或从节点。当这个事件发生时，就提升一个从节点来做主节点；若如果无法提升从节点来做主节点的话，那么整个集群就置为错误状态并停止接收客户端的查询。</p>
<p>每个节点都有一份跟其他已知节点相关的标识列表。其中有两个标识是用于失效检测，分别是 PFAIL 和 FAIL。PFAIL 表示可能失效（Possible failure），这是一个非公认的（non acknowledged）失效类型。FAIL 表示一个节点已经失效，而且这个情况已经被大多数主节点在某段固定时间内确认过的了。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://redis.io/topics/cluster-tutorial">https://redis.io/topics/cluster-tutorial</a></p>
<p><a href="https://juejin.cn/post/6850418118721077261">docker-compose快速搭建redis哨兵模式高可用集群</a></p>
<p><a href="https://juejin.cn/post/6844903663362637832">深入剖析Redis系列(二) - Redis哨兵模式与高可用集群</a></p>
<p><a href="https://msd.misuland.com/pd/3255817928875971830">redis cluster集群模式总结</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>哨兵模式</tag>
        <tag>集群模式</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么Redis集群使用16384个哈希槽</title>
    <url>/2020/12/30/redis/wei-shi-me-redis-ji-qun-shi-yong-16384-ge-ha-xi-cao/</url>
    <content><![CDATA[<h1 id="一、Redis集群特点"><a href="#一、Redis集群特点" class="headerlink" title="一、Redis集群特点"></a>一、Redis集群特点</h1><h2 id="1-1-Redis集群拓扑结构"><a href="#1-1-Redis集群拓扑结构" class="headerlink" title="1.1 Redis集群拓扑结构"></a>1.1 Redis集群拓扑结构</h2><p>Redis集群是一个网状结构，每个节点都通过TCP连接跟其它每个节点连接。</p>
<p>在一个有N个节点的集群中，每个节点都有N-1个流出的TCP连接和N-1个流入的TCP连接，这些TCP连接会永久保持，并不是按需创建的。</p>
<h2 id="1-2-Redis集群数据分片"><a href="#1-2-Redis集群数据分片" class="headerlink" title="1.2 Redis集群数据分片"></a>1.2 Redis集群数据分片</h2><h3 id="Redis集群的实现方案："><a href="#Redis集群的实现方案：" class="headerlink" title="Redis集群的实现方案："></a>Redis集群的实现方案：</h3><ul>
<li><p>客户端分区，代表为 Redis Sharding</p>
</li>
<li><p>代理分区方案，主流实现的有方案有 Twemproxy 和 Codis</p>
</li>
<li><p>查询路由方案，Redis默认实现方案。</p>
</li>
</ul>
<h2 id="1-3-Redis-集群没有使用一致性hash-而是引入了-哈希槽的概念"><a href="#1-3-Redis-集群没有使用一致性hash-而是引入了-哈希槽的概念" class="headerlink" title="1.3 Redis 集群没有使用一致性hash, 而是引入了 哈希槽的概念."></a>1.3 Redis 集群没有使用一致性hash, 而是引入了 哈希槽的概念.</h2><p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<p>节点 A 包含 0 到 5500号哈希槽.<br>节点 B 包含5501 到 11000 号哈希槽.<br>节点 C 包含11001 到 16384号哈希槽.<br>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。</p>
<h1 id="二、为什么Redis的集群使用16384个哈希槽？"><a href="#二、为什么Redis的集群使用16384个哈希槽？" class="headerlink" title="二、为什么Redis的集群使用16384个哈希槽？"></a>二、为什么Redis的集群使用16384个哈希槽？</h1><p>这个问题Redis的作者又在github的issue中解释过，我们看一下原文：<a href="https://github.com/redis/redis/issues/2576">原文地址</a></p>
<blockquote>
<p>why redis-cluster use 16384 slots? crc16() can have 2^16 -1=65535 different remainders。</p>
</blockquote>
<blockquote>
<p>The reason is:</p>
<ol>
<li>Normal heartbeat packets carry the full configuration of a node, that can be replaced in an idempotent way with the old in order to update an old config. This means they contain the slots configuration for a node, in raw form, that uses 2k of space with16k slots, but would use a prohibitive 8k of space using 65k slots.</li>
<li>At the same time it is unlikely that Redis Cluster would scale to more than 1000 mater nodes because of other design tradeoffs.<br>So 16k was in the right range to ensure enough slots per master with a max of 1000 maters, but a small enough number to propagate the slot configuration as a raw bitmap easily. Note that in small clusters the bitmap would be hard to compress because when N is small the bitmap would have slots/N bits set that is a large percentage of bits set.</li>
</ol>
</blockquote>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>从上面Redis的集群拓扑架构中我们知道，Redis集群节点是通过gossip协议进行点对点通信的，每个节点都会与集群中的其它节点进行通信，我们先看一下Redis心跳包的数据结构。</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct &#123;
    char sig[4];        &#x2F;* Signature &quot;RCmb&quot; (Redis Cluster message bus). *&#x2F;
    uint32_t totlen;    &#x2F;* Total length of this message *&#x2F;
    uint16_t ver;       &#x2F;* Protocol version, currently set to 1. *&#x2F;
    uint16_t port;      &#x2F;* TCP base port number. *&#x2F;
    uint16_t type;      &#x2F;* Message type *&#x2F;
    uint16_t count;     &#x2F;* Only used for some kind of messages. *&#x2F;
    uint64_t currentEpoch;  &#x2F;* The epoch accordingly to the sending node. *&#x2F;
    uint64_t configEpoch;   &#x2F;* The config epoch if it&#39;s a master, or the last
                               epoch advertised by its master if it is a
                               slave. *&#x2F;
    uint64_t offset;    &#x2F;* Master replication offset if node is a master or
                           processed replication offset if node is a slave. *&#x2F;
    char sender[CLUSTER_NAMELEN]; &#x2F;* Name of the sender node *&#x2F;
    unsigned char myslots[CLUSTER_SLOTS&#x2F;8];
    char slaveof[CLUSTER_NAMELEN];
    char myip[NET_IP_STR_LEN];    &#x2F;* Sender IP, if not all zeroed. *&#x2F;
    char notused1[34];  &#x2F;* 34 bytes reserved for future usage. *&#x2F;
    uint16_t cport;      &#x2F;* Sender TCP cluster bus port *&#x2F;
    uint16_t flags;      &#x2F;* Sender node flags *&#x2F;
    unsigned char state; &#x2F;* Cluster state from the POV of the sender *&#x2F;
    unsigned char mflags[3]; &#x2F;* Message flags: CLUSTERMSG_FLAG[012]_... *&#x2F;
    union clusterMsgData data;
&#125; clusterMsg;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>消息头里面有个myslots的char数组，长度为16383/8，这其实是一个bitmap,每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点的。</p>
<p>在Redis的心跳包携带了节点的全部配置信息，我们可以方便的去更新一个旧节点的全部信息。在心跳包中包含了为这个节点配置的全部哈希槽信息，他是一个位图数据结构。<br>（1）如果使用16384个哈希槽，则这个字段大小为2KB，如果使用65535个哈希槽，则将占用8KB的空间。<br>而且由于其它设计上的权衡，一个Redis集群的规模不可能超过1000个节点。<br>（2）因此16384个哈希槽能确保一个Redis集群上的每个主节点分配到足够的哈希槽；而且16384个哈希槽足够小，可以将节点配置的哈希槽作为原始位图进行传输。<br>而且由于在Redis集群规模较小时，由于每个节点分配的哈希槽会比较多，位图很难被压缩。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么用“福格行为模型”战胜拖延症?</title>
    <url>/2021/09/23/reprint/zen-me-yong-fu-ge-xing-wei-mo-xing-zhan-sheng-tuo-yan-zheng/</url>
    <content><![CDATA[<blockquote>
<p>说明：本文转载自 <a href="https://www.ljsw.io/dedao/2021-01-11/AsH.html">怎么用“福格行为模型”战胜拖延症？</a></p>
</blockquote>
<p>去年年底，我们有一期节目是讨论新年该立一个什么样的flag才人间值得，当时我给你的提议是：立一个不光自己变好，也要让别人从中受益的flag。</p>
<p>老实说，设定这样一个目标并不难，难的是如何完成它。我看到一个说法很有意思，说当代人立flag的现状是“今年立的flag，就是完成去年承诺的、前年没做到的、大前年立下的flag”，你说说，这让人情何以堪啊。于是，有人干脆就不敢定目标了，怕打脸。</p>
<p>到底是什么阻碍我们完成这些目标呢？除了客观原因之外，我想最大的拦路虎就是拖延症了。我身边很多朋友都饱受拖延症的困扰，包括我自己。明明是重要的事，也制定了计划，却总是无法按时完成。更可怕的是，打脸多了，自我评价变低，还容易掉入负面情绪的旋涡。</p>
<p>要怎么打败拖延症呢？我最近在36氪的神译局栏目里看到一篇文章，很受启发。文章来自一个国外专门研究拖延症的网站，叫Deprocrastination，标题是《如何用福格行为模型治疗拖延症》（How to stop procrastinating by using the Fogg Behavior Model）。读完这篇文章之后，我突然明白了拖延症的“底层逻辑”，也对如何应对它有了清晰的思路。在今天的《邵恒头条》中，我就把我从这篇文章中得到的收获分享给你。</p>
<p>你一定注意到了，文章的标题叫“如何用福格行为模型治疗拖延症”。那什么是福格行为模型呢？这个行为模型是美国斯坦福大学的教授布莱恩·福格（Brian Fogg）提出来的，所以是以他的名字命名的。福格行为模型的主要用途，是用来解释人们为什么会做出某种行为，比如“为什么你会早起跑步？”当然，它也能用来解释人们为什么没有做出某种行为，比如“你本来计划早起跑步，今天却没去，为什么？”对于这两类问题，福格行为模型都能给出合理的解释。</p>
<p>在互联网领域，福格行为模型常被用来设计引导用户行为。你可能听说过尼尔·埃亚尔的那本著名的《上瘾：让用户养成使用习惯的四大产品逻辑》，这本书的理论基础，就是福格行为模型。</p>
<p>简单来说，福格行为模型可以用一个公式来表示：行为=动机+能力+触发（Behavior=Motivation+Ability+Trigger）。 </p>
<p>从这个公式中你就可以看出，人的行为背后有三大要素：一个是动机，也就是做这件事的理由或目的；一个是能力，你得有能力完成这个行为才行；还有一个是触发，也就是在某个时刻促使人们采取行动的信号。要想使人们完成特定的行为，“动机”、“能力”、“触发”这三个要素缺一不可。</p>
<p>那你可能想问，福格行为模型和拖延症又有什么关系呢？其实，福格行为模型给了我们理解和分析拖延症的一个抓手。毕竟，拖延也是一种“行为”，那么它就可以被拆解成“动机”、“能力”和“触发”三个环节。你可以把它们想象成三根“链条”，任何一根链条断了，都会导致拖延发生。</p>
<p>这么说有点抽象，我举一些具体的例子。先来说第一根断掉的链条：动机。</p>
<p>不知道你有没有发现，我们拖延的事并不是什么小事，往往还挺重要的。比如说，你要写毕业论文，这关乎到你能不能顺利毕业；你想要瘦身，因为以前的衣服已经穿不进去了；你计划新的一年在知识城邦上多做分享，将来能成为“粉丝”过万的大V。这些都是对你来说重要的事，可问题是，当你把这些事放进待办列表之后，你的动机就不再像最开始那么强烈了。</p>
<p>不信，你回忆一下，有多少次你麻木地盯着待办事项列表，却发现找不到一件让自己感到兴奋，想马上就动手去做的事？随着时间的推移，你的动机会不断地被稀释淡化。</p>
<p>那该怎么办呢？最佳的解决方案，就是重新帮自己建立动机。你可以找出一件自己一直在拖延的事，想想当初为什么要计划做这件事，让自己再一次直观地感受到这件事的价值和意义。</p>
<p>这里有一个小窍门：尽量把这件事和个人收益关联起来。比如说，做完它能让你获得什么好处？你的个人能力会提升吗？未来会因此得到更多的机会吗？这件事有可能帮助到更多人吗？别人看到你穿着好看的衣服，会向你投来钦佩或羡慕的眼光吗？想得越细致，你的动机就会越明确，也就会感到越兴奋，动力越足。</p>
<p>好，这就是从动机上应对拖延的方法。再来说第二根断掉的链条：能力。</p>
<p>如果一项任务看起来特别难，你就不愿意做了，至少不愿意马上做。你有没有这种体会，做一件困难的事情时会特别容易分心。手机一有新消息提示就恨不得马上拿起来，干一会儿活就不自觉地打开购物网站刷一刷。这是为什么呢？</p>
<p>原因就出在能力上。从能力上来说，分心比工作要简单多了。工作你要耗费很多脑细胞，但回微信你只需要拿起手机就好了。人会本能地回避困难的事情，去做简单的事情。</p>
<p>更可怕的是，研究发现，你越不常做某事，就会越觉得它难。打个比方，如果日拱一卒，你会觉得每一步都比较轻松，但要是全憋到最后，那你就会觉得自己必须要下一盘大棋，无从下手了。</p>
<p>那该怎么办呢？你得学会把工作变简单。最好的方式就是拆分任务：把大任务拆分成若干个小任务，这样就能降低整体任务的难度。</p>
<p>如果你面对的只是一个小任务，那就不会觉得那么难了。比如爬山，爬到山顶很难，但先爬到50级台阶并不难；写完一篇上万字的论文很难，但先写出三个段落并不难；一下子瘦20斤很难，但上一次跑步机，跑个半小时并不难；成为知识城邦大V很难，但发一篇读书笔记并不难。而每完成一件这样的小任务，都会带给你信心和能量，让你更愿意把剩下的任务完成。</p>
<p>同时，你还需要做一个时间表，把所有的小任务串联起来。这里有一个小技巧是：倒推。也就是说，先写好最后一天要完成的任务，然后往回倒推，依次写下每一个时间点完成的小任务，一直写到今天为止。</p>
<p>举个例子，你要做一次公众演讲，一共有10天的准备时间，那时间表就要从第10天开始列，比如：</p>
<p>第10天：完整排练三次</p>
<p>第9天：熟练背诵整篇演讲稿</p>
<p>第8天：做完PPT，和文稿对照，确定翻页的时间点</p>
<p>……</p>
<p>第3天：先写出开头</p>
<p>第2天：收集和整理所有可用素材</p>
<p>第1天：理清演讲目的，构思结构框架</p>
<p>用“倒推”的方式设计时间表，你会更合理地安排小任务，不会出现到最后几天任务量积压的情况。</p>
<p>这是从能力上应对拖延的办法。再来说第三根断掉的链条：触发。</p>
<p>有时候，我们有充分的动机，也把任务拆好了，可还有会拖延，那原因就可能出在“触发不够”上。</p>
<p>触发，是提醒我们当下马上行动的信号。比如说，你这几天要交一份报告，结果突然接到老板一条信息说“报告写完了吗？写完赶紧发给我，我等着用”。本来你还想拖一拖，结果一接到老板的这条信息，屁股一下就从沙发上弹起来了。你看，这条信息就是一个触发，它会让你立即行动起来。可是，触发也不能光靠老板啊，要战胜拖延的毛病，你要学会主动设置触发信号。</p>
<p>什么样的触发最有效呢？文章里给了一个妙招：设置连锁触发。</p>
<p>第一个触发，是用手机设置一个定时提醒，让自己在设定好的时刻在办公桌前坐下来。你可能并没想好做什么，没关系，先坐下来。</p>
<p>第二个触发，就是倒计时5分钟，在5分钟之内盯着待办事项列表，挑出一项任务来做。如果5分钟计时结束，你仍然没决定做哪项任务的话，那就随机选择一项任务，立即去做。</p>
<p>通过连锁触发，你能快速让自己投入到工作状态中。</p>
<p>还有一种触发，是增加你“看见”任务的概率。什么意思呢？举个例子，假如你要制定春节假期的旅行计划，那得提前订机票啊，是吧。为了让自己不拖延，你可以下载一张飞机图片，设成手机壁纸。这样每次你拿起手机，就会看到飞机的图片，然后就会想起要赶紧订机票——这就是一种增加看见概率的触发。</p>
<p>除此之外，你还可以反过来，用减少触发的方式来提升专注力。比如说，在工作的时候，把手机放在别的房间或者打开勿扰模式；关闭微信电脑端的新消息通知；把工作用的软件全屏，这样就看不到其他软件的图标……你看，这些做法都是减少或消除导致分心的触发。你越难分心，也就越不会分心。</p>
<p>好了，总结一下，在今天的《邵恒头条》中，我跟你分享了如何用福格行为模型来分析和治疗拖延症。按照这个模型，拖延症可以被拆分为三个因素：动机不足、能力欠缺以及触发不够。很多人会认为拖延症就是自律性不强导致的，所以每次拖延都很自责。而这篇文章的启发在于，拖延症是个系统问题，它和人固有的行为模式有着密切的关系，你没必要苛责自己。你需要做的，是聪明地调整做事的方法。</p>
<p>今后当你拖延的时候，不妨想一想，到底是动机、能力和触发哪个环节出了问题？然后对症下药，制定应对策略。欢迎你把你的思考分享在留言区。</p>
<p>好了，这就是今天的《邵恒头条》。我是邵恒，我们明天见。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>福格行为模型</tag>
        <tag>拖延症</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ中ConsumeFromWhere详解</title>
    <url>/2021/09/06/rockermq/rocketmq-zhong-consumefromwhere-xiang-jie/</url>
    <content><![CDATA[<h1 id="一、ConsumeFromWhere"><a href="#一、ConsumeFromWhere" class="headerlink" title="一、ConsumeFromWhere"></a>一、ConsumeFromWhere</h1><p>RocketMQ的Consumer有一个<code>consumeFromWhere</code>属性，表示Consumer启动后将从哪个位置开始消费消息，该属性取值有以下情况：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Consuming point on consumer booting. There are three consuming points:
 * CONSUME_FROM_LAST_OFFSET: consumer clients pick up where it stopped previously. If it were a newly booting up consumer client, according aging of the consumer group, there are two cases:
 * if the consumer group is created so recently that the earliest message being subscribed has yet expired, which means the consumer group represents a lately launched business, consuming will start from the very beginning;
 * if the earliest message being subscribed has expired, consuming will start from the latest messages, meaning messages born prior to the booting timestamp would be ignored.
 * CONSUME_FROM_FIRST_OFFSET: Consumer client will start from earliest messages available.
 * CONSUME_FROM_TIMESTAMP: Consumer client will start from specified timestamp, which means messages born prior to consumeTimestamp will be ignored
 */</span>
<span class="token keyword">private</span> <span class="token class-name">ConsumeFromWhere</span> consumeFromWhere <span class="token operator">=</span> <span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span>CONSUME_FROM_LAST_OFFSET<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><p>consumeFromWhere在使用过程中，发现设置CONSUME_FROM_LAST_OFFSET后，有些情况仍然从头开始消费，接下来结合源码分析一下consumeFromWhere处理逻辑。</p>
<h2 id="2-1-RocketMQ客户端consumeFromWhere处理逻辑"><a href="#2-1-RocketMQ客户端consumeFromWhere处理逻辑" class="headerlink" title="2.1 RocketMQ客户端consumeFromWhere处理逻辑"></a>2.1 RocketMQ客户端consumeFromWhere处理逻辑</h2><p>Consumer启动是调用<code>computePullFromWhere(MessageQueue mq)</code>方法获取offset，以下为该方法的源码实现：<br><code>org.apache.rocketmq.client.impl.consumer.RebalancePushImpl.java</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">computePullFromWhere</span><span class="token punctuation">(</span><span class="token class-name">MessageQueue</span> mq<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ConsumeFromWhere</span> consumeFromWhere <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMQPushConsumerImpl<span class="token punctuation">.</span><span class="token function">getDefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConsumeFromWhere</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">OffsetStore</span> offsetStore <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMQPushConsumerImpl<span class="token punctuation">.</span><span class="token function">getOffsetStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>consumeFromWhere<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">case</span> CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST<span class="token operator">:</span>
        <span class="token keyword">case</span> CONSUME_FROM_MIN_OFFSET<span class="token operator">:</span>
        <span class="token keyword">case</span> CONSUME_FROM_MAX_OFFSET<span class="token operator">:</span>
        <span class="token keyword">case</span> CONSUME_FROM_LAST_OFFSET<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
            
            <span class="token comment">// 从broker获取消费者组的offset，此时分为两种情况</span>
            <span class="token comment">// 1. 该消费者组之前已经存在，则broker返回该消费者组的最后的offset，此时offset > 0</span>
            <span class="token comment">// 2. 如果是一个新的消费者组，则又分为两种情况：</span>
            <span class="token comment">// 2.1 如果消费者组订阅的消息仍在broker的内存中,则broker返回offset=0</span>
            <span class="token comment">// 2.2 如果消费者组订阅的消息不在broker的内存中，则broker返回未查找到，客户端将offset设置为-1</span>
            <span class="token keyword">long</span> lastOffset <span class="token operator">=</span> offsetStore<span class="token punctuation">.</span><span class="token function">readOffset</span><span class="token punctuation">(</span>mq<span class="token punctuation">,</span> <span class="token class-name">ReadOffsetType</span><span class="token punctuation">.</span>READ_FROM_STORE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token comment">// 消费者组之前已经存在（offset>0),或新消费者组且订阅的历史消息仍存在broker内存中（offset=0)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lastOffset <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> lastOffset<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            
            <span class="token comment">// 新消费者组且历史消息不在broker的内存中</span>
            <span class="token comment">// First start,no offset</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> lastOffset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>mq<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">MixAll</span><span class="token punctuation">.</span>RETRY_GROUP_TOPIC_PREFIX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    result <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    <span class="token comment">// 从最新的消息开始消费</span>
                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                        result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mQClientFactory<span class="token punctuation">.</span><span class="token function">getMQAdminImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxOffset</span><span class="token punctuation">(</span>mq<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MQClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">case</span> CONSUME_FROM_FIRST_OFFSET<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">long</span> lastOffset <span class="token operator">=</span> offsetStore<span class="token punctuation">.</span><span class="token function">readOffset</span><span class="token punctuation">(</span>mq<span class="token punctuation">,</span> <span class="token class-name">ReadOffsetType</span><span class="token punctuation">.</span>READ_FROM_STORE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token comment">// 消费者组之前已经存在（offset>0),或新消费者组且历史消息仍存在broker的内存中（offset=0)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lastOffset <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> lastOffset<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> lastOffset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">case</span> CONSUME_FROM_TIMESTAMP<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">long</span> lastOffset <span class="token operator">=</span> offsetStore<span class="token punctuation">.</span><span class="token function">readOffset</span><span class="token punctuation">(</span>mq<span class="token punctuation">,</span> <span class="token class-name">ReadOffsetType</span><span class="token punctuation">.</span>READ_FROM_STORE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
             <span class="token comment">// 消费者组之前已经存在（offset>0),或新消费者组且历史消息仍存在broker的内存中（offset=0)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lastOffset <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> lastOffset<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> lastOffset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>mq<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">MixAll</span><span class="token punctuation">.</span>RETRY_GROUP_TOPIC_PREFIX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                        result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mQClientFactory<span class="token punctuation">.</span><span class="token function">getMQAdminImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxOffset</span><span class="token punctuation">(</span>mq<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MQClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    <span class="token comment">// 从时间戳对应的offset开始消费</span>
                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                        <span class="token keyword">long</span> timestamp <span class="token operator">=</span> <span class="token class-name">UtilAll</span><span class="token punctuation">.</span><span class="token function">parseDate</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultMQPushConsumerImpl<span class="token punctuation">.</span><span class="token function">getDefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConsumeTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            <span class="token class-name">UtilAll</span><span class="token punctuation">.</span>YYYYMMDDHHMMSS<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mQClientFactory<span class="token punctuation">.</span><span class="token function">getMQAdminImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">searchOffset</span><span class="token punctuation">(</span>mq<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MQClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-2-broker端查询消费者组offset的处理逻辑"><a href="#2-2-broker端查询消费者组offset的处理逻辑" class="headerlink" title="2.2 broker端查询消费者组offset的处理逻辑"></a>2.2 broker端查询消费者组offset的处理逻辑</h2><h3 id="broker处理queryConsumerOffset请求源码实现"><a href="#broker处理queryConsumerOffset请求源码实现" class="headerlink" title="broker处理queryConsumerOffset请求源码实现"></a>broker处理queryConsumerOffset请求源码实现</h3><p><code>org.apache.rocketmq.broker.processor.ConsumerManageProcessor</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// broker处理客户端查找Consumer的offset的请求</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">RemotingCommand</span> <span class="token function">processRequest</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">RemotingCommand</span> request<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">RemotingCommandException</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_CONSUMER_LIST_BY_GROUP<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getConsumerListByGroup</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>UPDATE_CONSUMER_OFFSET<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateConsumerOffset</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>QUERY_CONSUMER_OFFSET<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">queryConsumerOffset</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span> <span class="token class-name">RemotingCommand</span> <span class="token function">queryConsumerOffset</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">RemotingCommand</span> request<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">RemotingCommandException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">final</span> <span class="token class-name">RemotingCommand</span> response <span class="token operator">=</span>
            <span class="token class-name">RemotingCommand</span><span class="token punctuation">.</span><span class="token function">createResponseCommand</span><span class="token punctuation">(</span><span class="token class-name">QueryConsumerOffsetResponseHeader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">QueryConsumerOffsetResponseHeader</span> responseHeader <span class="token operator">=</span>
            <span class="token punctuation">(</span><span class="token class-name">QueryConsumerOffsetResponseHeader</span><span class="token punctuation">)</span> response<span class="token punctuation">.</span><span class="token function">readCustomHeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">QueryConsumerOffsetRequestHeader</span> requestHeader <span class="token operator">=</span>
            <span class="token punctuation">(</span><span class="token class-name">QueryConsumerOffsetRequestHeader</span><span class="token punctuation">)</span> request
                <span class="token punctuation">.</span><span class="token function">decodeCommandCustomHeader</span><span class="token punctuation">(</span><span class="token class-name">QueryConsumerOffsetRequestHeader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 从ConsumerOffsetManager中获取offset</span>
        <span class="token keyword">long</span> offset <span class="token operator">=</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getConsumerOffsetManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">queryOffset</span><span class="token punctuation">(</span>
                requestHeader<span class="token punctuation">.</span><span class="token function">getConsumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            responseHeader<span class="token punctuation">.</span><span class="token function">setOffset</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
            response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
            response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// offset小于0，即broker中不存在该消费者组的offset信息（是一个新启动的消费者组）</span>
            <span class="token comment">// 获取消费队列的最小的offset，如果该队列文件未进行清除，则offset=0</span>
            <span class="token keyword">long</span> minOffset <span class="token operator">=</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getMessageStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMinOffsetInQueue</span><span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    requestHeader<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果minOffset小于等于0，且未被消费的消息仍在内存中则返回offset=0</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>minOffset <span class="token operator">&lt;=</span> <span class="token number">0</span>
                <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getMessageStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">checkInDiskByConsumeOffset</span><span class="token punctuation">(</span>
                requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                responseHeader<span class="token punctuation">.</span><span class="token function">setOffset</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
                response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 新启动的消费者组，且积压的消息不在内存中，则返回QUERY_NOT_FOUND</span>
                response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>QUERY_NOT_FOUND<span class="token punctuation">)</span><span class="token punctuation">;</span>
                response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token string">"Not found, V3_0_6_SNAPSHOT maybe this group consumer boot first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> response<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="broker查找消费者组offset源码实现"><a href="#broker查找消费者组offset源码实现" class="headerlink" title="broker查找消费者组offset源码实现"></a>broker查找消费者组offset源码实现</h3><p><code>org.apache.rocketmq.broker.offset.ConsumerOffsetManager.java</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// broker启动时加载启动用户目录下的store/config/consumerOffset.json文件，该文件保存了对应Topic下的消费者组在队列的offset</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">decode</span><span class="token punctuation">(</span><span class="token class-name">String</span> jsonString<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>jsonString <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ConsumerOffsetManager</span> obj <span class="token operator">=</span> <span class="token class-name">RemotingSerializable</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">,</span> <span class="token class-name">ConsumerOffsetManager</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>offsetTable <span class="token operator">=</span> obj<span class="token punctuation">.</span>offsetTable<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 根据Topic、消费者组、队列Id从broker获取offset，如果不存在则返回-1</span>
<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">queryOffset</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> group<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> queueId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// topic@group</span>
    <span class="token class-name">String</span> key <span class="token operator">=</span> topic <span class="token operator">+</span> TOPIC_GROUP_SEPARATOR <span class="token operator">+</span> group<span class="token punctuation">;</span>
    <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>offsetTable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> map<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Long</span> offset <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>queueId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> offset<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>如果一个消费者组之前已经启动过，再次启动后，无论consumeFromWhere设置何值，都会根据在broker记录的offset进行消费</li>
<li>如果是一个新启动的消费者组，且消费者组订阅的消息仍在broker的内存中，无论consumeFromWhere设置何值，都将从0开始消费</li>
<li>如果是一个新启动的消费者组，且消费者组订阅的消息不在broker的内存中，根据consumeFromWhere设置的获取对应的offset进行消费</li>
</ul>
<h2 id="克隆或重置消费者组的offset"><a href="#克隆或重置消费者组的offset" class="headerlink" title="克隆或重置消费者组的offset"></a>克隆或重置消费者组的offset</h2><p>根据分析结果，如果是一个已经存在的消费者组，如果想要跳过积压的消息，设置consumeFromWhere是无效的，但是可用通过rocketmq-dashboard或mqadmin重置offset。<br>如果是新建消费者组，不想要重头开始消费，可以在代码中做时间校验跳过历史消息，或者通过rocketmq-dashboard或mqadmin新建消费者组并重置offset。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>ConsumeFromWhere</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ中Mmap原理分析及使用</title>
    <url>/2020/10/29/rockermq/rocketmq-zhong-mmap-yuan-li-fen-xi-ji-shi-yong/</url>
    <content><![CDATA[<h1 id="一、Mmap基础概念"><a href="#一、Mmap基础概念" class="headerlink" title="一、Mmap基础概念"></a>一、Mmap基础概念</h1><p>Mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<h1 id="二、Mmap内存映射原理"><a href="#二、Mmap内存映射原理" class="headerlink" title="二、Mmap内存映射原理"></a>二、Mmap内存映射原理</h1><p><img src="/2020/10/29/rockermq/rocketmq-zhong-mmap-yuan-li-fen-xi-ji-shi-yong/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84mmap.png" alt="mmap内存映射"></p>
<blockquote>
<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>
</blockquote>
<h2 id="（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域"><a href="#（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域" class="headerlink" title="（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域"></a>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</h2><blockquote>
<p>1、进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</p>
<p>2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>
<p>3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化</p>
<p>4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p>
</blockquote>
<h2 id="（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系"><a href="#（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系" class="headerlink" title="（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系"></a>（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</h2><blockquote>
<p>5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>
<p>6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。</p>
<p>7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>
<p>8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p>
</blockquote>
<h2 id="（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝"><a href="#（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝" class="headerlink" title="（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝"></a>（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</h2><blockquote>
<p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p>
<p>9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>
<p>10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>
<p>11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>
<p>12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>
<p>注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p>
</blockquote>
<h1 id="三、Mmap方式和常规文件操作区别"><a href="#三、Mmap方式和常规文件操作区别" class="headerlink" title="三、Mmap方式和常规文件操作区别"></a>三、Mmap方式和常规文件操作区别</h1><p>常规文件系统操作（调用read/fread等类函数）中，函数的调用过程：</p>
<p>1、进程发起读文件请求。</p>
<p>2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。</p>
<p>3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>
<p>4、如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>
<blockquote>
<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p>
<p>而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p>
<p>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。</p>
</blockquote>
<h1 id="四、Mmap的优点"><a href="#四、Mmap的优点" class="headerlink" title="四、Mmap的优点"></a>四、Mmap的优点</h1><p>由上文讨论可知，mmap优点共有一下几点：</p>
<p>1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。</p>
<p>2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p>
<p>3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</p>
<p>同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</p>
<p>4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</p>
<h1 id="五、Mmap在java中应用"><a href="#五、Mmap在java中应用" class="headerlink" title="五、Mmap在java中应用"></a>五、Mmap在java中应用</h1><h2 id="5-1-Java中Mmap的使用"><a href="#5-1-Java中Mmap的使用" class="headerlink" title="5.1 Java中Mmap的使用"></a>5.1 Java中Mmap的使用</h2><pre class="line-numbers language-none"><code class="language-none">RandomAccessFile  raf &#x3D; new RandomAccessFile(&quot;C:\\Users\\0959\\Desktop\\mmap-test.txt&quot;, &quot;rw&quot;);
MappedByteBuffer mappedByteBuffer &#x3D; raf.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, FILE_SIZE);
raf.close();
mappedByteBuffer.put(content.getBytes());
mappedByteBuffer.force();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-2-FileChannel-map-详解"><a href="#5-2-FileChannel-map-详解" class="headerlink" title="5.2 FileChannel.map()详解"></a>5.2 FileChannel.map()详解</h2><pre class="line-numbers language-$java" data-language="$java"><code class="language-$java">&#x2F;**
 * Maps a region of this channel&#39;s file directly into memory.
 *
 * &lt;p&gt; A region of a file may be mapped into memory in one of three modes:
 * &lt;&#x2F;p&gt;
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt;&lt;p&gt; &lt;i&gt;Read-only:&lt;&#x2F;i&gt; Any attempt to modify the resulting buffer
 *   will cause a &#123;@link java.nio.ReadOnlyBufferException&#125; to be thrown.
 *   (&#123;@link MapMode#READ_ONLY MapMode.READ_ONLY&#125;) &lt;&#x2F;p&gt;&lt;&#x2F;li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; &lt;i&gt;Read&#x2F;write:&lt;&#x2F;i&gt; Changes made to the resulting buffer will
 *   eventually be propagated to the file; they may or may not be made
 *   visible to other programs that have mapped the same file.  (&#123;@link
 *   MapMode#READ_WRITE MapMode.READ_WRITE&#125;) &lt;&#x2F;p&gt;&lt;&#x2F;li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; &lt;i&gt;Private:&lt;&#x2F;i&gt; Changes made to the resulting buffer will not
 *   be propagated to the file and will not be visible to other programs
 *   that have mapped the same file; instead, they will cause private
 *   copies of the modified portions of the buffer to be created.  (&#123;@link
 *   MapMode#PRIVATE MapMode.PRIVATE&#125;) &lt;&#x2F;p&gt;&lt;&#x2F;li&gt;
 *
 * &lt;&#x2F;ul&gt;
 *
 * &lt;p&gt; For a read-only mapping, this channel must have been opened for
 * reading; for a read&#x2F;write or private mapping, this channel must have
 * been opened for both reading and writing.
 *
 * &lt;p&gt; The &#123;@link MappedByteBuffer &lt;i&gt;mapped byte buffer&lt;&#x2F;i&gt;&#125;
 * returned by this method will have a position of zero and a limit and
 * capacity of &lt;tt&gt;size&lt;&#x2F;tt&gt;; its mark will be undefined.  The buffer and
 * the mapping that it represents will remain valid until the buffer itself
 * is garbage-collected.
 *
 * &lt;p&gt; A mapping, once established, is not dependent upon the file channel
 * that was used to create it.  Closing the channel, in particular, has no
 * effect upon the validity of the mapping.
 *
 * &lt;p&gt; Many of the details of memory-mapped files are inherently dependent
 * upon the underlying operating system and are therefore unspecified.  The
 * behavior of this method when the requested region is not completely
 * contained within this channel&#39;s file is unspecified.  Whether changes
 * made to the content or size of the underlying file, by this program or
 * another, are propagated to the buffer is unspecified.  The rate at which
 * changes to the buffer are propagated to the file is unspecified.
 *
 * &lt;p&gt; For most operating systems, mapping a file into memory is more
 * expensive than reading or writing a few tens of kilobytes of data via
 * the usual &#123;@link #read read&#125; and &#123;@link #write write&#125; methods.  From the
 * standpoint of performance it is generally only worth mapping relatively
 * large files into memory.  &lt;&#x2F;p&gt;
 *
 * @param  mode
 *         One of the constants &#123;@link MapMode#READ_ONLY READ_ONLY&#125;, &#123;@link
 *         MapMode#READ_WRITE READ_WRITE&#125;, or &#123;@link MapMode#PRIVATE
 *         PRIVATE&#125; defined in the &#123;@link MapMode&#125; class, according to
 *         whether the file is to be mapped read-only, read&#x2F;write, or
 *         privately (copy-on-write), respectively
 *
 * @param  position
 *         The position within the file at which the mapped region
 *         is to start; must be non-negative
 *
 * @param  size
 *         The size of the region to be mapped; must be non-negative and
 *         no greater than &#123;@link java.lang.Integer#MAX_VALUE&#125;
 *
 * @return  The mapped byte buffer
 *
 * @throws NonReadableChannelException
 *         If the &lt;tt&gt;mode&lt;&#x2F;tt&gt; is &#123;@link MapMode#READ_ONLY READ_ONLY&#125; but
 *         this channel was not opened for reading
 *
 * @throws NonWritableChannelException
 *         If the &lt;tt&gt;mode&lt;&#x2F;tt&gt; is &#123;@link MapMode#READ_WRITE READ_WRITE&#125; or
 *         &#123;@link MapMode#PRIVATE PRIVATE&#125; but this channel was not opened
 *         for both reading and writing
 *
 * @throws IllegalArgumentException
 *         If the preconditions on the parameters do not hold
 *
 * @throws IOException
 *         If some other I&#x2F;O error occurs
 *
 * @see java.nio.channels.FileChannel.MapMode
 * @see java.nio.MappedByteBuffer
 *&#x2F;
public abstract MappedByteBuffer map(MapMode mode,
                                     long position, long size)
    throws IOException;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（1）将FileChannle对于的文件的一部分直接映射到内存。（这里的内存是堆外内存）<br>（2）映射模式可以是MapMode.READ_ONLY(只读)，MapMode.READ_WRITE(读写)，MapMode.PRIVATE（私有，写时复制）<br>（3）如果是只读模式映射，那么文件通道必须是以只读模式打开。<br>（4）方法返回的MappedByteBuffer的position是0，limit 和 capacity的值是参数size的值。<br>（5）一旦映射完成，那么该MappedByteBuffer就和创建它的FileChannel无关。关闭FileChannel不会影响该MappedByteBuffer。<br>（6）该方法的底层实现依赖于具体操作系统中mmap系统调用的实现逻辑。不同的操作系统可能表现不同。例如：程序修改了MappedByteBuffer的内容，操作系统何时将变更写入到磁盘，这个是不确定的。<br>（7）对大多数操作系统来说该方法都是一个昂贵的操作，如果仅仅是映射很小范围，那么不建议使用。针对大文件推荐使用该操作。</p>
<h2 id="5-3-MappedByteBuffer详解"><a href="#5-3-MappedByteBuffer详解" class="headerlink" title="5.3 MappedByteBuffer详解"></a>5.3 MappedByteBuffer详解</h2><p>MappedByteBuffer本质上是一块堆外内存，也就是DirectByteBuffer。通过FileChannel.map来创建，直到被GC才结束它的生命。</p>
<blockquote>
<p>load()方法</p>
</blockquote>
<p>加载该缓存的内容到物理内存中。这是因为mapp完成后，OS并没有直接读取文件的内容，当真正要访问的时候，通过缺页异常来进行读磁盘操作。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
    * Loads this buffer's content into physical memory.
    *
    * &lt;p> This method makes a best effort to ensure that, when it returns,
    * this buffer's content is resident in physical memory.  Invoking this
    * method may cause some number of page faults and I/O operations to
    * occur. &lt;/p>
    *
    * @return  This buffer
    */</span>
   <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">MappedByteBuffer</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token function">checkMapped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>address <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
           <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
       <span class="token keyword">long</span> offset <span class="token operator">=</span> <span class="token function">mappingOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">long</span> length <span class="token operator">=</span> <span class="token function">mappingLength</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">load0</span><span class="token punctuation">(</span><span class="token function">mappingAddress</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token comment">// Read a byte from each page to bring it into memory. A checksum</span>
       <span class="token comment">// is computed as we go along to prevent the compiler from otherwise</span>
       <span class="token comment">// considering the loop as dead code.</span>
       <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">int</span> ps <span class="token operator">=</span> <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">pageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">pageCount</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token function">mappingAddress</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">byte</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
           x <span class="token operator">^=</span> unsafe<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
           a <span class="token operator">+=</span> ps<span class="token punctuation">;</span>
       <span class="token punctuation">&#125;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>unused <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
           unused <span class="token operator">=</span> x<span class="token punctuation">;</span>

       <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>force()方法</p>
</blockquote>
<p>强制将修改后的的内容写入到存储设备上。<br>需要注意的是：如果是本地设备，那么该方法返回时，确保自从该缓存区创建后或该方法最后一次调用后，变更的内容一定写入了设备，如果是网络文件则没有该保证。<br>如果不是通过<code>MapMode.READ_WRITE</code>模式映射的，调用该方法没有任何影响。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
     * Forces any changes made to this buffer's content to be written to the
     * storage device containing the mapped file.
     *
     * &lt;p> If the file mapped into this buffer resides on a local storage
     * device then when this method returns it is guaranteed that all changes
     * made to the buffer since it was created, or since this method was last
     * invoked, will have been written to that device.
     *
     * &lt;p> If the file does not reside on a local device then no such guarantee
     * is made.
     *
     * &lt;p> If this buffer was not mapped in read/write mode (&#123;@link
     * java.nio.channels.FileChannel.MapMode#READ_WRITE&#125;) then invoking this
     * method has no effect. &lt;/p>
     *
     * @return  This buffer
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">MappedByteBuffer</span> <span class="token function">force</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">checkMapped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>address <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">long</span> offset <span class="token operator">=</span> <span class="token function">mappingOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">force0</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token function">mappingAddress</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mappingLength</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于force方法多说一点：即使我们不手动调动该方法写缓存区的更改写入底层设备，操作系统底层也会定时将变更的脏页刷到设备上，不过时间不确定。</p>
<p>MappedByteBuffer 在我们关闭FileChannel和文件后如果还没有被GC，那么对于的文件也是无法删除的，因为底层的文件句柄还没有释放。在RocketMQ中有专门针对该问题编写的代码。具体如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ByteBuffer</span> buffer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>buffer<span class="token punctuation">.</span><span class="token function">isDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token function">viewed</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"cleaner"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"clean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>作用是获取DirectByteBuffer中的Cleaner，然后调用它的clean方法来回收该DirectByteBuffer，也就是MappedByteBuffer。</p>
<p>Cleaner底层是通过unsafe.freeMemory(address);来释放内存的。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析mmap：是什么 为什么 怎么用</a></p>
<p><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html">从内核文件系统看文件读写过程</a></p>
<p><a href="https://blog.csdn.net/yusiguyuan/article/details/23388771">linux内存映射mmap原理分析</a></p>
<p><a href="https://leokongwq.github.io/2019/09/12/java-mmap.html">java 中的内存映射</a></p>
</blockquote>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>Mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ中的Consumer及ConsumerGroup详解</title>
    <url>/2021/09/05/rockermq/rocketmq-zhong-de-consumer-ji-consumergroup-xiang-jie/</url>
    <content><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）"></a>消息消费者（Consumer）</h2><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<h2 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）"></a>消费者组（Consumer Group）</h2><p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h2 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）"></a>集群消费（Clustering）</h2><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<h2 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）"></a>广播消费（Broadcasting）</h2><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p>
<h1 id="二、订阅关系一致"><a href="#二、订阅关系一致" class="headerlink" title="二、订阅关系一致"></a>二、订阅关系一致</h1><p>订阅关系一致指的是同一个消费者Group ID下所有Consumer实例所订阅的Topic、Tag必须完全一致。如果订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失。</p>
<h2 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息"></a>背景信息</h2><p>消息队列RocketMQ版里的一个消费者Group ID代表一个Consumer实例群组。对于大多数分布式应用来说，一个消费者Group ID下通常会挂载多个Consumer实例。</p>
<p>由于消息队列RocketMQ版的订阅关系主要由Topic+Tag共同组成，因此，保持订阅关系一致意味着同一个消费者Group ID下所有的Consumer实例需在以下方面均保持一致：</p>
<ul>
<li>订阅的Topic必须一致，例如：Consumer1订阅TopicA和TopicB，Consumer2也必须订阅TopicA和TopicB，不能只订阅TopicA、只订阅TopicB或订阅TopicA和TopicC。</li>
<li>订阅的同一个Topic中的Tag必须一致，包括Tag的数量和Tag的顺序，例如：Consumer1订阅TopicB且Tag为Tag1||Tag2，Consumer2订阅TopicB的Tag也必须是Tag1||Tag2，不能只订阅Tag1、只订阅Tag2或者订阅Tag2||Tag1。</li>
</ul>
<p>正确的订阅关系如下，多个Group ID分别订阅了不同的Topic，但是同一个Group ID下的多个Consumer实例C1、C2、C3订阅的Topic和Tag都一致。<br><img src="/2021/09/05/rockermq/rocketmq-zhong-de-consumer-ji-consumergroup-xiang-jie/RocketMQ%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB.png" alt="RocketMQ订阅关系"></p>
<h1 id="三、订阅关系不一致"><a href="#三、订阅关系不一致" class="headerlink" title="三、订阅关系不一致"></a>三、订阅关系不一致</h1><p>当RocketMQ订阅关系不一致时，消息消费的逻辑就会混乱，甚至导致消息丢失，接下来我们结合案例及源码做进一步验证分析。</p>
<blockquote>
<p>RocketMQ Version : 4.8.0</p>
</blockquote>
<h2 id="消费者组内消费者订阅相同的Topic不同的Tag"><a href="#消费者组内消费者订阅相同的Topic不同的Tag" class="headerlink" title="消费者组内消费者订阅相同的Topic不同的Tag"></a>消费者组内消费者订阅相同的Topic不同的Tag</h2><p>RocketMQ相同消费者组内订阅相同Topic不同Tag的测试基本信息：</p>
<ul>
<li>Topic名称： SUBSCRIBE_TEST</li>
<li>Topic读队列数量：4</li>
<li>Topic写队列数量：4</li>
<li>Topic读写权限：6</li>
<li>消费者组名称： SUBSCRIBE_TEST_CONSUMER_GROUP</li>
<li>消息TAG类型： TagA，TagB</li>
<li>TagA消息消费者： ConsumerForTagA</li>
<li>TagB消息消费者： ConsumerForTagB</li>
</ul>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><ul>
<li><code>ConsumerForTagA</code>订阅信息： 订阅Topic<code>SUBSCRIBE_TEST</code> 和<code>tagA</code></li>
<li><code>ConsumerForTagB</code>订阅信息： 订阅Topic<code>SUBSCRIBE_TEST</code> 和<code>tagB</code></li>
</ul>
<h3 id="消费者代码示例："><a href="#消费者代码示例：" class="headerlink" title="消费者代码示例："></a>消费者代码示例：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerForTagA</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"SUBSCRIBE_TEST_CONSUMER_GROUP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"172.16.1.15:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"SUBSCRIBE_TEST"</span><span class="token punctuation">,</span> <span class="token string">"tagA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive New Messages: %s %n"</span><span class="token punctuation">,</span> msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConsumerForTagA started!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerForTagB</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"SUBSCRIBE_TEST_CONSUMER_GROUP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"172.16.1.15:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"SUBSCRIBE_TEST"</span><span class="token punctuation">,</span> <span class="token string">"tagB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive New Messages: %s %n"</span><span class="token punctuation">,</span> msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConsumerForTagB started!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="先启动ConsumerForTagA再启动ConsumerForTagB"><a href="#先启动ConsumerForTagA再启动ConsumerForTagB" class="headerlink" title="先启动ConsumerForTagA再启动ConsumerForTagB"></a>先启动ConsumerForTagA再启动ConsumerForTagB</h3><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>生产者向<code>SUBSCRIBE_TEST</code>Topic中写入8条消息，前4条消息的TAG为<code>tagA</code>，后4条消息的TAG为<code>tagB</code>.</p>
<h3 id="生产者代码示例"><a href="#生产者代码示例" class="headerlink" title="生产者代码示例"></a>生产者代码示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SyncProducer</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span><span class="token punctuation">,</span> <span class="token class-name">RemotingException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">MQBrokerException</span><span class="token punctuation">,</span> <span class="token class-name">UnsupportedEncodingException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"SUBSCRIBE_TEST_PRODUCER_GROUP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"172.16.1.15:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        producer<span class="token punctuation">.</span><span class="token function">setSendMsgTimeout</span><span class="token punctuation">(</span><span class="token number">15000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">String</span> tag <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"tagA"</span> <span class="token operator">:</span> <span class="token string">"tagB"</span><span class="token punctuation">;</span>
            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"SUBSCRIBE_TEST"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"MsgStr"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s%n"</span><span class="token punctuation">,</span> sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="启动生产者发送消息"><a href="#启动生产者发送消息" class="headerlink" title="启动生产者发送消息"></a>启动生产者发送消息</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SendResult</span> <span class="token punctuation">[</span>sendStatus<span class="token operator">=</span>SEND_OK<span class="token punctuation">,</span> msgId<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4B9C0000<span class="token punctuation">,</span> offsetMsgId<span class="token operator">=</span>AC10010F00002A9F00000017038663BE<span class="token punctuation">,</span> messageQueue<span class="token operator">=</span><span class="token class-name">MessageQueue</span> <span class="token punctuation">[</span>topic<span class="token operator">=</span>SUBSCRIBE_TEST<span class="token punctuation">,</span> brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token class-name">SendResult</span> <span class="token punctuation">[</span>sendStatus<span class="token operator">=</span>SEND_OK<span class="token punctuation">,</span> msgId<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4C040001<span class="token punctuation">,</span> offsetMsgId<span class="token operator">=</span>AC10010F00002A9F0000001703866483<span class="token punctuation">,</span> messageQueue<span class="token operator">=</span><span class="token class-name">MessageQueue</span> <span class="token punctuation">[</span>topic<span class="token operator">=</span>SUBSCRIBE_TEST<span class="token punctuation">,</span> brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token class-name">SendResult</span> <span class="token punctuation">[</span>sendStatus<span class="token operator">=</span>SEND_OK<span class="token punctuation">,</span> msgId<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4C760002<span class="token punctuation">,</span> offsetMsgId<span class="token operator">=</span>AC10010F00002A9F0000001703866548<span class="token punctuation">,</span> messageQueue<span class="token operator">=</span><span class="token class-name">MessageQueue</span> <span class="token punctuation">[</span>topic<span class="token operator">=</span>SUBSCRIBE_TEST<span class="token punctuation">,</span> brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token class-name">SendResult</span> <span class="token punctuation">[</span>sendStatus<span class="token operator">=</span>SEND_OK<span class="token punctuation">,</span> msgId<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4C890003<span class="token punctuation">,</span> offsetMsgId<span class="token operator">=</span>AC10010F00002A9F000000170386660D<span class="token punctuation">,</span> messageQueue<span class="token operator">=</span><span class="token class-name">MessageQueue</span> <span class="token punctuation">[</span>topic<span class="token operator">=</span>SUBSCRIBE_TEST<span class="token punctuation">,</span> brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token class-name">SendResult</span> <span class="token punctuation">[</span>sendStatus<span class="token operator">=</span>SEND_OK<span class="token punctuation">,</span> msgId<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4CBE0004<span class="token punctuation">,</span> offsetMsgId<span class="token operator">=</span><span class="token operator">*</span><span class="token operator">*</span>AC10010F00002A9F00000017038666D2<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> messageQueue<span class="token operator">=</span><span class="token class-name">MessageQueue</span> <span class="token punctuation">[</span>topic<span class="token operator">=</span>SUBSCRIBE_TEST<span class="token punctuation">,</span> brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token class-name">SendResult</span> <span class="token punctuation">[</span>sendStatus<span class="token operator">=</span>SEND_OK<span class="token punctuation">,</span> msgId<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4D190005<span class="token punctuation">,</span> offsetMsgId<span class="token operator">=</span><span class="token operator">*</span><span class="token operator">*</span>AC10010F00002A9F0000001703866797<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> messageQueue<span class="token operator">=</span><span class="token class-name">MessageQueue</span> <span class="token punctuation">[</span>topic<span class="token operator">=</span>SUBSCRIBE_TEST<span class="token punctuation">,</span> brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token class-name">SendResult</span> <span class="token punctuation">[</span>sendStatus<span class="token operator">=</span>SEND_OK<span class="token punctuation">,</span> msgId<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4D380006<span class="token punctuation">,</span> offsetMsgId<span class="token operator">=</span>AC10010F00002A9F000000170386685C<span class="token punctuation">,</span> messageQueue<span class="token operator">=</span><span class="token class-name">MessageQueue</span> <span class="token punctuation">[</span>topic<span class="token operator">=</span>SUBSCRIBE_TEST<span class="token punctuation">,</span> brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token class-name">SendResult</span> <span class="token punctuation">[</span>sendStatus<span class="token operator">=</span>SEND_OK<span class="token punctuation">,</span> msgId<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4DE50007<span class="token punctuation">,</span> offsetMsgId<span class="token operator">=</span>AC10010F00002A9F0000001703866921<span class="token punctuation">,</span> messageQueue<span class="token operator">=</span><span class="token class-name">MessageQueue</span> <span class="token punctuation">[</span>topic<span class="token operator">=</span>SUBSCRIBE_TEST<span class="token punctuation">,</span> brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="消费者消费消息情况"><a href="#消费者消费消息情况" class="headerlink" title="消费者消费消息情况"></a>消费者消费消息情况</h2><p>ConsumerForTagA未消费到消息。<br>ConsumerForTagB消费到2条消息，消息内容如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Receive</span> <span class="token class-name">New</span> <span class="token class-name">Messages</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token class-name">MessageExt</span> <span class="token punctuation">[</span>brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> storeSize<span class="token operator">=</span><span class="token number">197</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> sysFlag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> bornTimestamp<span class="token operator">=</span><span class="token number">1630810315966</span><span class="token punctuation">,</span> bornHost<span class="token operator">=</span><span class="token operator">/</span><span class="token number">172.16</span><span class="token number">.0</span><span class="token number">.103</span><span class="token operator">:</span><span class="token number">62659</span><span class="token punctuation">,</span> storeTimestamp<span class="token operator">=</span><span class="token number">1630810316147</span><span class="token punctuation">,</span> storeHost<span class="token operator">=</span><span class="token operator">/</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> msgId<span class="token operator">=</span><span class="token operator">*</span><span class="token operator">*</span>AC10010F00002A9F00000017038666D2<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> commitLogOffset<span class="token operator">=</span><span class="token number">98843387602</span><span class="token punctuation">,</span> bodyCRC<span class="token operator">=</span><span class="token number">686395636</span><span class="token punctuation">,</span> reconsumeTimes<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> preparedTransactionOffset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token class-name">Message</span><span class="token punctuation">&#123;</span>topic<span class="token operator">=</span><span class="token string">'SUBSCRIBE_TEST'</span><span class="token punctuation">,</span> flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> properties<span class="token operator">=</span><span class="token punctuation">&#123;</span>MIN_OFFSET<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> MAX_OFFSET<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> CONSUME_START_TIME<span class="token operator">=</span><span class="token number">1630810316068</span><span class="token punctuation">,</span> UNIQ_KEY<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4CBE0004<span class="token punctuation">,</span> CLUSTER<span class="token operator">=</span><span class="token class-name">DefaultCluster</span><span class="token punctuation">,</span> WAIT<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> TAGS<span class="token operator">=</span>tagB<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> body<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">115</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">,</span> <span class="token number">83</span><span class="token punctuation">,</span> <span class="token number">116</span><span class="token punctuation">,</span> <span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">52</span><span class="token punctuation">]</span><span class="token punctuation">,</span> transactionId<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">]</span> 
<span class="token class-name">Receive</span> <span class="token class-name">New</span> <span class="token class-name">Messages</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token class-name">MessageExt</span> <span class="token punctuation">[</span>brokerName<span class="token operator">=</span>broker<span class="token operator">-</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> queueId<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> storeSize<span class="token operator">=</span><span class="token number">197</span><span class="token punctuation">,</span> queueOffset<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> sysFlag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> bornTimestamp<span class="token operator">=</span><span class="token number">1630810316057</span><span class="token punctuation">,</span> bornHost<span class="token operator">=</span><span class="token operator">/</span><span class="token number">172.16</span><span class="token number">.0</span><span class="token number">.103</span><span class="token operator">:</span><span class="token number">62659</span><span class="token punctuation">,</span> storeTimestamp<span class="token operator">=</span><span class="token number">1630810316223</span><span class="token punctuation">,</span> storeHost<span class="token operator">=</span><span class="token operator">/</span><span class="token number">172.16</span><span class="token number">.1</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">10911</span><span class="token punctuation">,</span> msgId<span class="token operator">=</span><span class="token operator">*</span><span class="token operator">*</span>AC10010F00002A9F0000001703866797<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> commitLogOffset<span class="token operator">=</span><span class="token number">98843387799</span><span class="token punctuation">,</span> bodyCRC<span class="token operator">=</span><span class="token number">1609474146</span><span class="token punctuation">,</span> reconsumeTimes<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> preparedTransactionOffset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token class-name">Message</span><span class="token punctuation">&#123;</span>topic<span class="token operator">=</span><span class="token string">'SUBSCRIBE_TEST'</span><span class="token punctuation">,</span> flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> properties<span class="token operator">=</span><span class="token punctuation">&#123;</span>MIN_OFFSET<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> MAX_OFFSET<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> CONSUME_START_TIME<span class="token operator">=</span><span class="token number">1630810316088</span><span class="token punctuation">,</span> UNIQ_KEY<span class="token operator">=</span>AC10DFD6121618B4AAC216EE4D190005<span class="token punctuation">,</span> CLUSTER<span class="token operator">=</span><span class="token class-name">DefaultCluster</span><span class="token punctuation">,</span> WAIT<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> TAGS<span class="token operator">=</span>tagB<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> body<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">115</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">,</span> <span class="token number">83</span><span class="token punctuation">,</span> <span class="token number">116</span><span class="token punctuation">,</span> <span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">,</span> transactionId<span class="token operator">=</span><span class="token string">'null'</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>根据上述测试结果，可以分析得出如下结论：</p>
<ul>
<li>测试Topic的队列数量为4，生产者分别向每个队列总共写入了2条消息，TAG分别为<code>tagA</code>和<code>tagB</code></li>
<li>消费者组<code>SUBSCRIBE_TEST_CONSUMER_GROUP</code>下有两个消费者，消费者<code>ConsumerForTagA</code>先启动，消费者<code>ConsumerForTagB</code>后启动</li>
<li>消费者<code>ConsumerForTagA</code>消费的队列ID为<code>0</code>和<code>1</code>，消费者<code>ConsumerForTagB</code>消息的队列ID为<code>2</code>和<code>3</code></li>
<li>消费者<code>ConsumerForTabA</code>对分配给自己的队列<code>0</code>和<code>1</code>中的TAG为<code>tagA</code>和<code>tagB</code>的消息，都未进行消费</li>
<li>消费者<code>ConsumerForTagB</code>消费了分配给自己的队列<code>2</code>和<code>3</code>中的TAG为<code>tagB</code>的消息，但没有消费TAG为<code>tagA</code>的消息</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>消费者<code>ConsumerForTagB</code>在消费者<code>ConsumerForTabA</code>之后启动，覆盖了RocketMQ的Broker中的消费者组<code>SUBSCRIBE_TEST_CONSUMER_GROUP</code>订阅关系，该消费者组在消费者<code>ConsumerForTagB</code>启动后，订阅的消息变为<code>tagB</code>，消费者<code>ConsumerForTagA</code>在消费消息时，由于消费者组的订阅TAG为<code>tagB</code>，所以过滤掉了<code>tagA</code>的消息。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Broken获取消息的源码"><a href="#Broken获取消息的源码" class="headerlink" title="Broken获取消息的源码"></a>Broken获取消息的源码</h4><p><code>DefaultMessageStore.java</code>中获取Message的源码, 其中去除了部分边界检测逻辑</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">GetMessageResult</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> group<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> queueId<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> maxMsgNums<span class="token punctuation">,</span>
        <span class="token keyword">final</span> <span class="token class-name">MessageFilter</span> messageFilter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

        <span class="token keyword">long</span> beginTime <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSystemClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">GetMessageStatus</span> status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>NO_MESSAGE_IN_QUEUE<span class="token punctuation">;</span>
        <span class="token keyword">long</span> nextBeginOffset <span class="token operator">=</span> offset<span class="token punctuation">;</span>
        <span class="token keyword">long</span> minOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> maxOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token class-name">GetMessageResult</span> getResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetMessageResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> <span class="token keyword">long</span> maxOffsetPy <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commitLog<span class="token punctuation">.</span><span class="token function">getMaxOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ConsumeQueue</span> consumeQueue <span class="token operator">=</span> <span class="token function">findConsumeQueue</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> queueId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>consumeQueue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            minOffset <span class="token operator">=</span> consumeQueue<span class="token punctuation">.</span><span class="token function">getMinOffsetInQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            maxOffset <span class="token operator">=</span> consumeQueue<span class="token punctuation">.</span><span class="token function">getMaxOffsetInQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxOffset <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>NO_MESSAGE_IN_QUEUE<span class="token punctuation">;</span>
                nextBeginOffset <span class="token operator">=</span> <span class="token function">nextOffsetCorrection</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;</span> minOffset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>OFFSET_TOO_SMALL<span class="token punctuation">;</span>
                nextBeginOffset <span class="token operator">=</span> <span class="token function">nextOffsetCorrection</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> minOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">==</span> maxOffset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>OFFSET_OVERFLOW_ONE<span class="token punctuation">;</span>
                nextBeginOffset <span class="token operator">=</span> <span class="token function">nextOffsetCorrection</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">></span> maxOffset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>OFFSET_OVERFLOW_BADLY<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> minOffset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    nextBeginOffset <span class="token operator">=</span> <span class="token function">nextOffsetCorrection</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> minOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    nextBeginOffset <span class="token operator">=</span> <span class="token function">nextOffsetCorrection</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> maxOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">SelectMappedBufferResult</span> bufferConsumeQueue <span class="token operator">=</span> consumeQueue<span class="token punctuation">.</span><span class="token function">getIndexBuffer</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>bufferConsumeQueue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                        status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>NO_MATCHED_MESSAGE<span class="token punctuation">;</span>

                        <span class="token keyword">long</span> nextPhyFileStartOffset <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>
                        <span class="token keyword">long</span> maxPhyOffsetPulling <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

                        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                        <span class="token keyword">final</span> <span class="token keyword">int</span> maxFilterMessageCount <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">16000</span><span class="token punctuation">,</span> maxMsgNums <span class="token operator">*</span> <span class="token class-name">ConsumeQueue</span><span class="token punctuation">.</span>CQ_STORE_UNIT_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">final</span> <span class="token keyword">boolean</span> diskFallRecorded <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>messageStoreConfig<span class="token punctuation">.</span><span class="token function">isDiskFallRecorded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">ConsumeQueueExt<span class="token punctuation">.</span>CqExtUnit</span> cqExtUnit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConsumeQueueExt<span class="token punctuation">.</span>CqExtUnit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bufferConsumeQueue<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> maxFilterMessageCount<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token class-name">ConsumeQueue</span><span class="token punctuation">.</span>CQ_STORE_UNIT_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">long</span> offsetPy <span class="token operator">=</span> bufferConsumeQueue<span class="token punctuation">.</span><span class="token function">getByteBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">int</span> sizePy <span class="token operator">=</span> bufferConsumeQueue<span class="token punctuation">.</span><span class="token function">getByteBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">long</span> tagsCode <span class="token operator">=</span> bufferConsumeQueue<span class="token punctuation">.</span><span class="token function">getByteBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                            maxPhyOffsetPulling <span class="token operator">=</span> offsetPy<span class="token punctuation">;</span>

                            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextPhyFileStartOffset <span class="token operator">!=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>offsetPy <span class="token operator">&lt;</span> nextPhyFileStartOffset<span class="token punctuation">)</span>
                                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>

                            <span class="token keyword">boolean</span> isInDisk <span class="token operator">=</span> <span class="token function">checkInDiskByCommitOffset</span><span class="token punctuation">(</span>offsetPy<span class="token punctuation">,</span> maxOffsetPy<span class="token punctuation">)</span><span class="token punctuation">;</span>

                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isTheBatchFull</span><span class="token punctuation">(</span>sizePy<span class="token punctuation">,</span> maxMsgNums<span class="token punctuation">,</span> getResult<span class="token punctuation">.</span><span class="token function">getBufferTotalSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> getResult<span class="token punctuation">.</span><span class="token function">getMessageCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                isInDisk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>

                            <span class="token keyword">boolean</span> extRet <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> isTagsCodeLegal <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>consumeQueue<span class="token punctuation">.</span><span class="token function">isExtAddr</span><span class="token punctuation">(</span>tagsCode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                extRet <span class="token operator">=</span> consumeQueue<span class="token punctuation">.</span><span class="token function">getExt</span><span class="token punctuation">(</span>tagsCode<span class="token punctuation">,</span> cqExtUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>extRet<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                    tagsCode <span class="token operator">=</span> cqExtUnit<span class="token punctuation">.</span><span class="token function">getTagsCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                                    <span class="token comment">// can't find ext content.Client will filter messages by tag also.</span>
                                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;, topic=&#123;&#125;, group=&#123;&#125;"</span><span class="token punctuation">,</span>
                                        tagsCode<span class="token punctuation">,</span> offsetPy<span class="token punctuation">,</span> sizePy<span class="token punctuation">,</span> topic<span class="token punctuation">,</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    isTagsCodeLegal <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                                <span class="token punctuation">&#125;</span>
                            <span class="token punctuation">&#125;</span>
                            <span class="token comment">// 这里是messageFilter根据消费队列中的tag值进行过滤，如果队列中的tag与messageFileter中不匹配则跳过该消息</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>messageFilter <span class="token operator">!=</span> <span class="token keyword">null</span>
                                <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>messageFilter<span class="token punctuation">.</span><span class="token function">isMatchedByConsumeQueue</span><span class="token punctuation">(</span>isTagsCodeLegal <span class="token operator">?</span> tagsCode <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> extRet <span class="token operator">?</span> cqExtUnit <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>getResult<span class="token punctuation">.</span><span class="token function">getBufferTotalSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                    status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>NO_MATCHED_MESSAGE<span class="token punctuation">;</span>
                                <span class="token punctuation">&#125;</span>

                                <span class="token keyword">continue</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>

                            <span class="token class-name">SelectMappedBufferResult</span> selectResult <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commitLog<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span>offsetPy<span class="token punctuation">,</span> sizePy<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> selectResult<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>getResult<span class="token punctuation">.</span><span class="token function">getBufferTotalSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                    status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>MESSAGE_WAS_REMOVING<span class="token punctuation">;</span>
                                <span class="token punctuation">&#125;</span>

                                nextPhyFileStartOffset <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commitLog<span class="token punctuation">.</span><span class="token function">rollNextFile</span><span class="token punctuation">(</span>offsetPy<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">continue</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>

                            <span class="token keyword">if</span> <span class="token punctuation">(</span>messageFilter <span class="token operator">!=</span> <span class="token keyword">null</span>
                                <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>messageFilter<span class="token punctuation">.</span><span class="token function">isMatchedByCommitLog</span><span class="token punctuation">(</span>selectResult<span class="token punctuation">.</span><span class="token function">getByteBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>getResult<span class="token punctuation">.</span><span class="token function">getBufferTotalSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                    status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>NO_MATCHED_MESSAGE<span class="token punctuation">;</span>
                                <span class="token punctuation">&#125;</span>
                                <span class="token comment">// release...</span>
                                selectResult<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">continue</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>

                            <span class="token keyword">this</span><span class="token punctuation">.</span>storeStatsService<span class="token punctuation">.</span><span class="token function">getGetMessageTransferedMsgCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            getResult<span class="token punctuation">.</span><span class="token function">addMessage</span><span class="token punctuation">(</span>selectResult<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>FOUND<span class="token punctuation">;</span>
                            nextPhyFileStartOffset <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>

                        <span class="token keyword">if</span> <span class="token punctuation">(</span>diskFallRecorded<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">long</span> fallBehind <span class="token operator">=</span> maxOffsetPy <span class="token operator">-</span> maxPhyOffsetPulling<span class="token punctuation">;</span>
                            brokerStatsManager<span class="token punctuation">.</span><span class="token function">recordDiskFallBehindSize</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> topic<span class="token punctuation">,</span> queueId<span class="token punctuation">,</span> fallBehind<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>

                        nextBeginOffset <span class="token operator">=</span> offset <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">/</span> <span class="token class-name">ConsumeQueue</span><span class="token punctuation">.</span>CQ_STORE_UNIT_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

                        <span class="token keyword">long</span> diff <span class="token operator">=</span> maxOffsetPy <span class="token operator">-</span> maxPhyOffsetPulling<span class="token punctuation">;</span>
                        <span class="token keyword">long</span> memory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">StoreUtil</span><span class="token punctuation">.</span>TOTAL_PHYSICAL_MEMORY_SIZE
                            <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>messageStoreConfig<span class="token punctuation">.</span><span class="token function">getAccessMessageInMemoryMaxRatio</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        getResult<span class="token punctuation">.</span><span class="token function">setSuggestPullingFromSlave</span><span class="token punctuation">(</span>diff <span class="token operator">></span> memory<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>

                        bufferConsumeQueue<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>OFFSET_FOUND_NULL<span class="token punctuation">;</span>
                    nextBeginOffset <span class="token operator">=</span> <span class="token function">nextOffsetCorrection</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> consumeQueue<span class="token punctuation">.</span><span class="token function">rollNextFile</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"consumer request topic: "</span> <span class="token operator">+</span> topic <span class="token operator">+</span> <span class="token string">"offset: "</span> <span class="token operator">+</span> offset <span class="token operator">+</span> <span class="token string">" minOffset: "</span> <span class="token operator">+</span> minOffset <span class="token operator">+</span> <span class="token string">" maxOffset: "</span>
                        <span class="token operator">+</span> maxOffset <span class="token operator">+</span> <span class="token string">", but access logic queue failed."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            status <span class="token operator">=</span> <span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>NO_MATCHED_LOGIC_QUEUE<span class="token punctuation">;</span>
            nextBeginOffset <span class="token operator">=</span> <span class="token function">nextOffsetCorrection</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">GetMessageStatus</span><span class="token punctuation">.</span>FOUND <span class="token operator">==</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>storeStatsService<span class="token punctuation">.</span><span class="token function">getGetMessageTimesTotalFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>storeStatsService<span class="token punctuation">.</span><span class="token function">getGetMessageTimesTotalMiss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">long</span> elapsedTime <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSystemClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> beginTime<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>storeStatsService<span class="token punctuation">.</span><span class="token function">setGetMessageEntireTimeMax</span><span class="token punctuation">(</span>elapsedTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

        getResult<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
        getResult<span class="token punctuation">.</span><span class="token function">setNextBeginOffset</span><span class="token punctuation">(</span>nextBeginOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
        getResult<span class="token punctuation">.</span><span class="token function">setMaxOffset</span><span class="token punctuation">(</span>maxOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
        getResult<span class="token punctuation">.</span><span class="token function">setMinOffset</span><span class="token punctuation">(</span>minOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> getResult<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="消息过滤器TAG匹配源码"><a href="#消息过滤器TAG匹配源码" class="headerlink" title="消息过滤器TAG匹配源码"></a>消息过滤器TAG匹配源码</h4><p><code>messageFilter.isMatchedByConsumeQueue</code>的代码实现.<br>根据代码这里是根据messageFilter中的subscriptionData的订阅TAG进行匹配。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatchedByConsumeQueue</span><span class="token punctuation">(</span><span class="token class-name">Long</span> tagsCode<span class="token punctuation">,</span> <span class="token class-name">ConsumeQueueExt<span class="token punctuation">.</span>CqExtUnit</span> cqExtUnit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> subscriptionData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriptionData<span class="token punctuation">.</span><span class="token function">isClassFilterMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// by tags code.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ExpressionType</span><span class="token punctuation">.</span><span class="token function">isTagType</span><span class="token punctuation">(</span>subscriptionData<span class="token punctuation">.</span><span class="token function">getExpressionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>tagsCode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriptionData<span class="token punctuation">.</span><span class="token function">getSubString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">SubscriptionData</span><span class="token punctuation">.</span>SUB_ALL<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            
            <span class="token comment">// 根据subscriptionData中的订阅tag判断是否匹配</span>
            <span class="token keyword">return</span> subscriptionData<span class="token punctuation">.</span><span class="token function">getCodeSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>tagsCode<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// no expression or no bloom</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>consumerFilterData <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> consumerFilterData<span class="token punctuation">.</span><span class="token function">getExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span>
                <span class="token operator">||</span> consumerFilterData<span class="token punctuation">.</span><span class="token function">getCompiledExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> consumerFilterData<span class="token punctuation">.</span><span class="token function">getBloomFilterData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

            <span class="token comment">// message is before consumer</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cqExtUnit <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>consumerFilterData<span class="token punctuation">.</span><span class="token function">isMsgInLive</span><span class="token punctuation">(</span>cqExtUnit<span class="token punctuation">.</span><span class="token function">getMsgStoreTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Pull matched because not in live: &#123;&#125;, &#123;&#125;"</span><span class="token punctuation">,</span> consumerFilterData<span class="token punctuation">,</span> cqExtUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> filterBitMap <span class="token operator">=</span> cqExtUnit<span class="token punctuation">.</span><span class="token function">getFilterBitMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">BloomFilter</span> bloomFilter <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>consumerFilterManager<span class="token punctuation">.</span><span class="token function">getBloomFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>filterBitMap <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>bloomDataValid
                <span class="token operator">||</span> filterBitMap<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token class-name">Byte</span><span class="token punctuation">.</span>SIZE <span class="token operator">!=</span> consumerFilterData<span class="token punctuation">.</span><span class="token function">getBloomFilterData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBitNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

            <span class="token class-name">BitsArray</span> bitsArray <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                bitsArray <span class="token operator">=</span> <span class="token class-name">BitsArray</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>filterBitMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">boolean</span> ret <span class="token operator">=</span> bloomFilter<span class="token punctuation">.</span><span class="token function">isHit</span><span class="token punctuation">(</span>consumerFilterData<span class="token punctuation">.</span><span class="token function">getBloomFilterData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bitsArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Pull &#123;&#125; by bit map:&#123;&#125;, &#123;&#125;, &#123;&#125;"</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span> consumerFilterData<span class="token punctuation">,</span> bitsArray<span class="token punctuation">,</span> cqExtUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"bloom filter error, sub="</span> <span class="token operator">+</span> subscriptionData
                    <span class="token operator">+</span> <span class="token string">", filter="</span> <span class="token operator">+</span> consumerFilterData <span class="token operator">+</span> <span class="token string">", bitMap="</span> <span class="token operator">+</span> bitsArray<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="消息过滤器中订阅数据来源"><a href="#消息过滤器中订阅数据来源" class="headerlink" title="消息过滤器中订阅数据来源"></a>消息过滤器中订阅数据来源</h4><p><code>PullMessageProcessor.java</code>中的Consumer订阅数据</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">RemotingCommand</span> <span class="token function">processRequest</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">RemotingCommand</span> request<span class="token punctuation">,</span> <span class="token keyword">boolean</span> brokerAllowSuspend<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">RemotingCommandException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">RemotingCommand</span> response <span class="token operator">=</span> <span class="token class-name">RemotingCommand</span><span class="token punctuation">.</span><span class="token function">createResponseCommand</span><span class="token punctuation">(</span><span class="token class-name">PullMessageResponseHeader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">PullMessageResponseHeader</span> responseHeader <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PullMessageResponseHeader</span><span class="token punctuation">)</span> response<span class="token punctuation">.</span><span class="token function">readCustomHeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">PullMessageRequestHeader</span> requestHeader <span class="token operator">=</span>
            <span class="token punctuation">(</span><span class="token class-name">PullMessageRequestHeader</span><span class="token punctuation">)</span> request<span class="token punctuation">.</span><span class="token function">decodeCommandCustomHeader</span><span class="token punctuation">(</span><span class="token class-name">PullMessageRequestHeader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        response<span class="token punctuation">.</span><span class="token function">setOpaque</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getOpaque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"receive PullMessage request command, &#123;&#125;"</span><span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 此处略去部分代码</span>

        <span class="token keyword">final</span> <span class="token keyword">boolean</span> hasSuspendFlag <span class="token operator">=</span> <span class="token class-name">PullSysFlag</span><span class="token punctuation">.</span><span class="token function">hasSuspendFlag</span><span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getSysFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token keyword">boolean</span> hasCommitOffsetFlag <span class="token operator">=</span> <span class="token class-name">PullSysFlag</span><span class="token punctuation">.</span><span class="token function">hasCommitOffsetFlag</span><span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getSysFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token keyword">boolean</span> hasSubscriptionFlag <span class="token operator">=</span> <span class="token class-name">PullSysFlag</span><span class="token punctuation">.</span><span class="token function">hasSubscriptionFlag</span><span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getSysFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> <span class="token keyword">long</span> suspendTimeoutMillisLong <span class="token operator">=</span> hasSuspendFlag <span class="token operator">?</span> requestHeader<span class="token punctuation">.</span><span class="token function">getSuspendTimeoutMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token class-name">TopicConfig</span> topicConfig <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getTopicConfigManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">selectTopicConfig</span><span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> topicConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"the topic &#123;&#125; not exist, consumer: &#123;&#125;"</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span><span class="token function">parseChannelRemoteAddr</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>TOPIC_NOT_EXIST<span class="token punctuation">)</span><span class="token punctuation">;</span>
            response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"topic[%s] not exist, apply first please! %s"</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">FAQUrl</span><span class="token punctuation">.</span><span class="token function">suggestTodo</span><span class="token punctuation">(</span><span class="token class-name">FAQUrl</span><span class="token punctuation">.</span>APPLY_TOPIC_URL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> response<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">PermName</span><span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span>topicConfig<span class="token punctuation">.</span><span class="token function">getPerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>NO_PERMISSION<span class="token punctuation">)</span><span class="token punctuation">;</span>
            response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token string">"the topic["</span> <span class="token operator">+</span> requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"] pulling message is forbidden"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> response<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> requestHeader<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> topicConfig<span class="token punctuation">.</span><span class="token function">getReadQueueNums</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">String</span> errorInfo <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]"</span><span class="token punctuation">,</span>
                requestHeader<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> topicConfig<span class="token punctuation">.</span><span class="token function">getReadQueueNums</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> channel<span class="token punctuation">.</span><span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>errorInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
            response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>SYSTEM_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>
            response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span>errorInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> response<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token class-name">SubscriptionData</span> subscriptionData <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">ConsumerFilterData</span> consumerFilterData <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hasSubscriptionFlag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                subscriptionData <span class="token operator">=</span> <span class="token class-name">FilterAPI</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>
                    requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getExpressionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">ExpressionType</span><span class="token punctuation">.</span><span class="token function">isTagType</span><span class="token punctuation">(</span>subscriptionData<span class="token punctuation">.</span><span class="token function">getExpressionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    consumerFilterData <span class="token operator">=</span> <span class="token class-name">ConsumerFilterManager</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>
                        requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getConsumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        requestHeader<span class="token punctuation">.</span><span class="token function">getExpressionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getSubVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">assert</span> consumerFilterData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Parse the consumer's subscription[&#123;&#125;] failed, group: &#123;&#125;"</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    requestHeader<span class="token punctuation">.</span><span class="token function">getConsumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>SUBSCRIPTION_PARSE_FAILED<span class="token punctuation">)</span><span class="token punctuation">;</span>
                response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token string">"parse the consumer's subscription failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> response<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">ConsumerGroupInfo</span> consumerGroupInfo <span class="token operator">=</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getConsumerManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConsumerGroupInfo</span><span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getConsumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 此处略去部分卫语句判断</span>
            
            <span class="token comment">// 这里从subscriptionTable获取到了subscriptionData</span>
            subscriptionData <span class="token operator">=</span> consumerGroupInfo<span class="token punctuation">.</span><span class="token function">findSubscriptionData</span><span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> subscriptionData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"the consumer's subscription not exist, group: &#123;&#125;, topic:&#123;&#125;"</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getConsumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>SUBSCRIPTION_NOT_EXIST<span class="token punctuation">)</span><span class="token punctuation">;</span>
                response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token string">"the consumer's subscription not exist"</span> <span class="token operator">+</span> <span class="token class-name">FAQUrl</span><span class="token punctuation">.</span><span class="token function">suggestTodo</span><span class="token punctuation">(</span><span class="token class-name">FAQUrl</span><span class="token punctuation">.</span>SAME_GROUP_DIFFERENT_TOPIC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> response<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>subscriptionData<span class="token punctuation">.</span><span class="token function">getSubVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> requestHeader<span class="token punctuation">.</span><span class="token function">getSubVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"The broker's subscription is not latest, group: &#123;&#125; &#123;&#125;"</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getConsumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    subscriptionData<span class="token punctuation">.</span><span class="token function">getSubString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>SUBSCRIPTION_NOT_LATEST<span class="token punctuation">)</span><span class="token punctuation">;</span>
                response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token string">"the consumer's subscription not latest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> response<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">ExpressionType</span><span class="token punctuation">.</span><span class="token function">isTagType</span><span class="token punctuation">(</span>subscriptionData<span class="token punctuation">.</span><span class="token function">getExpressionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                consumerFilterData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getConsumerFilterManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    requestHeader<span class="token punctuation">.</span><span class="token function">getConsumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>consumerFilterData <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>FILTER_DATA_NOT_EXIST<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token string">"The broker's consumer filter data is not exist!Your expression may be wrong!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> response<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>consumerFilterData<span class="token punctuation">.</span><span class="token function">getClientVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> requestHeader<span class="token punctuation">.</span><span class="token function">getSubVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"The broker's consumer filter data is not latest, group: &#123;&#125;, topic: &#123;&#125;, serverV: &#123;&#125;, clientV: &#123;&#125;"</span><span class="token punctuation">,</span>
                        requestHeader<span class="token punctuation">.</span><span class="token function">getConsumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> consumerFilterData<span class="token punctuation">.</span><span class="token function">getClientVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getSubVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>FILTER_DATA_NOT_LATEST<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token string">"the consumer's consumer filter data not latest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> response<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">ExpressionType</span><span class="token punctuation">.</span><span class="token function">isTagType</span><span class="token punctuation">(</span>subscriptionData<span class="token punctuation">.</span><span class="token function">getExpressionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getBrokerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEnablePropertyFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            response<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResponseCode</span><span class="token punctuation">.</span>SYSTEM_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>
            response<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token string">"The broker does not support consumer to filter message by "</span> <span class="token operator">+</span> subscriptionData<span class="token punctuation">.</span><span class="token function">getExpressionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> response<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token class-name">MessageFilter</span> messageFilter<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getBrokerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isFilterSupportRetry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            messageFilter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExpressionForRetryMessageFilter</span><span class="token punctuation">(</span>subscriptionData<span class="token punctuation">,</span> consumerFilterData<span class="token punctuation">,</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getConsumerFilterManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            messageFilter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExpressionMessageFilter</span><span class="token punctuation">(</span>subscriptionData<span class="token punctuation">,</span> consumerFilterData<span class="token punctuation">,</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getConsumerFilterManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">final</span> <span class="token class-name">GetMessageResult</span> getMessageResult <span class="token operator">=</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getMessageStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span>requestHeader<span class="token punctuation">.</span><span class="token function">getConsumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                requestHeader<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getQueueOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requestHeader<span class="token punctuation">.</span><span class="token function">getMaxMsgNums</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> messageFilter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 此处略去后续处理的相关代码</span>
        <span class="token keyword">return</span> response<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Consumer订阅数据更新"><a href="#Consumer订阅数据更新" class="headerlink" title="Consumer订阅数据更新"></a>Consumer订阅数据更新</h4><p><code>ConsumerGroupInfo.java</code> </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">updateSubscription</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SubscriptionData</span><span class="token punctuation">></span></span> subList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">boolean</span> updated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SubscriptionData</span> sub <span class="token operator">:</span> subList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// Consumer订阅新的Topic后，更新订阅关系</span>
            <span class="token class-name">SubscriptionData</span> old <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscriptionTable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sub<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>old <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">SubscriptionData</span> prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscriptionTable<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>sub<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> prev<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    updated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"subscription changed, add new topic, group: &#123;&#125; &#123;&#125;"</span><span class="token punctuation">,</span>
                        <span class="token keyword">this</span><span class="token punctuation">.</span>groupName<span class="token punctuation">,</span>
                        sub<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span><span class="token function">getSubVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> old<span class="token punctuation">.</span><span class="token function">getSubVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>consumeType <span class="token operator">==</span> <span class="token class-name">ConsumeType</span><span class="token punctuation">.</span>CONSUME_PASSIVELY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"subscription changed, group: &#123;&#125; OLD: &#123;&#125; NEW: &#123;&#125;"</span><span class="token punctuation">,</span>
                        <span class="token keyword">this</span><span class="token punctuation">.</span>groupName<span class="token punctuation">,</span>
                        old<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        sub<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token comment">/**
                 * 当Consumer的subVersion大于Broker中的subVersion时，则更新订阅信息
                 * 这里old.getSubVersion()即为最后消费者组内最后一个消费者的启动时间
                 * 只有当有新的消费者启动，或者消费者进行了重新负载，订阅关系才会被更新
                 */</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>subscriptionTable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>sub<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SubscriptionData</span><span class="token punctuation">></span><span class="token punctuation">></span></span> it <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscriptionTable<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SubscriptionData</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">String</span> oldTopic <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">boolean</span> exist <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SubscriptionData</span> sub <span class="token operator">:</span> subList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>oldTopic<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    exist <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>exist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"subscription changed, group: &#123;&#125; remove topic &#123;&#125; &#123;&#125;"</span><span class="token punctuation">,</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>groupName<span class="token punctuation">,</span>
                    oldTopic<span class="token punctuation">,</span>
                    next<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">)</span><span class="token punctuation">;</span>

                it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                updated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">this</span><span class="token punctuation">.</span>lastUpdateTimestamp <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> updated<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>Broker在获取消息时会根据subscriptionTable中对应的消费者组的订阅Tag进行消息过滤，同一个消费者组内，Broker中保存了最后启动的Consumer的订阅信息，后续只有当新的消费者添加进来或者消费者组内的消费者进行了重新负载均衡（重新负载的可能原因：消费者新增或移除、队列数量变更），订阅信息才会被更新。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>Consumer</tag>
        <tag>ConsumerGroup</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ消息存储</title>
    <url>/2020/09/10/rockermq/rocketmq-xiao-xi-cun-chu/</url>
    <content><![CDATA[<h1 id="一、消息存储架构图"><a href="#一、消息存储架构图" class="headerlink" title="一、消息存储架构图"></a>一、消息存储架构图</h1><p><img src="/2020/09/10/rockermq/rocketmq-xiao-xi-cun-chu/rocketmq_design_1.png" alt="消息存储架构图"></p>
<h1 id="二、消息存储"><a href="#二、消息存储" class="headerlink" title="二、消息存储"></a>二、消息存储</h1><h2 id="2-1-消息存储文件"><a href="#2-1-消息存储文件" class="headerlink" title="2.1 消息存储文件"></a>2.1 消息存储文件</h2><table>
<thead>
<tr>
<th>文件名称</th>
<th>作用</th>
<th>文件大小</th>
<th>文件格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CommitLog</td>
<td>消息主体以及元数据的存储主体</td>
<td>单个文件大小默认1G</td>
<td>消息顺序写入文件，当文件满了，写入下一个文件</td>
<td>文件名为20位，如一个文件名为00000000000000000000代表以一个文件，起始偏移量为0，文件大小为1G=1073741824，后面新增文件的名称基于上一个文件名累加1G，起始偏移量从上一个文件继续累计。</td>
</tr>
<tr>
<td>ConsumeQueue</td>
<td>消息消费队列</td>
<td>每个条目20个字节，单个文件由30W个条目组成</td>
<td>每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode</td>
<td>单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M</td>
</tr>
<tr>
<td>IndexFile</td>
<td>索引文件</td>
<td>固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引</td>
<td>IndexFile的底层存储设计为在文件系统中实现HashMap结构</td>
<td>rocketmq的索引文件其底层实现为hash索引</td>
</tr>
</tbody></table>
<h2 id="2-2-存储结构分析"><a href="#2-2-存储结构分析" class="headerlink" title="2.2 存储结构分析"></a>2.2 存储结构分析</h2><ol>
<li>Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。</li>
<li>多个Topic的消息实体内容都存储于一个CommitLog中</li>
<li>RocketMQ的混合型存储结构针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构</li>
</ol>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>消息存储</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ设计原理分析</title>
    <url>/2020/11/26/rockermq/rocketmq-she-ji-yuan-li-fen-xi/</url>
    <content><![CDATA[<h1 id="RocketMQ设计原理分析——技术分享PPT"><a href="#RocketMQ设计原理分析——技术分享PPT" class="headerlink" title="RocketMQ设计原理分析——技术分享PPT"></a>RocketMQ设计原理分析——技术分享PPT</h1><span id="more"></span>


	<div class="row">
    <embed src="./RocketMQ设计原理分析.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>Mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>张一鸣：牛逼的人找方法，傻逼的人找借口</title>
    <url>/2022/01/18/thought/zhang-yi-ming-niu-bi-de-ren-zhao-fang-fa-sha-bi-de-ren-zhao-jie-kou/</url>
    <content><![CDATA[<blockquote>
<h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><p>内容来源：本文为公众号仟语仟寻（ID：huoqian2014）首发，转载自笔记侠（ID：Notesman）<br>原文地址：<a href="https://mp.weixin.qq.com/s/HJLStYr-UO1Y02lEA6EOGQ">张一鸣：牛逼的人找方法，傻逼的人找借口</a></p>
</blockquote>
<p>伴随成长，我们会遇到很多问题，在不断思考，今天读到的这篇文章中许多观点引起了我的共鸣，更从中看到了一些值得去探索的方法。</p>
<blockquote>
<h2 id="商业思维"><a href="#商业思维" class="headerlink" title="商业思维"></a>商业思维</h2><p>编者按：<br>这几天抽空把张一鸣所有的微博看了一遍，2010年的微博是他30岁左右时候发的，那时候他刚创业没多久，在微博上认真分享自己的思考和观点。到了2012年附近，开始做今日头条。从他的微博中，我试图找到他成功的钥匙，仅仅是这些只言片语，我都觉得对我的启发很大。一个有趣的故事是，早年张一鸣曾把马化腾的所有微博读了一遍；而今天，张一鸣的微博也被人仔细研读，试图摸索出他成就背后的思维逻辑。<br>围观他的微博，结论就是张一鸣真的太厉害了，发现他说得最多的关键词：延迟满足感，自控，理性，反省，创新，学习。<br>本文是从他微博中摘录的231句话，绝大多数都是他创业初期的思考，我们可以看下10年前的想创业的张一鸣在想什么，在思考什么，是怎么鞭策自己的。有点长，希望大家耐心看完，一定会有所收获的。</p>
</blockquote>
<h1 id="一、关于成长"><a href="#一、关于成长" class="headerlink" title="一、关于成长"></a>一、关于成长</h1><p>1.人常会不自觉地记下对自己有利的部分，这是形成委屈的重要原因。</p>
<p>2.延迟满足感程度在不同量级的人是没法有效讨论问题的，因为他们愿意触探停留的深度不一样。</p>
<p>3.做不好的就别做了，要做就必须做到非常好。</p>
<p>4.当感到沟通困难的时候，最好的沟通方法不是想太多技巧和说法，而是：更坦诚的沟通</p>
<p>5.有感：人生的差距就是在自我感觉良好中拉开的。——与朋友共诫勉</p>
<p>6.经验：当无法选择或判断的时候，离远一步，远到用更重要的原则和更长的时间尺度来衡量就清楚了。</p>
<p>7.沟通中没听明白的话，常因为这些话用了“这个”，“那样”等代词，或笼统的名词，含糊的形容词、副词、量词替换掉往往“本身还模糊或有分歧的内容”。虽然句子是完整了，但是意思不清楚。然而如果替换的部分是清楚的，并不会听不明白。你要做的就是抓住这个词，还给他们。</p>
<p>8.练习保持耐心，即使是快节奏和压力的情况下。</p>
<p>9.今天听王兴演讲的的比喻：人生，和谁一起在路上，看什么风景。我最近也是在想，以后要让小孩多看看传记，包括电视剧《阿信》那样的也可以，看看别人的风景和旅程，更容易想清楚自己的选择。</p>
<p>10.应该让肾上腺素和理智一起发挥作用。</p>
<p>11.谋事不求易成，具备强烈的成功动机和韧性才能成功。</p>
<p>12.路径依赖的强弱可表征延迟满足感。</p>
<p>13.参考别人的意见，只是判断线索，不可作为决定的决心。</p>
<p>14.老子说祸兮福之所倚，福兮祸之所伏。幸运的时候不要忘形，失意的时候也不要绝望，相信事情总会有转机。那这句话是唯心的还是唯物的呢？当然是唯物的，告诉你忘形和失意都无助于事，做有意义的事情，关注事情的变化。</p>
<p>15.与智慧的常见敌人：未延迟的满足感，经验带来的麻痹或恐惧。</p>
<p>16.很多时候不是不理解，甚至不是认识不到，只是不愿意深刻认识到。这往往还是隐隐的主观在作怪。</p>
<p>17.最贵的是“学费”。</p>
<p>18.三年前和朋友聊天，问他对合作者对人才看重什么，其它点我已经记不住了，唯记住：不装B。当时楞了一下，随后越发觉得有道理。经常要提醒自己，这也是延迟满足感的一种锻炼。</p>
<p>19.不停地想应该如何让未来更精彩。</p>
<p>20.年轻人不要试图追求安全感，特别是年轻的时候，周遭环境从来都不会有绝对的安全感，如果你觉得安全了，很有可能开始暗藏危机。真正的安全感，来自你对自己的信心，是你每个阶段性目标的实现，而真正的归属感，在于你的内心深处，对自己命运的把控，因为你最大的对手永远是自己。</p>
<p>21.如果给过去5年的自己一个建议，就是激进再激进一点。</p>
<p>22.快50岁，思路清晰深入，细节敏感，执行又高举高打，很好地控制自己情绪。晚上参加活动看到别人的优点。</p>
<p>23.短期交往说话忽悠会有溢价，长期交往说话实在会有溢价。</p>
<p>24.用心认真的折腾是没有风险的。</p>
<p>25.看缺点有难度，权衡缺点看优点更难；避免犯错有难度，接受犯错以成功更难。</p>
<p>26.选择比努力更重要，观念比选择更重要。</p>
<p>27.遇到一本好书，很愉快，和遇到一个非常值得交往的朋友是相似的。</p>
<p>28.在北京6年住了6个地方：回龙观，双榆树，知春里，和平里，惠新西街，西土城。你住过哪儿？</p>
<p>29.多修炼，期早达：耳顺、知天命、从心所欲不逾矩。想起一个朋友的msn（国外的通讯软件）签名：三十耳顺，当时没注意，现在想到已经了不起了，提前了一半。</p>
<p>30.在不来劲的时候来劲，在太来劲的时候淡定。</p>
<p>31.谦虚的人能看到自己的不足，自信的人能在知道不足的情况下依然积极。</p>
<p>32.你最终会成为你想要的样子——如果你真的非常想。虽然听起来有点唯心，但是强大的愿望确实非常重要。</p>
<p>33.稻盛要辞职离开快倒闭的公司，遭兄长棒喝：“在这样没人干活的公司你都做不出点成绩来，你还能干什么？洛克菲勒感觉再也无法忍受日复一日枯燥的工作，提出换岗，遭主管冷言“要么好好干、要么另谋出路”。同样的道理，不同的说法，却像雷一样击中并成就了两个商业巨匠。还是那句，不抱怨、想方法。</p>
<p>34.关于消费：买书、健身、学习都属于资金成本边际成本很低，对于很多人，只要你能真正完成这些消费，资金都不是主要成本而值得大力投入的消费。综上，我非常建议大家买书、买电子书、ipad、智能手机、买健身卡、游泳卡…还有类似的消费吗？</p>
<p>35.“独立思考忠实于自己的内心”“越朴素不虚荣，所做出的选择会越实际而可行”。</p>
<p>36.听说有人每天能看一本书，问题还不在看书速度，而是在知易行难，实践的速度赶不上所知的要求，欠账很多。</p>
<p>37.卓有成效如果有什么秘诀的话，那就是善于集中精力。—《卓有成效的管理》</p>
<p>38.研究聪明人如何犯错误，回报率很高。聪明人易犯错误包括：第一，嫉妒他人成功；第二，自命不凡；第三，过于相信自己判断；第四，停止学习；第五，认为世界是静止的，生活在过去荣耀中；第六，任何事情都有自己一套言之有据、且深信不疑的说法和理论：忘记了没有调查研究，就没有发言权。你符合吗？</p>
<p>39.坚持原则很多时候是经济的，可以看做是一种短期浮亏的长期受益的投资。</p>
<p>40.知行合一真难，中间差的是什么？</p>
<p>41.既会庆幸做了什么，也会庆幸没做什么。</p>
<p>42.加强专注力训练，它是优先级管理的保证，同时持续专注力的一个基础是体力和精力，锻炼修炼。</p>
<p>43.晚上看书，看书—带着悔恨的心情和克制悔恨的努力。</p>
<p>44.发现保持体力充沛精力旺盛是一项基础工作～</p>
<p>45.昨天和朋友聊天，总结到：在这个信息流动越来越快越来越透明的社会，从经济的角度来看，做一个表里不一的人成本越来越高，龌龊的人会越来越倒霉，不装不但是一个道德品性优选，而且也是更经济的。很多人还未意识到这点。</p>
<p>46.某项较长时间不如人意的工作，终于有了起色，耐心很重要。凡事都有原因，只要认真找原因并努力改进，就会有效果。</p>
<p>47.今天会谈提到感性理性，我的观点：感性深化放在深处，理性实化放在前锋。</p>
<p>48.上午北京大学周其仁教授发言非常精彩。他认为一个持久得到别人信任的人，收入就越高。有比知识、技能更加重要的东西，那就是信任。他们的团队在研究了农民工的收入以后发现，收入最高的人，往往并不是体力最好、技能最好的时候，而是最受信任的人。所以，成为一个受人信任的人，非常重要。</p>
<p>49.改变你目前能改变的，专注到circle of influence（影响圈）：现在最重要的是放松，睡觉去。</p>
<p>50.最近感想：口碑很重要，人品很重要，信用很重要，越老越重要，原则要坚定。</p>
<p>51.上帝不可能骗得了我，因为所有的欺骗都有漏洞。——笛卡尔</p>
<p>52.将事情做满，还是将事情做好，其实是很不一样的。我们容易看到将事情做满，但是容易忽略把事情做好。</p>
<p>53.指标系统：为什么刷牙不能坚持认真刷，为什么在跑步机上能坚持跑步。有许多事情不容易做好和不被重视的原因就是因为没有指标系统。比如，如果健康有准确方便度量的指标，那么大家的身体素质一定会提高。但是指标不见得好提炼，提炼指标的过程，本身是分解事物特征的过程。而且指标要常测量。比如说：当我今天发现眼睛度数上升100度的时候，才发现眼睛过疲劳了，用眼不注意了，在手机上看书是非常不恰当的行为。关键是今天才知道哇…</p>
<p>54.大多数人，确实一开始就想绕过困难。好的问题就是一半的答案，剩下一半答案就是奋斗。</p>
<p>55.你们读了哪些传记？想起2年前朋友说：如果不知道让小孩阅读什么，最适合的就是传记。最近在思考与回忆：关于品格、理想、动机的形成，觉得确实如此。</p>
<p>56.我去年自己有一个感想：觉得之前的老板都对我不太苛刻啊。否则我当时能做的更好。当然很可能是他们认为，已经做的好，太苛刻人就跑了，其实对于会自我驱动的人是不会的。</p>
<p>57.关于感性，或忧或悲，但你看到人生不容易十之八九，当你看到生活的真实面目时：你会悲，但就不会因表象而伤感；你会喜，也不会而浮华而极乐。生活中有时候猛然听到残酷而又真实有穿透力的话，看到本有违世界观而又有理的书，直到你自己会下意识的去看生活本来面目，你的感性就变化了。</p>
<p>58.玩德州扑克看人性的弱点：第一，贪玩（一开始拿烂牌但是不fold，fold:认输）；第二，侥幸（希望等低概率事件）；第三，不能舍（因过去付出而不放弃）；第四，过度概括（只看一个例子就下结论）。其实，德州扑克和人生一样：应该：第一，理解不确定性；第二，专注有可能的事情；第三，理智评估概率；第四，能舍才能得；第五，避免意气用事。</p>
<p>59.在知乎上看到很多IT行业聪明爱思考的人的思考，密度很高。感觉是氛围尚不是模式带来的，喜欢和聪明思考的人共处。</p>
<p>60.终于把《如何阅读一本书》阅读完了。美国人就是认真，把阅读的问题方法刨根究底。这不是一本资讯娱乐类的书，是需要和增进理解的书。</p>
<p>61.一件事情上，在心里想对方自私的时候，想一想自己：多数发现自己也蛮自私的。在骂对方贪婪的时候，想一想自己：多数发现自己也同样贪婪。</p>
<p>62.做个理性人，很多事情就不必做。感性做人，理性做事的态度有其意义。</p>
<p>63.今天手机报上有一段话:“独处是一次心灵按摩”静坐在斗室里，漫步在小道上，平躺在沙滩上…有意识的面对自己，和内心对话。喜欢独处的人，和别人在一起时，往往也会处理的更好。交流和独处相辅相成，才能让内心成熟和强大。</p>
<p>64.凡事就怕不认真，不思考。好多问题我应该能知道的，只是之前没有认真看，认真想，想当然（不是没时间）。延迟满足感是一项长期修炼。</p>
<p>65.台风来的时候，猪都会飞起来。所以，真的飞起来时一定要清楚的知道是因为自已能飞，还是外力使然。靠台风飞起来的猪迟早是会掉下来的。</p>
<p>66.有人问比尔·盖茨：什么是你最大的恐惧？盖茨回答：我最恐惧的是那些正在破车库里没日没夜捣鼓新名堂的年轻人。</p>
<p>67.写完文档准备睡觉，想起今天看的《facebook 效应》，突然想起《普通生物学》介绍的一个物质：多巴胺。最近愈发想起人与人之间的状态区别，是否有激情，是否自我激励，是否是由这类物质的代谢水平决定了基本面。肖恩·帕克是多巴胺水平很高的典型？</p>
<p>68.想做的事情太多，经常要抑制自己的激动。</p>
<p>69.沟通，听一个人说话：你是否知道他在说什么，你是否知道他知道他在说什么，你是否知道他们知道他在说什么。</p>
<p>70.今天晚上的时候，每个周五晚上下班的时候，我常会和同事说：我明天假期我们再把xxx做好。每次突然想这句话矛盾啊，不能这样要求。嗯，生活工作要平衡。不过，别人腐败的时候我们在努力，别人消磨时光的时候我们在学习，那么延迟的满足一定会厚积薄发来到。</p>
<p>71.延迟满足感经验：涵蓄情绪，让自己静止，不要在沟通交流的时候走动、晃动，情绪跳动，思维失去精确控制。</p>
<p>72.寻找错误或者问题可以从发现自我矛盾点做起，如果能理性地使用逻辑。</p>
<p>73.注意力也可以开源节流的，欲望和杂念分散注意力要节流，锻炼身体和注意力训练是开源。</p>
<p>74.人不逼一下自己，永远不知道自己潜力有多大。很多事情非不能也，是不为也。</p>
<p>75.我最近经常问自己：马上有什么可行动，你是行动派吗？很多问题它不会消失，不动(犹豫/抱怨/感叹)肯定是错误，行动就有力量，哪怕是行动的准备行动，唯有行动才能改变事情。</p>
<p>76.《如何阅读一本书》一书在谈技能之外，更多的是讲学习的态度和沟通的方法。比如赞同和反对一章，其实标题亦可写为，关于沟通的赞同和反对。</p>
<p>77.好的问题就是一半的的答案。</p>
<p>78.乔布斯说stay hungry，我以为饥渴有三个层次：贪婪、成就动机、好奇心 。三者分别关注：瞬间的结果，持续的过程，和远大的未知。三者也恰好对应了三种人：卑劣的投机者，艰辛的攀登者，与幸福的探索者。</p>
<p>79.有不少留言说不理解这段话。研究快乐的专家告诉我们，快乐有三种：pleasure（欢乐）,passion（热情）,higherpurpose（理想、有意义）。其中欢乐是最短暂的，热情其次，而最长久的是理想。</p>
<p>80.想学的东西很多，吾生有涯知无涯，以有涯追无涯，怠也。有两种理解，积极的理解是应该有优先级的规划学习。</p>
<p>81.做减法最不容易也最容易。</p>
<p>82.现在年轻人部分流行把三四十岁退休作为理想，我不认同，我觉得理想是一直有机会创造、实现想法，有机会学习，修炼，创造到老。为什么会想退休？想退休说明你认为现在是在“忍”。我还有很多很多想法想做，希望三四十岁更多条件去实现想法。</p>
<p>83.人群总有一些人xx素比普通人高(很好)有精神有斗志，爱学习，爱创造，爱折腾。下午和一个在某顶级互联网公司的老朋友聊天，他又要出来创业了。</p>
<p>84.发现最近，不论是一起公司的同事，或是投资人，还是老同学都不约而同提到一点：过去一年，我变化很大。我相信他们是能感觉到或者观察到，但是变化的心路只有自己才知道，所以自己觉得很自然。</p>
<p>85.保证足够睡眠是积极高效的第一步。</p>
<p>86.自我实现，自我修炼是最高层次。</p>
<p>87.生活中不是缺少美，而是缺少分享。</p>
<p>88.很多很好的想法自己都非常认真，现在都被人实现或者通往实现的路上了。真希望自己能分身体几个同时努力，这样人生多精确。但是分身是不可能的，所以只能①根据情况排优先级；②找到志同道合的人。</p>
<p>89.今天M.A.D会议，听到一个关于SEO人物介绍，提到某人非常洒脱。我对人物介绍倒没有感觉到特别。但是对洒脱这个词，突然有点感想。效率和竞争往往把人变得很精确、严谨、注重细节、强调计划和控制，这些都没错，但是大家要注意保留一份洒脱，性格和人生观别职业被带入另一个胡同。</p>
<p>90.最近IPO（首次公开募股）的公司一堆一堆的，但是大家一定要耐得住寂寞，他们今天的成功是他们的过去已经决定的，属于他们。我们的成功是我们的现在和将来决定的。我发现很多事情经常是这样的：今天和明天已经由昨天决定，你还可以决定后天。</p>
<p>91.应届生应该推崇自信，诚实，努力，相信成功可通过学习和努力获得。别太讨巧，走捷径。事实上面试大多不是因为技能不行，而是人品和性格不行。</p>
<p>92.一连串有想象力且恰当的比喻连续使用是讲道理的好方法。</p>
<p>93.通货膨胀正在洗劫你的钱包，同学问怎么办？三个办法，一是尽可能地提高家庭负债率，当今之世能借到钱的就是英雄；二是配置资源性财产，能够抵抗通涨的只有三个东西，黄金房产和农产品；三是象傻瓜一样的长期持有，眼前的涨跌都是对耐心的考验。除非天下大乱，否则以上三条应是规律。</p>
<p>94.我今天的处境都是因为我有些应该做的事情我没有做，不应该做的事情我就全做，所以要改变现状，就要从自己开始。</p>
<p>95.有百分之多少的把握你会开始创业，有多深的感觉你会对另外一个人说我爱你，有多么的确信会让你有精神上的信仰。你不必等一切都100%确定了才开始创业，去爱一个人和建立信仰。其实我们的确信度永远达不到100%，那么你会一直等吗？今天，你如果不做一个肯定的决定可能会失去得更多。</p>
<p>96.一个困扰我们很长的时间技术诡异问题，同事们这两天集中时间集中精力分析、求助、排查、尝试终于解决。想起稻盛和夫的说的：用尽全力，异常认真，神明就会来相助。其实神明未必相助，但是你会更接近问题的本质，从而解决问题。</p>
<p>97.系统地运动锻炼需要抗身体的惰性，锻炼久了之后，不但身体好，而且锻炼的积极性也好，容易启动，养成习惯，最近觉得读书学习也很类似。</p>
<p>98.看完《如何阅读一本书》这一章：如何做一个自我要求的读者。也即阅读应该是有自我要求的具主动状态的。阅读两字换成其它很多词也适用。</p>
<p>99.执行力到底是什么？我认为的执行力是：说到做到，不找借口，完成别人都能完成的事。而更强的人可以做到：完成别人完不成的事。同样的一件事，交给不同的员工，会有不同的结果，完不成的人都会有各种理由来说服自己说服领导，将一个小困难由点到面扩大化看待。做一个NB的人，从此刻开始，不再找借口。</p>
<p>100.向成功找方法和为失败找理由，也是人的一个方面的两种习惯和素质。</p>
<p>101.今天和同事讨论效率，说到表达模糊影响效率和沟通的问题。很有同感，我一直就觉得类似以下含糊说法在工作中应避免：“应该差不多吧，过两三天大概就可以了，估计再要一点时间就接近好了，这个东西也还行吧，最好能 xxxx吧，差不多也都行，我过一段弄一下，这样也还是可以的”。</p>
<p>102.最近三个月身体锻炼的进展：腰背少严重疼了，一次跑五公里，一次游一公里都很轻松了。近期目标，自由泳学习中，健身学习中，羽毛球提高。</p>
<p>103.一个人在他的信仰上站得越不牢固，他就越要用双臂紧紧抱住那些使之区分于其他信仰的教条不放；相反，一个人在他的信念上站得越牢固，他就越可以自由地把双手伸向那些与他信仰不同的人。——弗兰克。早安，各位。</p>
<p>104.说到自我修炼，由于懒惰(体力的、思考的、情绪的)是万恶之源，所以修炼很多时候就是在克服惰性。</p>
<p>105.不断给自己小的承诺并努力达到。Be Proactive （变得积极）的修炼方法之一。</p>
<p>106.喜欢最近地铁里的一句广告词：we trust learning（我们要相信学习）。</p>
<p>107.平庸有重力，需要逃逸速度。</p>
<p>108.不怕犯错误，不怕坏方法，甚至不怕坏习惯。只要你会会自我改正。你习惯改正吗？</p>
<p>109.单身的人是有一些好处的，比如更多自由独立思考的环境和时间，孤独往往使人更加深邃和广阔，非单身的人想想如何避免非单身的缺点。</p>
<p>110.快到30岁了，感觉这几年又再重新学习/补习本应在青少年时间学习的东西：如何阅读、如何了解自己、如何与人沟通、如何安排时间、如何正确的看待别人意见、如何激励自己、如何写作、如何坚持锻炼身体、如何耐心。</p>
<p>111.今天见了一个5年未见的同学和半年未见的同学。期间有位同学说工作生活最近很没意思。其实5年变化已经很大，不过我觉得还不够大，生活的意思完全可以自己找，自己改变人生意思就很大。不要等意思来找你。借用奥巴马的话说 change，yes we can.</p>
<p>112.未雨绸缪其实很难的，大多数情况都是事情推人走，而且往往能容易被推动的人已经不错了。</p>
<p>113.互联网让会学习爱学习的人和相反的差距拉的更大，这并不仅限于互联网行业。只不过互联网行业这种趋势先开始而已。现在好多初中生、高中生比大学生、博士生还博学。我见过2个中学生，自己用wiki整理所学过的、自学的各种知识。我怎么生的这么早…</p>
<p>114.延迟满足感和坚决告别惰性，是“优秀”的最重要两块基石。</p>
<p>115.当某人开始深入认识自己、研究自己的时候，说明此人开始有了哲学的思考，预示着此人开始迈入一个新的人生阶段。</p>
<p>116.非常同意自控力（也就是反惰性）是优秀的标准。确实马拉松不是高标准，思维意识情绪的自控更难。</p>
<p>117.牛逼的人找方法，傻逼的人找借口。</p>
<p>118.昨天公司内部做时间管理的交流，是我推动大家的。不过说实话惭愧，最近2-3周我自己的时间管理的目标下降了。惰性是万恶之源。从今天开始又有意识地加强了。</p>
<p>119.只有当你离开自己的舒适区时，你才会挑战自己的极限。</p>
<p>120.“积极主动”是广泛优秀的素质的基础。</p>
<p>121.看年轻人的潜力，看他周末几点起，周末在干嘛，下班在干嘛。甚至不一定要干嘛，只要看想些什么。</p>
<p>122.高中刚开始学物理的时候，老师反复强调不要想当然、凭感觉，应该要推理。其实线性思维是常见的一种想当然，也许许多事物的常态是类线性的，但是常态或者普通事物往往不是关键，需要面对的情况往往是非常态，所以要注意避免线性地”想当然。</p>
<p>123.低落的状态时情况往往没有感受的难，松懈的时候其实不如想象的容易，人往往难理性。</p>
<p>124.避免的常用含糊词：“难免会”，“差不多都这样”。</p>
<p>125.对很多事情我挺有自己观点和想法，目前不能解决问题，没有效果，所以不应该去展开和评论，要想想现在能有效果和价值的事情。我甚至时常要提醒自己：你这样想是没有错的也是没有用的，赶紧做许多又很有用又没有错的事情。</p>
<p>126.最近感觉忙碌多，思考学习反省又少了，观察问题也不够深入和耐心，在 speed up（加速）和激动干劲足的时候，保持一份 slow down（慢下来）的心态很重要。</p>
<p>127.对现实隐忍，对未来有期待，在当下有作为。</p>
<p>128.内向但精力充沛有企图心的人。性格内向的人更易成功：美国MSNBC网站报道称，一项研究发现，内向害羞大多与生俱来，而且，内向的人在工作中更容易成功。在做决策时，他们愿意花大量时间思考，不喜欢闲扯其他的话题，更能专心致志地奔着一个目标努力，因此他们成功的几率也相应增大。</p>
<p>129.很多复杂问题是更高维度简单问题的投影，比如说打篮球动作变形、速度慢、配合差是很多时候体力不行；写程序烂、bug多、时间长是抽象分解问题做的不好；还有比如海军说的“很多管理问题都是假象，本质是能力问题”。而解决这些本质问题，需要更大代价和决心的。</p>
<p>130.今天早点睡，明天早上起来看书。本周的学习计划快完不成了。创业过程中不断的学习又能尝试是感觉很好的体验。</p>
<p>131.人欲望太强的时候就容易短视，太自我中心的时候就容易盲目。</p>
<p>132.以前一直都没觉得找人自信很重要，现在发现越来越重要。惰性、依赖、拖拉、保守很多也都是不自信导致的。自信的人，自然会和自我高要求联系起来。</p>
<p>133.常说机会总是青睐有准备的人，其实更多时候是机会已经来了只是还没凸显，往往自己没珍惜。</p>
<p>134.不抬杠，要抓住主要问题，任何办法都是在一定时空下对真理的近似实现，时空条件越具体，办法法就越有效。如果去抬杠“近似”，那么就更难在这个时空条件下实施。</p>
<p>135.很多事情都是这样既没有你设想的容易，也没有你想象的难。睡觉～～</p>
<p>136.所谓门槛，过去了是门，过不去则是槛。人生的悲哀往往是，你想两肋插刀，刀却只有一把。怀旧，不是那个时代有多好，而是那时你年轻。觉得不快乐，是因为我们追求的不是“幸福”，而是“比别人幸福”。两人的感情就像织毛衣，建立时一针一线，拆除时只需轻轻一拉。</p>
<p>137.成熟感悟：成熟就是从inside-out（由内向外）更多的变成outside-in（由外向内），就是在需要时常能变成忍者神龟，在另一些时候又能变成动感超人。</p>
<p>138.昨天父亲节，和爸妈视频聊天，他们在广东经商，这几年竞争压力内部意见纠纷不小，有时想建议他们别经营了，退休养老，但办公司往往欲退不能。昨天爸爸说还想投入更多一搏，我想既然劝退不行不如鼓励他放手一搏，信任就是鼓励。我不能回去帮忙就要把自己的事情做好，让他不要有担心。</p>
<p>139.关于勤奋，就我所知，罕有成功者不是工作时间极长的：通用电气的CEO 每周工作一百小时，坚持了至少十年。巴菲特为了最早看到次日的华尔街日报，经常在凌晨四点去取报纸。勤奋不是一种形式，而是一种心理状态：享受挑战极限的过程，保持热情和好奇心，坚持不屑。</p>
<p>140.哈佛有一个著名的理论：人的差别在于业余时间，而一个人的命运决定于晚上8点到10点之间。每晚抽出2个小时的时间用来阅读、进修、思考或参加有意的演讲、讨论，你会发现，你的人生正在发生改变，坚持数年之后，成功会向你招手。</p>
<p>141.今天公司进行读书交流会，其中提到《别做正常的傻瓜》一书，大家对是否理性的态度有分歧。</p>
<p>142.人生吧，0岁出场，10岁快乐成长；20为情彷徨；30基本定向；40拼命打闯；50回头望望；60告老还乡；70搓搓麻将；80晒晒太阳；90躺在床上；100 挂在墙上。</p>
<p>143.人生的本质是追寻自我的提升。包括思想、能力、意志等等。这些发展好了，一切随之而来。偏偏大多数人追求的是短期的公司、职位、薪水，运气好的能有所发展，运气差的会迷失方向流于平庸。</p>
<p>144.周末参加一个朋友婚礼，发现新郎最近去了中央某监管结构的信息处，博士新娘回到新郎故乡担干部。他们已经两地分居5年了，为了珍惜机会还要继续分开。这样我是做不到的，也不赞同，人生在世就应该尽可能实现价值体验生活，为了静态的收益而去“忍”损失生活，损失很大，不是创造的人生。</p>
<p>145.不满足之后有几种反应。第一，努力提高自己；第二，尝试安慰自己；第三，抱怨牢骚记在其它人事身上。</p>
<p>146.强烈的动机比方法更根本。</p>
<p>147.不爱表达观点的人，总是容易被人认为没想法不聪明，而部分强势之人更爱发表意见，所以看其他人大多不如自己聪明，其以总爱发表关于他人是否聪明的意见之人为甚。</p>
<p>148.聪明又耐心是有一些矛盾的优点，同时具备两点的人却非常优秀。</p>
<p>149.一点不要含糊，含糊代表着侥幸、代表着自我欺骗、代表着自我感觉飘然。</p>
<p>150.一次别以看一本为目标，比如看5页为目标，关于自己无法耐心看书的问题：如果说哪里来了一个高人每次都会听得很仔细，听完以后觉得很有收获；而看书则是完全不同的心情了。电脑里的经典书籍堆翻天了，却从来没有仔细翻过，真是书非借不能读啊。真是应该给自己一个规划，用看待约会和讲座的心情来看待每一次阅读。</p>
<p>151.不知道其它人看《活法》一书是怎么样一个真实感受，我有时觉得书中的要求太高以致不想去想。</p>
<p>152.“很奇怪”“很诡异”“太奇怪”，有这些想法说明自己还不懂，而且常常还想把原因归咎于“奇怪”以release（免责）。没有什么太奇怪的东西，仔细去找学习的途径，你常常能找到。</p>
<p>153.最近重读到稻盛和夫的《活法》，其中提到专注投入，其中举的陶瓷工艺改进的例子尤其另我印象深刻。我们做每一件事（写一段程序，写一封邮件，写一个策划）的时候是否在想自己是否投入全力以赴的认真做了，结果真的不一样？请试试：你能有多专注？</p>
<p>154.我给自己贴了创业、技术、管理、创新、自省标签。</p>
<p>155.执行力这个词一度很流行，在我理解来看就是态度和能力。不断筛选和提高大家的态度、能力就是提高执行力。</p>
<p>156.习惯：把要做的事情迅速分配在calendar（日历）上，会变化没关系，多调整。</p>
<p>157.你是在松懈状态还是在挑战状态？（这是第一条微博）</p>
<h1 id="二、关于管理"><a href="#二、关于管理" class="headerlink" title="二、关于管理"></a>二、关于管理</h1><p>1.三顾茅庐已经不适用了，必须得四顾。</p>
<p>2.我自己的方法：忘掉资历，集中精力用能力和潜力来评估。资历是个锚点，但未必准确。</p>
<p>3.有个同事提到多招女生来活跃气氛，我晕，果然小年轻的想法，这是分心不是活跃，难道学支付宝美腿招聘么。周末想了想，应该是其实能看到产品在进步、用户体验在提高，自己在修炼进步，交流沟通中有智慧有火花，个人回报满意有提高，就是high的关键。</p>
<p>4.别装，做个坦诚真实的人。团队中都是坦诚真实的人，沟通成本将小很多。</p>
<p>5.能否坦诚沟通是公司团队管理的主要问题。</p>
<p>6.对于创业者来说，找合适的人常常是个不作为的借口，事实是合适的人是永远不存在的，要让自己变成最合适的人。创业者永远要作为半个HR存在。</p>
<p>7.据多家公司统计，团队淘汰个人的顺序往往如下：第一批，明显缺陷者、众人厌恶的说谎者；第二批，不愿交流者、不合群者；第三批，有能力但慵懒者、妄图坐享其成者；第四批，居功自傲者，蔑视同僚者。</p>
<p>8.他解答团队中部分人不能跟上公司发展的处理要点，三点原则：第一，以德为主，德有大问题则需离开，话说清楚不含糊、好好说，先鼓励给机会、不要让团队意外、猜测担心。第三，德具备、才落后或者不匹配的情况，要给降下的人降落伞，降落伞要有含金量，要替人考虑好。</p>
<p>9.当你给一个人足够的信任和压力的时候，他总能比原来做的更好。</p>
<p>10.开会的时候总有些大忙人在那里闷头回邮件玩短信，认为讨论的那些别人的事和自己无关，这是极端错误的。让你参会说明领导认为会议的内容你需要知道并希望听到你的意见，如果发现你不会倾听又对会议无所贡献，慢慢你就不会再被要求参会，久而久之在组织中也就被边缘化了。</p>
<p>11.公平的文化和公平的信任是非常重要的，奖罚分明，这样大家才相信游戏规则存在，才会挑战自己更大回报，才不会有侥幸心理。类似这样的原则CEO要谨记不忘。</p>
<p>12.对组织而言需要把优秀的标准清晰无误的传递且不断精进。含糊和混淆其实是牺牲。</p>
<p>13.加入我们并不代表眼下的这一份工作。万一我说万一，这一票不成功，加入了我们，你会发现，世界上还有很多事值得我们去做。只是看你有没有足够的视野和激情。</p>
<p>14.对于一名CEO而言，最艰难的事可能就是抵制住想自己解决问题的欲望。你曾身经百战，你也许是最有经验，最有资格去解决问题的人。但是这样一来却无法建立一个优秀的管理团队。将机会留给别人期待他们能解决问题十分艰难，但也十分值得。这样一来，整个团队的能力都可以有所提升。</p>
<p>15.经常看到职位蛮漂亮的人，但细看发现他每次升职都是换工作的时候发生的。这会让我警惕，因为好的人，老板会加薪升职来挽留。如果一个人在同一公司多次升职，让我会放心很多，因为比我了解他多得多的人看好他给他更多的责任，而且他一次次胜任。换工作才升职，有可能是外强中干，忽悠了新老板。</p>
<p>16.亚马逊卖书起家，现在他不卖书也很赚钱，360做搜索起家，现在不搜索也很强大，而一些公司，比如迅雷从p2sp、客户端起家却没在这个领域持续拓展创新。这就是是团队的差异。</p>
<p>17.一个身价两百多亿的老板不作秀、不爬山、不吹牛、不打口水仗、不接受采访、不上电视杂志，以身作则像一个基层员工一样每天脚踏实地测试产品， 无止境地改进产品的体验。这才是腾讯成功的最大原因。而被腾讯打败的 Loser们始终没有认识到这一点，要么骂它靠抄袭，要么说它靠QQ才能成功。</p>
<p>18.创业企业在中国越来越普及，优秀的人才也会在之间杜比。况且好的机制也是重要竞争力，我建议所有创业者都以好的心态和机制和团队分享创业过程和结果而不要“忽悠”，这样创业公司才会更容易吸引人才。</p>
<p>19.今天完成期权发放准备，下周给第一批加入的优秀成员发放。开始制定发放计划时，我和其它董事有一些分歧：我强调希望以极低的行权价发放期权，其它董事则强调会计评估问题。最终采用我的方案，因为我非常了解创业团队成员的心态。一个早期公司成员的心态和状态是最根本的，其它问题只是“技术问题”。</p>
<p>20.选择越高级影响越大的人才越要看一些基本素质：理性、逻辑、修养、企图心、自我控制力。</p>
<p>21.其实我挺想知道团队成员周末都在干嘛。。。总希望大家把时间充分有效利用了。。当然我说的不是只工作，是指优先利用学习、休息、娱乐、锻炼、交流，思考上。并且可以一起活动。</p>
<p>22.职场总结：工作基本上是一个积累信誉的过程。自己今天的工作一直在为自己的明天积累信誉。工作中总是掉链子、需要人提醒就是不断的丢掉自己的信誉。We are what we repeatedly do，not we repeatedly think or want or say（我们是我们反复做的，而不是我们反复想或想或说的）。</p>
<p>23.没有免费的午餐。创业公司要出人头地就要求非常优秀高的自我要求。告别“差不多”、“还行”、“先这样吧”、告别工作掉链子、拖拉、80分。很多创业公司还不如大公司努力要求高就沉浸“创业”的状态，或者是只沉浸在工作时间长的伪“创业”状态。</p>
<p>24.姜子牙81岁才当上三军总司令，人家前80年就做两件事：好好学习和锻炼身体。</p>
<p>25.一个公司最强的敌人是什么？韦尔奇说，是“坦率”。深表认同。幸好，坦率是可以培育的。</p>
<p>26.我觉得以后团队的工作，不论大小，应把工作的目标定义并分解后，邮件发出来。第一，这样可以别人提意见；第二，可以避免重复的工作；第三，避免定义清楚理解有误差；第四，同时能估计工作量、评估效率方法。清楚不含糊要成为公司的文化。</p>
<p>27.【职场】昨晚请多玩优秀员工吃饭，聊了几点职场体会。第一，把自己当老板看， 象老板一样拼命干活，能力自然就提高了。有了能力，假如多玩不能给你好的回 报，其他公司一定会给。第二，不是每次付出就一定有回报，但是不断付出就一定会有回报。李学凌补充了一点：像你的老板一样思考，能力会提高得更快。</p>
<p>28.有人问我如何突破自己的职业瓶颈，我说：你的瓶颈就在于你的心。你的心更宽，心态更好，遇到问题将自己拨高一层去看问题，把你心里的那些小纠结小疑惑小算盘小私心，统统打破，你就没有瓶颈。</p>
<p>29.最近大家 review 了九九房半年的进展并讨论每个人的总结和设想，对我们的信心更加增强。和同事曾讨论：创业要经常自省，避免自我强化和催眠。所以要区别信心和“YY”，真正信心源于看到自己的进步和潜力，可以分成两个方面：第一，对事情本身判断的信心；第二，对自己和团队的信心。</p>
<p>30.周六凌晨一点，收到一位创业者短信：大家讨论的结论，极致就是把自己逼疯、把别人逼死！那时，他们正在为自己的梦想通宵达旦的打拼。我理解的极致就是做出超越自己能力的东西，只有极致的东西才能超越用户的想象，才会有良好的口碑。</p>
<p>31.能在细微关键之处自我要求和互相challenge（挑战）是好团队的特质之一。比如平时时间分配、工作状态、思维训练、沟通表达、小习惯。</p>
<p>32.招人最简单莫过于招干过这个事的人。不过能找到特质最具合适特质的人更重要。特别是创新企业，很多岗位未必有成熟的人对应，或者业界的普通标准并不特别适合，或者具体的岗位有一些特别的要求。这时候通过对岗位的理解而去招具备性格技能爱好特质的人就特别重要。</p>
<p>33.其实加入一个优秀的早期公司有一个明显的好处：公司会想尽办法帮你提高，因为公司有很多事情要做，而人员又有限。这个时候就会对有潜质的人提出各种高的要求，帮助提高。在大公司你的老板即使愿意(不一定)花时间和精力coach（教练）你，肯定没有创业公司多。</p>
<p>34.这周面了十几个人终于确定一个实习生。最近一个多月可能面试了50多人，总共只有2个非常有意向的人选，其中失败一个，一个还在谈。每当想放低要求的时候，我就提醒自己一定不能往低走而要往高走，我们要做的出彩，而不是完成的事情。而尤其在早期，核心几个人的能力、素质、态度是最关键的。</p>
<p>35.一个好的团队，是应该能够不断创新突破的团队。</p>
<p>36.有2个朋友2年前10万元起步创业令我佩服，今天见到一个创业者3年前0元起步创业令我惊讶。</p>
<p>37.公司的激励制度和考核制度非常重要，我不知道我看的是否是特例，了解到好些公司的重要岗位管理者长期一边拿着不错的回报，一边把精力重放在折腾自己想的事情。一定要避免这种情况。（不会有人觉得这种情况存在也合理吧）</p>
<p>38.以前面试选拔人的时候一直没有觉得自信这个特质很重要，现在发现在一般的简单的事情和工作自信不是一个重要特质，但是对于一些关键事情和职责自信就是重要区别的特质，真正困难或有挑战的事往往是反向操作的或者是相对孤独的。</p>
<p>39.中午亮哥说创业公司早期只能辛苦多面试人来淘人才。老王说自己的第一职位是hr（人力资源管理）。我觉得他们说的很对。</p>
<p>40.上线大概半年，经常觉得进度太慢。速度、质量、成本三者是不能都同时达到的，当然团队成长速度也是一个重要因素。</p>
<p>41.今天，把半年来每次与不同团队成员1:1沟通中得到的对我和对公司的意见建议作了个回顾，并作划分分为已解决、部分解决、问题依旧。恩，改进的还不够好。</p>
<p>42.结婚有一个不短谈恋爱的过程才领证，而找创业伙伴的时间缺短非常多。如果结婚是合作60年，创业是合作六七年，那么是否应该用 1/10 的时间谈谈“恋爱”？</p>
<p>43.长期回报重点是股份期权。但这方面国内的还不规范：即使是早期核心成员也不被告知自己的期权占公司总股本的比例，更是没有普及优先偿还，行权价、行权条件限等概念，所以很多公司董事会把总股数做很大，让员工听起来好听。我想这个情况不会持久，我们不会这么做。</p>
<p>44.如何吸引人才：我总结（总结不表示我做好了，而是认识到要做好）四个要素：【短期回报】、【长期回报】、【个人成长】、【精神生活】。从左到右，从易到难，其中丰富不一般的人生体验和精神生活是最综合要求最高的，要不断反思追求，九九房会努力做好！欢迎优秀的技术人才、产品人才加入一起共事。</p>
<p>45.有一些人可用追求卓越来鼓舞，另一些人应以现实回报作激励，但是其实两种方法可以关联起来。我是这样关联的，如：“只要我能改进耐心不足的缺点就相当于个人将增值30%了”。</p>
<h1 id="三、关于商业"><a href="#三、关于商业" class="headerlink" title="三、关于商业"></a>三、关于商业</h1><p>1.堆砌的产品没有安全感，准确的抉择才有。</p>
<p>2.组织的成果都在组织之外，所以不要把做完了某某项目说成成果，而应该始终关注对外体现的成果，如：用户在什么方面体验得到了提升，公司在业界得到了什么益处。</p>
<p>3.微博的验证码是什么东西，怎么都答不对，这么重要的东西就这样质量就上线了。引以为戒。</p>
<p>4.创业就要像生小孩一样：准备好体力，用长劲，快速换气；喊疼和抱怨没用，专注在努力，关键时候坚持再坚持一把！</p>
<p>5.重视服务，重视感受，是重要的机会，随着收入水平提高，怕麻烦，希望高质量服务将成为付费动力。帮用户省钱不再是唯一思路，甚至不是最佳思路。</p>
<p>非常强的改善体验的技术应用，靠技术的强劲推动力，让不可能变成可能。</p>
<p>6.对产品经理的常用问题：有什么好处，重要吗，怎么知道的，达到这个好处有好的做法吗？</p>
<p>7.如果你很有才华，在某些方面又有一技之长，请先不要急于露出锋芒，如果你只是以普通身份而不是以领导身份到新单位去的，那就更不能锋芒太露。一个人新到一个单位，就像一粒石子投入一潭平静的池水，往往会引入注目，一举一动，一言一行，都在别人的视野之中。</p>
<p>8.发现问题总是又高兴又郁闷，高兴：解决问题；郁闷：为什么是我发现，为计么现在才发现</p>
<p>9.做产品一定要坚持面对事实仔细辨析小心求证，不绕弯不侥幸不鸵鸟，延迟满足感。</p>
<p>10.创业忌：未思进，先思退。</p>
<p>11.我也快看完了，推荐。我的分享内部交流。之前还看了一本《从零到百亿》，虽然中美环境差别挺大，但是关于创业和人生的差别不大。</p>
<p>12.大半夜来点给力的，创业四原则：刚才又一位出来创业的兄弟 msn 上跟我聊。再次诚恳分享给他：一，凡事只能靠自己；二，万事皆有解，且只有唯一正解；三，凡是担心的事一定会发生；四，从创业的第一天开始，享受！</p>
<p>13.未来会有更多的输入输出的创新让信息可流动，更多分发推荐的机制转动起来。</p>
<p>14.我从小到大遇到过2个大忽悠(不是某件事忽悠，忽悠成性的那种人)，一个中学同学，一个是今年，我的总结是一定不要和大忽悠交往合作，否则即使利益不受损，口碑也会受损。甚至连敷衍都不要去敷衍，那也会浪费你时间。</p>
<p>15.林彪研究战略更研究战术。46年共军初到东北，一个师打不过国军一个团。他冒死亲赴战场观战，研究出班的三三制战斗队形、一点两面等战术方法。并亲 自讲课推广，缩小了与国军战斗力差距。没有林彪，共党很可能失掉东北，改变战争进程。一个企业，如果战略家太多不是好事，抓细节的人越多越好。</p>
<p>16.创业公司周末上班是依靠中策，希望能做到依靠上策：非常主动，高峰状态，时间管理；Procative，Mindfull，Sensitive（练习、正念、敏捷）。</p>
<p>17.看马化腾的腾讯微博，真是超级注重用户体验的产品经理项目经理。</p>
<p>18.明天是9月的第1天。去年的今天，我离开了上一个团队开始筹备 99fang.com。过去的一年表现有优秀有不足，但是打下了很好的产品/用户/市场//技术/团队基础，尤其是我能明显感觉到团队的进步。从明天开始，我们要对自己有更高的挑战和要求。</p>
<p>19.今天公司一位同事用了G2一周后感言：虽然我还很多功能不会用，但是我觉得5年后肯定全部人都用智能手机，很高兴现在用上了。类似的话在公司再一次听到，这次是一个非it背景的同事预测。使用智能手机是一个的生活态度和方式的变化，而尝试新生活本身是积极的态度，而积极的态度是可以互相感染的。</p>
<p>20.反复反复反复体会需求体验产品，高强度的使用产品。</p>
<p>21.非理性让社会存在各种商业机会，非理性让创业公司错过这些机会。不要非理性，要非常理性。</p>
<p>22.互联网行业往往是 Winner Takes All（赢家通吃），即使是传统行业也往往是120%的努力的人获得200%的回报。这个是可以社会有利的，社会需要激励顶尖、极致、创新来带动社会发展。所以每天出门前问问自己如何才能全力以赴了做到杰出。</p>
<p>23.战略很重要，但是团队也相当重要，我自己有切身体会的。酷讯和去哪儿竞争，方向很清楚，但是差距越来越大。当年海内和开心竞争，对开心的数据产品也很了解，可惜就是眼睁睁看着对手从产品到推广上的节节胜利。回到现在团购网站，模式非常简单也没有什么门槛，但是也能拉开这么大的差距。</p>
<p>24.中午见到了一个在做音频信息处理的很有意思的团队，我相信信息的聚合、检索、关联、推荐有很大的空间。</p>
<p>25.模式、方向、战略提的很多，但是许多公司其实死在非常重要但是容易被忽略的基础点或细节上。</p>
<p>26.每天坚持抽看并跟踪10条用户反馈，避免问题疏忽。</p>
<p>27.京东商城“不上楼”的做法其实在很多行业都用过，比如不设导购，不收桌子，不负责安装，这种做减法非常正确和自信。学习。</p>
<p>28.刚刚做完用户可用性测试，发现很多问题。可用性测试是让团队近距离客观细致观察用户的使用体验，发现团队在工作期间想当然或者因为熟悉而忽略的问题。创业过程中出现愿望式思考并自我强化，是我时时提醒自己避免的。</p>
<p>29.创业公司的常见问题：技术怨产品、产品怨战略、战略怨市场。但是往往这种情况的公司技术产品、产品、产品都做的不怎么样。</p>
]]></content>
      <categories>
        <category>thought</category>
      </categories>
      <tags>
        <tag>张一鸣</tag>
      </tags>
  </entry>
  <entry>
    <title>非人力资源经理的人力资源管理</title>
    <url>/2022/03/24/thought/fei-ren-li-zi-yuan-jing-li-de-ren-li-zi-yuan-guan-li/</url>
    <content><![CDATA[<h1 id="一、人力资源管理的技巧"><a href="#一、人力资源管理的技巧" class="headerlink" title="一、人力资源管理的技巧"></a>一、人力资源管理的技巧</h1><p>人力资源管理的核心：选、育、用、留</p>
<h2 id="1-1-人力日常资源管理（HRM）"><a href="#1-1-人力日常资源管理（HRM）" class="headerlink" title="1.1 人力日常资源管理（HRM）"></a>1.1 人力日常资源管理（HRM）</h2><ul>
<li>招聘与选材（Staffing）</li>
<li>薪酬与福利（C&amp;B）</li>
<li>员工关系管理（Employee Relations）</li>
<li>绩效管理（Performance Management）</li>
<li>人力资源电子化管理（E-HR）</li>
</ul>
<h2 id="1-2-人力资源管理谁来做？"><a href="#1-2-人力资源管理谁来做？" class="headerlink" title="1.2 人力资源管理谁来做？"></a>1.2 人力资源管理谁来做？</h2><ol>
<li>所有有下述的人都是公司的人力资源管理者</li>
<li>人力资源部门负责提供有力工具协助管理人力资源</li>
<li>公司老大就是首席人力资源管理者</li>
<li>人力资源管理成败关键<strong>中层管理者</strong></li>
</ol>
<h1 id="二、选材实操篇"><a href="#二、选材实操篇" class="headerlink" title="二、选材实操篇"></a>二、选材实操篇</h1><ul>
<li>一慢：清理成年人在选材方面的定式/偏见</li>
<li>二慢：看看所招岗位需要什么素质</li>
<li>三通过: 通过行为面试法看人不走眼</li>
<li>我怎样综合评估候选人？</li>
</ul>
<h2 id="2-1-一慢：清理成年人在选材方面的定式-偏见"><a href="#2-1-一慢：清理成年人在选材方面的定式-偏见" class="headerlink" title="2.1 一慢：清理成年人在选材方面的定式/偏见"></a>2.1 一慢：清理成年人在选材方面的定式/偏见</h2><ul>
<li>对一些人/事的刻板印象<br>1、年龄<br>2、性别<br>3、学生会干部</li>
<li>试图寻找“超人”</li>
<li>校园招聘忽略应届生情商和逆商</li>
</ul>
<h2 id="2-2-二慢：看看所招岗位需要什么素质"><a href="#2-2-二慢：看看所招岗位需要什么素质" class="headerlink" title="2.2 二慢：看看所招岗位需要什么素质"></a>2.2 二慢：看看所招岗位需要什么素质</h2><ul>
<li>简单工作分析——他上班后要做什么</li>
<li>提炼关键事件——要做的工作中最困难的是什么</li>
<li>确定胜任核心素质——要克服最困难的事需要什么素质</li>
</ul>
<h2 id="2-3-三通过-通过行为面试法看人不走眼"><a href="#2-3-三通过-通过行为面试法看人不走眼" class="headerlink" title="2.3 三通过: 通过行为面试法看人不走眼"></a>2.3 三通过: 通过行为面试法看人不走眼</h2><p>STAR行为面试法：多问过去，少问将来</p>
<ul>
<li>情景：Situation</li>
<li>目标/任务: Target/Task</li>
<li>行动：Action</li>
<li>结果：Result</li>
</ul>
<h1 id="三、育才实操篇"><a href="#三、育才实操篇" class="headerlink" title="三、育才实操篇"></a>三、育才实操篇</h1><ul>
<li>培训篇：一个中心与两个基本点</li>
<li>辅导篇：做员工的最佳教练</li>
<li>培训篇：与公司同成长的4种规划方式</li>
</ul>
<h2 id="3-1-培训篇：一个中心与两个基本点"><a href="#3-1-培训篇：一个中心与两个基本点" class="headerlink" title="3.1 培训篇：一个中心与两个基本点"></a>3.1 培训篇：一个中心与两个基本点</h2><p>一个中心：员工<br>第一个基本点：培训需求分析<br>第二个基本点：培训效果追踪</p>
<h3 id="第一个基本点：培训需求分析"><a href="#第一个基本点：培训需求分析" class="headerlink" title="第一个基本点：培训需求分析"></a>第一个基本点：培训需求分析</h3><table>
<thead>
<tr>
<th>分析</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>组织分析</td>
<td>决定组织种哪里要培训</td>
</tr>
<tr>
<td>任务分析</td>
<td>决定培训什么内容</td>
</tr>
<tr>
<td>人员分析</td>
<td>决定谁该接受培训</td>
</tr>
</tbody></table>
<h3 id="第二个基本点：培训效果评估"><a href="#第二个基本点：培训效果评估" class="headerlink" title="第二个基本点：培训效果评估"></a>第二个基本点：培训效果评估</h3><p>反应：针对学员对课程及学习过程的满意度进行评估。<br>学习：针对学员完成课程后，所保留的学习成效进行评估。<br>行为：针对学员回岗位后，其行为或绩效是否因培训而有改变进行评估。<br>结果：针对培训的整体投资报酬率进行评估。</p>
<h2 id="3-2-辅导篇：做员工的最佳教练"><a href="#3-2-辅导篇：做员工的最佳教练" class="headerlink" title="3.2 辅导篇：做员工的最佳教练"></a>3.2 辅导篇：做员工的最佳教练</h2><p>接受：认识到培训重要，允许员工去培训<br>鼓励：调整工作安排鼓励员工参加培训<br>强化：培训完与其探讨如何支持其新技能<br>给机会：员工学到新技能后有实践机会<br>教练：作为教练全程辅导</p>
<h2 id="3-3-培训篇：与公司同成长的4种规划方式"><a href="#3-3-培训篇：与公司同成长的4种规划方式" class="headerlink" title="3.3 培训篇：与公司同成长的4种规划方式"></a>3.3 培训篇：与公司同成长的4种规划方式</h2><p>个人职业规划，确保个人在组织种的进步，其表现和潜力符合组织的需要：<br>1、升职<br>2、轮岗<br>3、工作扩大化<br>4、工作丰富化</p>
<h1 id="四、用才篇——绩效管理"><a href="#四、用才篇——绩效管理" class="headerlink" title="四、用才篇——绩效管理"></a>四、用才篇——绩效管理</h1><h2 id="4-1-员工绩效为什么不高？"><a href="#4-1-员工绩效为什么不高？" class="headerlink" title="4.1 员工绩效为什么不高？"></a>4.1 员工绩效为什么不高？</h2><h3 id="绩效反馈反面"><a href="#绩效反馈反面" class="headerlink" title="绩效反馈反面"></a>绩效反馈反面</h3><ul>
<li>无反馈或无效反馈</li>
</ul>
<h3 id="平时的阻碍"><a href="#平时的阻碍" class="headerlink" title="平时的阻碍"></a>平时的阻碍</h3><ul>
<li>身体生病</li>
<li>精神压力大</li>
<li>感情受挫</li>
<li>被要求在同一时间完成相矛盾的工作</li>
<li>缺乏足够的资源来做事</li>
</ul>
<h3 id="绩效标准方面"><a href="#绩效标准方面" class="headerlink" title="绩效标准方面"></a>绩效标准方面</h3><ul>
<li>绩效标准不量化</li>
<li>没跟员工沟通而直接派活</li>
<li>绩效标准太高</li>
</ul>
<h3 id="绩效后果方面"><a href="#绩效后果方面" class="headerlink" title="绩效后果方面"></a>绩效后果方面</h3><ul>
<li>考完后没有重奖重罚</li>
<li>绩效后果不刺激员工行为</li>
</ul>
<h3 id="员工本身的技能方面"><a href="#员工本身的技能方面" class="headerlink" title="员工本身的技能方面"></a>员工本身的技能方面</h3><ul>
<li>员工不知道怎样做</li>
</ul>
<h2 id="4-2-如何设定量化指标，并分解给部门"><a href="#4-2-如何设定量化指标，并分解给部门" class="headerlink" title="4.2 如何设定量化指标，并分解给部门?"></a>4.2 如何设定量化指标，并分解给部门?</h2><ul>
<li>Specific: 特定的</li>
<li>Measurable：可衡量的</li>
<li>Agreed：双方同意的</li>
<li>Realistic：现实的</li>
<li>Time-bond：有时间限制的</li>
</ul>
<blockquote>
<h3 id="绩效目标"><a href="#绩效目标" class="headerlink" title="绩效目标"></a>绩效目标</h3></blockquote>
<ul>
<li>对要达成的结果的一个表述</li>
<li>更适于经理们和专业员工等涉及个人项目的工作</li>
</ul>
<blockquote>
<h3 id="绩效标准"><a href="#绩效标准" class="headerlink" title="绩效标准"></a>绩效标准</h3></blockquote>
<ul>
<li>是一种延续的，须一次又一次遵守的准则</li>
<li>更适用于从事日常需要及重复性作业的工作</li>
</ul>
<h2 id="4-3-建设性反馈方法"><a href="#4-3-建设性反馈方法" class="headerlink" title="4.3 建设性反馈方法"></a>4.3 建设性反馈方法</h2><p>“汉堡”原则</p>
<ul>
<li>先表扬特定的成就，给予真心的肯定</li>
<li>然后提出需要改进的“特定”的行为表现</li>
<li>最后肯定和支持结果</li>
</ul>
<h2 id="4-4-如何友好地结束面谈"><a href="#4-4-如何友好地结束面谈" class="headerlink" title="4.4 如何友好地结束面谈"></a>4.4 如何友好地结束面谈</h2><ol>
<li>确认员工理解你的每一个评估</li>
<li>可以请员工在面谈记录上签字确认</li>
<li>永远以积极的言谈结束谈话</li>
</ol>
<p><font clolor="#ff0000">！！！不要轻易许诺你不确认的事</font></p>
<h1 id="五、留才篇——多用“薪”不如多用“心”"><a href="#五、留才篇——多用“薪”不如多用“心”" class="headerlink" title="五、留才篇——多用“薪”不如多用“心”"></a>五、留才篇——多用“薪”不如多用“心”</h1><h2 id="5-1-激励是管理中的核心问题"><a href="#5-1-激励是管理中的核心问题" class="headerlink" title="5.1 激励是管理中的核心问题"></a>5.1 激励是管理中的核心问题</h2><blockquote>
<p><font color="#ff0000">危机激励</font>: 负强化，企业必须要做的事    </p>
</blockquote>
<ol>
<li>物质激励</li>
<li>精神激励</li>
<li>培训激励</li>
<li>目标激励</li>
<li>参与激励</li>
<li>情感激励</li>
<li>信任激励</li>
<li>晋升激励</li>
<li>荣誉激励</li>
<li>榜样激励</li>
</ol>
<h2 id="5-2-Maslow-马斯洛——需求层次理论"><a href="#5-2-Maslow-马斯洛——需求层次理论" class="headerlink" title="5.2 Maslow 马斯洛——需求层次理论"></a>5.2 Maslow 马斯洛——需求层次理论</h2><h3 id="更适合激励核心员工-20"><a href="#更适合激励核心员工-20" class="headerlink" title="更适合激励核心员工(20%)"></a><font color="#ff000">更适合激励核心员工</font>(20%)</h3><ol>
<li>生理需求</li>
<li>安全需求</li>
<li>归属需求</li>
<li>尊重需求</li>
<li>自我实现需求</li>
</ol>
<h2 id="5-3-三种高管适用的个人激励方法"><a href="#5-3-三种高管适用的个人激励方法" class="headerlink" title="5.3 三种高管适用的个人激励方法"></a>5.3 三种高管适用的个人激励方法</h2><ol>
<li>制度激励——让优秀员工与众不同</li>
<li>职业生涯规划激励（升职；轮岗；工作扩大化；工作丰富化）</li>
<li>企业文化留人</li>
</ol>
<h2 id="5-4-四种中层管理者适用的个人激励方法"><a href="#5-4-四种中层管理者适用的个人激励方法" class="headerlink" title="5.4 四种中层管理者适用的个人激励方法"></a>5.4 四种中层管理者适用的个人激励方法</h2><ol>
<li>期望留人-罗森塔尔效应——我知道你可以的</li>
<li>工作扩大化与丰富化——让员工有机会进步（工作轮换，工作扩大化，工作丰富化）</li>
<li>得人心者得天下——感情激励</li>
<li>巧用团体压力——团队激励（群体动力学）</li>
</ol>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>人力资源管理得核心事：选、育、用、留。</p>
<ul>
<li>选：行为面试法结合STAR法则</li>
<li>育：围绕员工这个核心，分析要培训什么，追踪培训效果，做好员工的帮、扶、带</li>
<li>用：基于SMART法则设定量化目标，做好绩效面谈及反馈</li>
<li>留：观察员工得需求，采用适当得激励方式</li>
</ul>
]]></content>
      <categories>
        <category>thought</category>
      </categories>
      <tags>
        <tag>人力资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器重启后mysqld.service未创建/var/run/mysqld</title>
    <url>/2021/12/20/mysql/linux-fu-wu-qi-chong-qi-hou-mysqld.service-wei-chuang-jian-mysqld.pid-fu-mu-lu-wen-ti/</url>
    <content><![CDATA[<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>开发环境的数据库服务器重启后，启动MySQl服务报错，错误如下：</p>
<pre class="line-numbers language-none"><code class="language-none">[ERROR] &#x2F;usr&#x2F;sbin&#x2F;mysqld: Can&#39;t create&#x2F;write to file &#39;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid&#39; (Errcode: 2 - No such file or directory)
[ERROR] Can&#39;t start server: can&#39;t create PID file: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>之前看到上面错误日志都是手动创建<code>/var/run/mysqld</code>目录，然后将目录的属主修改为mysql用户，如下：</p>
<pre class="line-numbers language-none"><code class="language-none">mkdir -p &#x2F;var&#x2F;run&#x2F;mysqld
chown mysql:mysql &#x2F;var&#x2F;run&#x2F;mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面方式，每次服务器重启后都要重新执行，所以分析一下问题原因，探索一种永久的解决方案。</p>
<blockquote>
<p>MySQL版本信息<br>mysql  Ver 14.14 Distrib 5.7.10, for Linux (x86_64) using  EditLine wrapper</p>
</blockquote>
<h1 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h1><p>通过查找发现该问题是MySQL5.7的一个小bug，详见：<br><a href="https://bugs.mysql.com/bug.php?id=100506">Bug #100506    mysqld.service does not create /var/run/mysqld after reboot</a></p>
<p>该问题的主要原因是/var/run目录是一个临时目录，存在于内存之中，系统重启后/var/run目录下的文件将会被擦除。</p>
<pre class="line-numbers language-none"><code class="language-none">[root@develop log]# ll &#x2F;var&#x2F;run
lrwxrwxrwx. 1 root root 6 Sep 27 22:33 &#x2F;var&#x2F;run -&gt; ..&#x2F;run

[root@develop log]# df -hT
Filesystem                Type      Size  Used Avail Use% Mounted on
&#x2F;dev&#x2F;mapper&#x2F;centos00-root xfs        30G   22G  8.0G  74% &#x2F;
devtmpfs                  devtmpfs   16G     0   16G   0% &#x2F;dev
tmpfs                     tmpfs      16G     0   16G   0% &#x2F;dev&#x2F;shm
tmpfs                     tmpfs      16G  682M   15G   5% &#x2F;run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面可以看出，<code>/var/run</code>目录通过软连接挂载在<code>/run</code>目录下，<code>/run</code>目录文件系统类型为<code>tmpfs</code></p>
<h2 id="原因总结："><a href="#原因总结：" class="headerlink" title="原因总结："></a>原因总结：</h2><p>安装MySQL时，mysql-community-server-5.7.31-1.el7.x86_64 rpm 创建了<code>/var/run/mysqld</code>目录，系统重启后这个目录被擦除了。</p>
<h1 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>使用<code>tmpfiles.d</code>在系统启动的时候创建<code>/var/run/mysqld</code>目录，<a href="https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html">tmpfiles.d简介</a>。<br>在<code>/usr/lib/tmpfiles.d</code>目录下创建<code>mysql.conf</code>文件，文件内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">d &#x2F;run&#x2F;mysqld 0755 mysql mysql  -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或直接使用如下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">echo &quot;d &#x2F;var&#x2F;run&#x2F;mysqld 0755 mysql mysql -&quot; &gt; &#x2F;usr&#x2F;lib&#x2F;tmpfiles.d&#x2F;mysql.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>操作系统重启后会根据<code>/usr/lib/tmpfiles.d/mysql.conf</code>创建<code>/var/run/mysqld</code>目录。</p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>修改MySQL配置文件<code>/etc/my.cnf</code>中的<code>pid-file</code>的路径，文件内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">
datadir&#x3D;&#x2F;data&#x2F;deploy&#x2F;mysql&#x2F;data
socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock

# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links&#x3D;0

log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.log
pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid

skip-external-locking
key_buffer_size &#x3D; 256M
max_allowed_packet &#x3D; 16M
table_open_cache &#x3D; 2048
sort_buffer_size &#x3D; 2M
read_buffer_size &#x3D; 2M
read_rnd_buffer_size &#x3D; 8M
myisam_sort_buffer_size &#x3D; 64M
thread_cache_size &#x3D; 64
query_cache_size &#x3D; 256M
max_connections &#x3D; 1024

default-storage-engine&#x3D;INNODB
lower_case_table_names&#x3D;1
explicit_defaults_for_timestamp&#x3D;true
sql_mode&#x3D;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
character_set_server&#x3D; utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将’pid-file<code>文件路径修改为</code>/var/lib/mysql`.</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中MVCC是否真的能够解决幻读问题？</title>
    <url>/2019/04/30/mysql/mysql-zhong-mvcc-shi-fou-zhen-de-neng-gou-jie-jue-huan-du-wen-ti/</url>
    <content><![CDATA[<p>&emsp;&emsp;偶然间看到同事在看MySQL的MVCC问题，就随口插了一句，“MVCC模式解决了MySQL中的幻读问题”，但是</p>
<p>同事告诉我并没有，我说不可能，我清楚的记得在看《高性能MySQL 第3版》一书的事务隔离级别中的，在介绍**REPEATABLE READ **隔离级别时候提过，MVCC解决了幻读的问题。说完我还找到了书中内容给他看，内容如下：</p>
<p>英文原版：</p>
<blockquote>
<ul>
<li>REPEATABLE READ </li>
</ul>
<p> REPEATABLE READ solves the problems that READ UNCOMMITTED allows. It guarantees<br> that any rows a transaction reads will “look the same” in subsequent reads within<br> the same transaction, but in theory it still allows another tricky problem: phantom<br> reads. Simply put, a phantom read can happen when you select some range of rows,<br> another transaction inserts a new row into the range, and then you select the same<br> range again; you will then see the new “phantom” row. InnoDB and XtraDB solve<br> the phantom read problem with multiversion concurrency control, which we explain later in this chapter.<br> REPEATABLE READ is MySQL’s default transaction isolation level. </p>
</blockquote>
<p>中文版：</p>
<blockquote>
<ul>
<li><p>REPEATABLE READ(可重复读)</p>
<p>REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上,可重复读隔离级别还是无法解决另外一个幻读( Phantom read)的问题。所谓幻读,指的是当某个事务在读取某个范围内的记录时另外一个事务又在该范围内插入了新的记录,当之前的事务再次读取该范围的记录时,会产生幻行( Phantom row)。 InnoDB和 XtraDB存储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control)解决了幻读的问题。本章稍后会做进一步的讨论。</p>
<p>可重复读是 MySQL的默认事务隔离级别。</p>
</li>
</ul>
</blockquote>
<p>同事说这也是他正在查找的问题，并给我演示了一个案例，相关表结构数据如下：</p>
<pre class="line-numbers language-none"><code class="language-none">CREATE TABLE &#96;employee&#96; (
  &#96;Id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;Name&#96; varchar(50) DEFAULT NULL,
  &#96;Salary&#96; int(11) DEFAULT NULL,
  &#96;DepartmentId&#96; int(11) DEFAULT NULL,
  PRIMARY KEY (&#96;Id&#96;)
) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;5 DEFAULT CHARSET&#x3D;utf8;

insert  into &#96;employee&#96;(&#96;Id&#96;,&#96;Name&#96;,&#96;Salary&#96;,&#96;DepartmentId&#96;) values (1,&#39;Joe&#39;,70000,1);
insert  into &#96;employee&#96;(&#96;Id&#96;,&#96;Name&#96;,&#96;Salary&#96;,&#96;DepartmentId&#96;) values (2,&#39;Henry&#39;,80000,2);
insert  into &#96;employee&#96;(&#96;Id&#96;,&#96;Name&#96;,&#96;Salary&#96;,&#96;DepartmentId&#96;) values (3,&#39;Sam&#39;,6000,2);
insert  into &#96;employee&#96;(&#96;Id&#96;,&#96;Name&#96;,&#96;Salary&#96;,&#96;DepartmentId&#96;) values (4,&#39;Max&#39;,90000,1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>事务执行流程如下：</p>
<p><img src="/2019/04/30/mysql/mysql-zhong-mvcc-shi-fou-zhen-de-neng-gou-jie-jue-huan-du-wen-ti/%E4%BA%8B%E5%8A%A1%E6%BC%94%E7%A4%BA.png" alt="MySQL幻读的情景演示"></p>
<ul>
<li><p>1、开始事务A</p>
</li>
<li><p>2、查询employee表中所有数据</p>
<p><img src="/2019/04/30/mysql/mysql-zhong-mvcc-shi-fou-zhen-de-neng-gou-jie-jue-huan-du-wen-ti/%E5%BC%80%E5%A7%8B%E4%BA%8B%E5%8A%A1A.png" alt="开始事务A"></p>
</li>
<li><p>3、开始事务B</p>
</li>
<li><p>4、向employee表中插入2条数据</p>
</li>
<li><p>5、提交事务B</p>
<p><img src="/2019/04/30/mysql/mysql-zhong-mvcc-shi-fou-zhen-de-neng-gou-jie-jue-huan-du-wen-ti/%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1B.png" alt="执行事务B"></p>
</li>
<li><p>6、在事务A中执行查询</p>
<p><img src="/2019/04/30/mysql/mysql-zhong-mvcc-shi-fou-zhen-de-neng-gou-jie-jue-huan-du-wen-ti/%E4%BA%8B%E5%8A%A1B%E6%8F%90%E4%BA%A4%E5%90%8E%E5%86%8D%E6%AC%A1%E5%9C%A8%E4%BA%8B%E5%8A%A1A%E4%B8%AD%E6%9F%A5%E8%AF%A2.png" alt="事务B提交后再次在事务A中查询"></p>
</li>
</ul>
<p>&emsp;&emsp;从这里我们可以看出MySQL的默认事务隔离级别（REPEATABLE READ）解决不可重复读的问题，但是对于幻读我们继续验证。</p>
<ul>
<li><p>7、更新employee表中的所有数据， 将DepartmentId都设置为1</p>
</li>
<li><p>8、更新操作执行后再次查询</p>
<p><img src="/2019/04/30/mysql/mysql-zhong-mvcc-shi-fou-zhen-de-neng-gou-jie-jue-huan-du-wen-ti/%E6%9B%B4%E6%96%B0%E5%90%8E%E5%86%8D%E6%AC%A1%E6%9F%A5%E8%AF%A2.png" alt="更新后再次查询"></p>
</li>
</ul>
<p>此时我们发现，在A事务中竟然能够查看到B事务插入的2条数据，我们再来回顾一下脏读、不可重复读和幻读的定义及现象：</p>
<p>以下内容均来自MySQL官网：<a href="https://dev.mysql.com/doc/refman/5.7/en/">https://dev.mysql.com/doc/refman/5.7/en/</a></p>
<p><strong>脏读：</strong></p>
<blockquote>
<ul>
<li><p>dirty read </p>
<p>An operation that retrieves unreliable data, data that was updated by another transaction but not yet committed. It is only possible with the isolation level known as read uncommitted.  </p>
</li>
</ul>
</blockquote>
<p>脏读意味着一个事务读取了另一个事务未提交的数据,而这个数据是有可能回滚。</p>
<p><strong>不可重复读：</strong></p>
<blockquote>
<ul>
<li><p>non-repeatable read </p>
<p>The situation when a query retrieves data, and a later query within the same transaction retrieves what should be the same data, but the queries return different results (changed by another transaction committing in the meantime). </p>
</li>
</ul>
</blockquote>
<p>不可重复读意味着在同一个事务中，不同时间的相同查询的返回结果不一致，由于另外已提交的事务修改了数据。</p>
<p><strong>幻读：</strong></p>
<blockquote>
<ul>
<li><p>phantom </p>
<p>A row that appears in the result set of a query, but not in the result set of an earlier query. For example, if a query is run twice within a transaction, and in the meantime, another transaction commits after inserting a new row or updating a row so that it matches the WHERE clause of the query. </p>
</li>
</ul>
</blockquote>
<p>幻读意味着在同一个事务中，相同的查询在最新的结果集中出现了新的行数据。</p>
<p>总结：根据上面的实验案例以及幻读的定义，上述案例确实存在幻读的问题，接下来我们简单介绍一下MVCC的实现原理，并结合MySQL源码分析一下幻读产生的原因。</p>
<h1 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h1><p>为什么会出现幻读的问题？在解释这个问题之前，我们先简单介绍一下MySQL中MVCC。</p>
<p><strong>MVCC简介：</strong></p>
<p>引用：<a href="http://mysql.taobao.org/monthly/2017/12/01/">[阿里数据库内核’2017/12’月报]</a></p>
<blockquote>
<p>多版本并发控制(Multiversion concurrency control， MCC 或 <strong>MVCC</strong>)指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p>
</blockquote>
<p>下面两篇文章对MySQL的InnoDB的MVCC实现进行详细介绍：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000012650596">MySQL-InnoDB-MVCC多版本并发控制</a></li>
<li><a href="http://mysql.taobao.org/monthly/2017/12/01/">[阿里数据库内核’2017/12’月报]</a></li>
</ul>
<h1 id="为什么会出现幻读？"><a href="#为什么会出现幻读？" class="headerlink" title="为什么会出现幻读？"></a>为什么会出现幻读？</h1><p>在了解了MVCC的原理之后我们再来看一下源码</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">UNIV_INTERN
dberr_t
row_search_for_mysql(
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
  byte*   buf,    &#x2F;* 用来存放记录的空间地址 *&#x2F;
  ulint   mode,   &#x2F;* InnoDB页扫描顺序 *&#x2F;
  row_prebuilt_t* prebuilt, &#x2F;* InnoDB扫描需要的所有信息都包含在这个结构体，比如表以及Index等信息 *&#x2F;
  ulint   match_mode, &#x2F;* 对于Index的匹配模式，是精确匹配还是前缀索引匹配 *&#x2F;
  ulint   direction)  &#x2F;* 指定扫描顺序，正序还是倒叙扫描 *&#x2F;
&#123;
	...
	&#x2F;* 从这里我们看出开始一个新事务，并非是从执行BEGIN语句位置开始，而是从其后开始执行的第一条语句开始分配事务ID *&#x2F;
	trx_start_if_not_started(trx, ((trx-&gt;mysql_thd
          &amp;&amp; thd_is_select(trx-&gt;mysql_thd)
          ) || srv_read_only_mode) ? FALSE : TRUE); 

	...
	&#x2F;&#x2F; 如果是SQL语句第一次开始执行，需要考虑对TABLE增加意向所

	 if (!prebuilt-&gt;sql_stat_start) &#123;
	 &#x2F;&#x2F; 这里标记SQL语句已经开始执行，处理一条SQL语句循环扫描记录的过程
    &#x2F;* No need to set an intention lock or assign a read view *&#x2F;

    if (UNIV_UNLIKELY
        (trx-&gt;read_view &#x3D;&#x3D; NULL 
         &amp;&amp; prebuilt-&gt;select_lock_type &#x3D;&#x3D; LOCK_NONE)) &#123;
      ...
	    &#125;
  &#125; else if (prebuilt-&gt;select_lock_type &#x3D;&#x3D; LOCK_NONE) &#123;
	...
  &#125; else &#123;
	&#x2F;&#x2F; 这里开始非INSERT的DML操作，因为DML会对记录增加记录排他锁。具体需要增加什么类型的锁，可以参考https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;innodb-locking.html
 wait_table_again:
	&#x2F;&#x2F; 这里要对TABLE加意向锁
    err &#x3D; lock_table(0, index-&gt;table,
         prebuilt-&gt;select_lock_type &#x3D;&#x3D; LOCK_S
         ? LOCK_IS : LOCK_IX, thr);

    if (err !&#x3D; DB_SUCCESS) &#123;

      table_lock_waited &#x3D; TRUE;
      goto lock_table_wait;
    &#125;    
    prebuilt-&gt;sql_stat_start &#x3D; FALSE;
  &#125;

	...
  if (prebuilt-&gt;select_lock_type !&#x3D; LOCK_NONE) &#123;
	 ulint lock_type;

    if (!set_also_gap_locks
        || srv_locks_unsafe_for_binlog
        || trx-&gt;isolation_level &lt;&#x3D; TRX_ISO_READ_COMMITTED
        || (unique_search &amp;&amp; !rec_get_deleted_flag(rec, comp))) &#123;
	  &#x2F;&#x2F; 这里对于READ_UNCOMMITTED以及READ_COMMITTED,或者唯一键扫描不需要使用gap锁
      goto no_gap_lock;
    &#125; else &#123;
      lock_type &#x3D; LOCK_ORDINARY;
    &#125;
	
	&#x2F;* If we are doing a &#39;greater or equal than a primary key
    value&#39; search from a clustered index, and we find a record
    that has that exact primary key value, then there is no need
    to lock the gap before the record, because no insert in the
    gap can be in our search range. That is, no phantom row can
    appear that way.

    An example: if col1 is the primary key, the search is WHERE
    col1 &gt;&#x3D; 100, and we find a record where col1 &#x3D; 100, then no
    need to lock the gap before that record. *&#x2F;

    if (index &#x3D;&#x3D; clust_index
        &amp;&amp; mode &#x3D;&#x3D; PAGE_CUR_GE
        &amp;&amp; direction &#x3D;&#x3D; 0
        &amp;&amp; dtuple_get_n_fields_cmp(search_tuple)
        &#x3D;&#x3D; dict_index_get_n_unique(index)
        &amp;&amp; 0 &#x3D;&#x3D; cmp_dtuple_rec(search_tuple, rec, offsets)) &#123;
no_gap_lock:
      lock_type &#x3D; LOCK_REC_NOT_GAP;
    &#125;

	    err &#x3D; sel_set_rec_lock(btr_pcur_get_block(pcur),
               rec, index, offsets,
               prebuilt-&gt;select_lock_type,
               lock_type, thr);

    switch (err) &#123;
      const rec_t*  old_vers;
    case DB_SUCCESS_LOCKED_REC:
      if (srv_locks_unsafe_for_binlog
          || trx-&gt;isolation_level
          &lt;&#x3D; TRX_ISO_READ_COMMITTED) &#123;
        &#x2F;* Note that a record of
        prebuilt-&gt;index was locked. *&#x2F;
        prebuilt-&gt;new_rec_locks &#x3D; 1;
      &#125;
      err &#x3D; DB_SUCCESS;
    case DB_SUCCESS:
	 &#x2F;&#x2F; 加锁成功后就认为记录可见了，并未像SELECT语句一样根据事务开始的READ_VIEW进行可见性判断。所以对于DML来说，所有提交的事务都是可见的。
      break;
    case DB_LOCK_WAIT:
	      &#x2F;* Never unlock rows that were part of a conflict. *&#x2F;
	  &#x2F;&#x2F; 如果存在锁冲突，也就是其他事务正在更新同一行
      prebuilt-&gt;new_rec_locks &#x3D; 0;

      if (UNIV_LIKELY(prebuilt-&gt;row_read_type
          !&#x3D; ROW_READ_TRY_SEMI_CONSISTENT)
          || unique_search
          || index !&#x3D; clust_index) &#123;

        goto lock_wait_or_error;
      &#125;

      &#x2F;* The following call returns &#39;offsets&#39;
      associated with &#39;old_vers&#39; *&#x2F;
	  &#x2F;&#x2F; 这里需要查看是否有别的事务提交了，以便获取最新版本的记录
      row_sel_build_committed_vers_for_mysql(
        clust_index, prebuilt, rec,
        &amp;offsets, &amp;heap, &amp;old_vers, &amp;mtr);

      &#x2F;* Check whether it was a deadlock or not, if not
      a deadlock and the transaction had to wait then
      release the lock it is waiting on. *&#x2F;
	        err &#x3D; lock_trx_handle_wait(trx);

      switch (err) &#123;
      case DB_SUCCESS:
        &#x2F;* The lock was granted while we were
        searching for the last committed version.
        Do a normal locking read. *&#x2F;

        offsets &#x3D; rec_get_offsets(
          rec, index, offsets, ULINT_UNDEFINED,
          &amp;heap);
        goto locks_ok;
      case DB_DEADLOCK:
        goto lock_wait_or_error;
      case DB_LOCK_WAIT:
        err &#x3D; DB_SUCCESS;
        break;
      default:
        ut_error;
      &#125;
	        if (old_vers &#x3D;&#x3D; NULL) &#123;
        &#x2F;* The row was not yet committed *&#x2F;

        goto next_rec;
      &#125;
	  did_semi_consistent_read &#x3D; TRUE;
      rec &#x3D; old_vers;
      break;
    default:

      goto lock_wait_or_error;
    &#125;

	&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>从上面的代码我们可以看到，对于UPDATE操作更新的记录包含幻读读取到的已提交事务的最新记录。那么接下来看为什么UPDATE之后的SELECT语句对于UPDATE之后的所有语句都可见了？ 原因是前面的UPDATE语句执行之后，会将当前记录上存储的事务信息更新为当前的事务，而当前事务所做的任何更新，对本事务所有SELECT查询都变的可见，因此最后输出的结果是UPDATE执行后更新的所有记录。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上我们可以知道，MySQL的**REPEATABLE READ **隔离级别和MVCC只解决了部分幻读的问题，意味着这一隔离级别仍旧可能出现幻读。该问题的发现同时也提醒着以后不能死读书，应该边读边想多实践，把书中的知识转换为我们自己的想法，而不是生搬硬套。</p>
<blockquote>
<p><strong>引用参考</strong></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">MySQL官网</a></p>
<p><a href="http://mysql.taobao.org/monthly/2017/06/07/">MySQL · 源码分析 · InnoDB Repeatable Read隔离级别之大不同</a></p>
<p><a href="http://mysql.taobao.org/monthly/2017/12/01/">[阿里数据库内核’2017/12’月报]</a></p>
<p><a href="http://mysql.taobao.org/monthly/2017/06">[数据库内核月报 2017 / 06]</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql mvcc</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL插入速度测试</title>
    <url>/2019/07/02/mysql/mysql-cha-ru-su-du-ce-shi/</url>
    <content><![CDATA[<h2 id="一、测试环境"><a href="#一、测试环境" class="headerlink" title="一、测试环境"></a>一、测试环境</h2><h3 id="1-1-硬件环境"><a href="#1-1-硬件环境" class="headerlink" title="1.1 硬件环境"></a>1.1 硬件环境</h3><table>
<thead>
<tr>
<th>名称</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>win7 64位</td>
</tr>
<tr>
<td>CPU</td>
<td>4核4线程 i5-4590</td>
</tr>
<tr>
<td>内存</td>
<td>16G</td>
</tr>
<tr>
<td>硬盘</td>
<td>128G SSD</td>
</tr>
<tr>
<td>MySQL</td>
<td>Version 5.6</td>
</tr>
</tbody></table>
<h3 id="1-2-数据库表结构"><a href="#1-2-数据库表结构" class="headerlink" title="1.2 数据库表结构"></a>1.2 数据库表结构</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token punctuation">(</span>
  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>username<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>password<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>sex<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>phone<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>email<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>remark<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二、插入实验"><a href="#二、插入实验" class="headerlink" title="二、插入实验"></a>二、插入实验</h2><h3 id="2-1-普通插入"><a href="#2-1-普通插入" class="headerlink" title="2.1 普通插入"></a>2.1 普通插入</h3><table>
<thead>
<tr>
<th>线程数</th>
<th>插入量（万）</th>
<th>总耗时（毫秒）</th>
<th>平均插入速度（条/秒）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>100</td>
<td>342844</td>
<td>2923</td>
</tr>
<tr>
<td>4</td>
<td>400</td>
<td>480112</td>
<td>8333</td>
</tr>
<tr>
<td>8</td>
<td>800</td>
<td>693702</td>
<td>11544</td>
</tr>
<tr>
<td>16</td>
<td>1600</td>
<td>1246522</td>
<td>12841</td>
</tr>
</tbody></table>
<h3 id="2-2-批量插入"><a href="#2-2-批量插入" class="headerlink" title="2.2 批量插入"></a>2.2 批量插入</h3><blockquote>
<p>批次大小： 500条</p>
</blockquote>
<table>
<thead>
<tr>
<th>线程数</th>
<th>插入量（万）</th>
<th>总耗时（毫秒）</th>
<th>平均插入速度（条/秒）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>100</td>
<td>42793</td>
<td>23364</td>
</tr>
<tr>
<td>4</td>
<td>400</td>
<td>58856</td>
<td>68027</td>
</tr>
<tr>
<td>8</td>
<td>800</td>
<td>109688</td>
<td>72939</td>
</tr>
<tr>
<td>16</td>
<td>1600</td>
<td>216542</td>
<td>73903</td>
</tr>
</tbody></table>
<blockquote>
<p>批次大小： 1000条</p>
</blockquote>
<table>
<thead>
<tr>
<th>线程数</th>
<th>插入量（万）</th>
<th>总耗时（毫秒）</th>
<th>平均插入速度（条/秒）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>100</td>
<td>42771</td>
<td>23380</td>
</tr>
<tr>
<td>4</td>
<td>400</td>
<td>55098</td>
<td>72595</td>
</tr>
<tr>
<td>8</td>
<td>800</td>
<td>106554</td>
<td>75082</td>
</tr>
<tr>
<td>16</td>
<td>1600</td>
<td>216353</td>
<td>73971</td>
</tr>
</tbody></table>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>本次实验主要是测试一下MySQL的插入速度到底有多快，让我们在开发过程中心理有底，测试数据库文件是存储到固态硬盘上的，所以速度肯定比在普通磁盘上快。测试主要围绕多线程插入和批量插入这两个点，从实验结果来看，我们可以得出以下两点结论：</p>
<ul>
<li>多线程插入确实是能够提高MySQL的插入速度，但是线程数超过系统核心线程数后，已经没有太大提升效果，所以建议多线程插入时，线程数保持和系统核心线程数一致。</li>
<li>MySQL批量插入能极大提高插入速度，每批次1000条插入的速度是单条插入速度的8倍左右，在大数据量插入时建议使用批量插入的方式，批次大小建议设置为1000条左右，可根据具体的业务情况调整。MySQL数据包默认大小为4M，超过该值会导致插入或更新失败，批量插入时应考虑该因素，可通过<code>SHOW VARIABLES LIKE &#39;%max_allowed_packet%&#39;</code>查看，该值可以修改。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引合并优化</title>
    <url>/2022/01/07/mysql/mysql-suo-yin-he-bing-you-hua/</url>
    <content><![CDATA[<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>之前遇到过一个关于MySQL索引的面试题，问题如下：</p>
<blockquote>
<p>一张数据库表t其中有3列为a、b、c，分别为每一个列单独建立一个二级索引，那么现在有一个查询条件<code>select * from t where a=? and b=? and c=?</code><br>请问上述SQL语句，MySQL存储引擎在执行查询的时候，哪些索引将会被使用到？</p>
</blockquote>
<p>当时一顿分析，还谈到了MySQL基于成本估算的优化，认为MySQL优化器先基于a、b、c三个列的索引区分度，选择索引区分度较高的索引进行扫描，根据第一个索引的扫描结果，如果第一个索引的扫描结果集高于一个固定量级，则继续选择第二个索引进行扫描，依次判断是否需要使用第三个索引，如果第一个索引的扫描结果集小于一个固定量级，则直接根据第一个索引的扫描结果集进行回表查询到列记录，再根据未使用到的2列进行过滤。</p>
<p>最后得出的结果是：a、b、c 3个索引都可能被使用到，具体使用到哪些索引，取决于3个索引的区分度以及表的数据量。</p>
<h2 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h2><p>上面的问题应该用<code>索引合并优化</code>的原理来分析，上述的SQL的where条件满足了索引合并优化中的<code>Index Merge Intersection Access Algorithm</code>,<br>存储引擎将会同时使用3个索引进行扫描，将扫描到的结果集取交集后返回给MySQL Server，然后再进行回表查询。</p>
<h1 id="二、索引合并优化"><a href="#二、索引合并优化" class="headerlink" title="二、索引合并优化"></a>二、索引合并优化</h1><p>索引合并访问方法检索具有多个范围扫描的行并将其结果合并为一个。 此访问方法仅合并来自单个表的索引扫描，而不是跨多个表的扫描。 合并可以生成其底层扫描的并集、交集或交集并集。</p>
<h2 id="索引合并的查询案例"><a href="#索引合并的查询案例" class="headerlink" title="索引合并的查询案例"></a>索引合并的查询案例</h2><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM tbl_name WHERE key1 &#x3D; 10 OR key2 &#x3D; 20;

SELECT * FROM tbl_name
  WHERE (key1 &#x3D; 10 OR key2 &#x3D; 20) AND non_key &#x3D; 30;

SELECT * FROM t1, t2
  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#39;value%&#39;)
  AND t2.key1 &#x3D; t1.some_col;

SELECT * FROM t1, t2
  WHERE t1.key1 &#x3D; 1
  AND (t2.key1 &#x3D; t1.some_col OR t2.key2 &#x3D; t1.some_col2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>索引合并优化具有以下已知限制：</p>
<ul>
<li>如果您的查询有一个带有深度 AND/OR 嵌套的复杂 WHERE 子句，并且 MySQL 没有选择最佳计划，请尝试使用以下身份转换分配术语：<pre class="line-numbers language-none"><code class="language-none">(x AND y) OR z &#x3D;&gt; (x OR z) AND (y OR z)
(x OR y) AND z &#x3D;&gt; (x AND z) OR (y AND z)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>索引合并不适用于全文索引</li>
</ul>
</blockquote>
<p>在 <code>EXPLAIN</code> 输出中，Index Merge 方法在 <code>type</code> 列中显示为 <code>index_merge</code>。 在这种情况下，键列包含使用的索引列表，而 <code>key_len</code> 包含这些索引的最长键部分的列表。</p>
<p>Index Merge 访问方法有几种算法，显示在 EXPLAIN 输出的 Extra 字段中：</p>
<ul>
<li><p>Using intersect(…)</p>
</li>
<li><p>Using union(…)</p>
</li>
<li><p>Using sort_union(…)</p>
</li>
</ul>
<p>以下部分更详细地描述了这些算法。 优化器根据各种可用选项的成本估计在不同可能的索引合并算法和其他访问方法之间进行选择。</p>
<p>索引合并的使用取决于MySQL优化器开关,分别是系统变量 index_merge、index_merge_intersection、index_merge_union 和 index_merge_sort_union 标志的值。<br>请参见第 8.9.2 节，“可切换的优化”。 默认情况下，所有这些标志都打开。<br>要仅启用某些算法，请将 index_merge 设置为关闭，并仅启用应允许的其他算法。</p>
<ul>
<li><p>Index Merge Intersection Access Algorithm</p>
</li>
<li><p>Index Merge Union Access Algorithm</p>
</li>
<li><p>Index Merge Sort-Union Access Algorithm</p>
</li>
</ul>
<h2 id="Index-Merge-Intersection-Access-Algorithm（索引合并交集访问算法）"><a href="#Index-Merge-Intersection-Access-Algorithm（索引合并交集访问算法）" class="headerlink" title="Index Merge Intersection Access Algorithm（索引合并交集访问算法）"></a>Index Merge Intersection Access Algorithm（索引合并交集访问算法）</h2><p>此访问算法适用于将 WHERE 子句转换为与 AND 结合的不同键上的多个范围条件的情况，并且每个条件都是以下之一：</p>
<ul>
<li>这种形式的 N 部分表达式，其中索引正好有 N 部分（即，组合索引所有索引部分都被覆盖）：<pre class="line-numbers language-none"><code class="language-none">-- 二级索引必须是等值查询，如果是组合索引，则组合索引的每一列都必须覆盖到
key_part1 &#x3D; const1 AND key_part2 &#x3D; const2 ... AND key_partN &#x3D; constN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>InnoDB 表的主键上的任何范围条件。</li>
</ul>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM innodb_table
  WHERE primary_key &lt; 10 AND key_col1 &#x3D; 20;

SELECT * FROM tbl_name
  WHERE key1_part1 &#x3D; 1 AND key1_part2 &#x3D; 2 AND key2 &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>索引合并交集算法对所有使用的索引执行同时扫描，并生成它从合并索引扫描接收的行序列的交集。</p>
<ul>
<li>如果查询中使用的所有列都被使用的索引覆盖，则不会检索完整的表行（在这种情况下，EXPLAIN 输出包含在 Extra 字段中使用索引）。以下是此类查询的示例：<pre class="line-numbers language-none"><code class="language-none">SELECT COUNT(*) FROM t1 WHERE key1 &#x3D; 1 AND key2 &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>如果使用的索引未覆盖查询中使用的所有列，则仅当满足所有使用的键的范围条件时才检索完整的行。</li>
<li>如果其中一个合并条件是对 InnoDB 表的主键的条件，则它不用于行检索，而是用于过滤掉使用其他条件检索到的行。</li>
</ul>
<h2 id="Index-Merge-Union-Access-Algorithm-索引合并并集访问算法）"><a href="#Index-Merge-Union-Access-Algorithm-索引合并并集访问算法）" class="headerlink" title="Index Merge Union Access Algorithm(索引合并并集访问算法）"></a>Index Merge Union Access Algorithm(索引合并并集访问算法）</h2><p>此算法的标准类似于索引合并交集算法的标准。 该算法适用于将表的 WHERE 子句转换为不同键上的多个范围条件并结合 OR 的情况，并且每个条件都是以下之一：</p>
<ul>
<li>这种形式的 N 部分表达式，其中索引正好有 N 部分（即，组合索引所有索引部分都被覆盖）：<pre class="line-numbers language-none"><code class="language-none">key_part1 &#x3D; const1 AND key_part2 &#x3D; const2 ... AND key_partN &#x3D; constN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>InnoDB 表的主键上的任何范围条件。</li>
<li>索引合并交集算法适用的条件。 </li>
</ul>
<h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM t1
  WHERE key1 &#x3D; 1 OR key2 &#x3D; 2 OR key3 &#x3D; 3;

SELECT * FROM innodb_table
  WHERE (key1 &#x3D; 1 AND key2 &#x3D; 2)
     OR (key3 &#x3D; &#39;foo&#39; AND key4 &#x3D; &#39;bar&#39;) AND key5 &#x3D; 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Index-Merge-Sort-Union-Access-Algorithm-索引合并排序并集访问算法"><a href="#Index-Merge-Sort-Union-Access-Algorithm-索引合并排序并集访问算法" class="headerlink" title="Index Merge Sort-Union Access Algorithm(索引合并排序并集访问算法)"></a>Index Merge Sort-Union Access Algorithm(索引合并排序并集访问算法)</h2><p>该访问算法适用于WHERE子句转换为多个OR组合的范围条件，但不适用Index Merge union算法。</p>
<h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM tbl_name
  WHERE key_col1 &lt; 10 OR key_col2 &lt; 20;

SELECT * FROM tbl_name
  WHERE (key_col1 &gt; 10 OR key_col2 &#x3D; 20) AND nonkey_col &#x3D; 30;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>排序并集算法和并集算法之间的区别在于排序并集算法必须首先获取所有行的行 ID 并在返回任何行之前对它们进行排序。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h2 id="索引合并交集访问算法"><a href="#索引合并交集访问算法" class="headerlink" title="索引合并交集访问算法"></a>索引合并交集访问算法</h2><p><code>WHERE</code>条件之间使用<code>AND</code>结合，而且每个条件必须满足以下两个条件：</p>
<ul>
<li>二级索引必须是等值查询，如果是组合索引，组合索引的每一列都必须覆盖到</li>
<li>InnoDB表的主键范围条件查询</li>
</ul>
<h2 id="索引合并并集访问算法"><a href="#索引合并并集访问算法" class="headerlink" title="索引合并并集访问算法"></a>索引合并并集访问算法</h2><p>与<code>索引合并交集访问算法</code>类似，不过使用了<code>OR</code>连接条件，且满足以下条件：</p>
<ul>
<li>二级索引必须是等值查询，如果是组合索引，组合索引的每一列都必须覆盖到</li>
<li>InnoDB表的主键范围条件查询</li>
<li>符合<code>索引合并交集访问算法</code>的条件</li>
</ul>
<h2 id="索引合并排序并集访问算法"><a href="#索引合并排序并集访问算法" class="headerlink" title="索引合并排序并集访问算法"></a>索引合并排序并集访问算法</h2><p>二级索引不必等值查询，联合索引也不必匹配所有的索引项</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html">8.2.1.3 Index Merge Optimization</a></p>
<p><a href="https://gentlezuo.github.io/2019/09/11/MySQL%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/#%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6">MySQL：索引合并</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引合并</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL调优案例分享</title>
    <url>/2020/04/27/mysql/mysql-diao-you-an-li-fen-xiang/</url>
    <content><![CDATA[<h1 id="MySQL调优案例分享——技术分享"><a href="#MySQL调优案例分享——技术分享" class="headerlink" title="MySQL调优案例分享——技术分享"></a>MySQL调优案例分享——技术分享</h1><span id="more"></span>


	<div class="row">
    <embed src="./MySQL调优案例分享.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>《你的善良必须有点锋芒》</title>
    <url>/2022/05/15/book/ni-de-shan-liang-bi-xu-you-dian-feng-mang/</url>
    <content><![CDATA[<blockquote>
<p>你的善良，必须有点锋芒，否则等于零 —— 【美】拉尔夫·瓦尔多·爱默生</p>
</blockquote>
<p><img src="/images/book/%E4%BD%A0%E7%9A%84%E5%96%84%E8%89%AF%E5%BF%85%E9%A1%BB%E6%9C%89%E7%82%B9%E9%94%8B%E8%8A%92.jpeg" alt="你的善良必须有点锋芒"></p>
<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>曾经听到过这样的一句话：<code>God helps those who help themselves</code>,翻译后的意思是：上帝只救自救者。佛经有一句相似的话：众生皆苦，唯有自渡。随着成长我开始逐渐理解这两句话的意思，想要追寻幸福的人生，必须要学会<code>自救</code>或者<code>自渡</code>。在成长的道路上，我们会遇见许多迷茫和困惑，阻碍我们的前进和成长之路，或许我们都希望有人能够帮助我们克服困难，但是问题的根本原因是我们始终过不去自己心中的那一关，就这样不断陷入内心的煎熬之中。看到这本书的时候一下子就被这本书的名字吸引，但是书阅读后发现，书中的内容犹如空中楼阁，这里更建议大家去读：<a href="https://www.mpoom.cn/2021/02/10/book/bei-tao-yan-de-yong-qi/">《被讨厌的勇气》</a>、<a href="https://www.mpoom.cn/2021/02/11/book/ke-ai-de-zu-zhou/">《可爱的诅咒》</a>以及《自卑与超越》，这些书籍结合心理学的知识，分析了问题的本质，结合切实的案例提供了解决之法。虽然这本书中更多是鸡汤，但是书中提到的很多现象值得我们思考探讨一下。</p>
<h1 id="诚知此恨人人有，贫贱夫妻百事哀"><a href="#诚知此恨人人有，贫贱夫妻百事哀" class="headerlink" title="诚知此恨人人有，贫贱夫妻百事哀"></a>诚知此恨人人有，贫贱夫妻百事哀</h1><blockquote>
<p>《遣悲怀三首·其二》</p>
<p>唐·元稹</p>
<p>昔日戏言身后事，今朝都到眼前来。</p>
<p>衣裳已施行看尽，针线犹存未忍开。</p>
<p>尚想旧情怜婢仆，也曾因梦送钱财。</p>
<p>诚知此恨人人有，贫贱夫妻百事哀。</p>
</blockquote>
<p>在婚姻和家庭话题中，我们经常会听到一句话：<code>贫贱夫妻百事哀</code>，这句话从字面意思理解是：夫妻家庭生活经济条件差、生活窘迫，因各种琐事而矛盾重重。但是这句诗的原文出自唐代诗人元稹《遣悲怀三首·其二》,《遣悲怀三首》是作者伤悼已故的原配妻子，最后一句大意为：虽然我知道这种阴阳相隔的悲恨人人都会有,但一想起我们做贫贱夫妻的每一件事情都会让我特别悲哀。之前在没有了解这句诗的原文出处的时候，也是望文生义的去用。现在每次听到这句话都忍不住想给对方友情提示一下，但是有时候想想又觉得没必要，说出去无非是在卖弄知识，从字面理解确实没毛病，而且强行解释对于正在交谈的话题本身无实质性帮助。这里本着分享的态度，希望大家了解到这句话的原意。</p>
<h1 id="一、你以为的善良，其实知识懦弱"><a href="#一、你以为的善良，其实知识懦弱" class="headerlink" title="一、你以为的善良，其实知识懦弱"></a>一、你以为的善良，其实知识懦弱</h1><p>每个人都曾遇到过不好意思拒绝别人的情况，其中原因有很多，或是怕对方失望不想伤害对方，或是不想违背对方意愿，或是不想打破自己“好人”的人设等等，但是我们仔细回顾我们因为自己的“善意”没有拒绝别人的最后结果是我们真正想要的吗？</p>
<h2 id="1-1-”善意“的拒绝"><a href="#1-1-”善意“的拒绝" class="headerlink" title="1.1 ”善意“的拒绝"></a>1.1 ”善意“的拒绝</h2><p>你“善意”的拒绝往往可能会真正的伤害到别人。比如别人邀请你参与一个聚会时，你内心是不想去的，但是又不忍直接拒绝，所以推辞说有个重要的事要参做抽不开身，结果别人以为你想要来而没有时间，商量过后推迟了时间重新邀请你，这时你发现不忍再找理由拒绝，不得不去参加这个你不想去的聚会。另一种情况是你编了一个蹩脚的谎言说你工作忙去不了，却因机缘巧合，被别人撞见了说是要工作但是却在逛街的你，谎言被无情的拆穿，在对方的印象里，你是一个宁愿去逛街也不愿去参加他聚会的人。</p>
<p>”善意“的拒绝有时会给对方带来更大的伤害，所以表达你真实的想法，直接拒绝掉会更好。如果真的是很好的朋友，他会站在你的立场上思考理解你的决定。反之如果因为你的一次拒绝，对方就和你断绝关系往来，那么你就有必要思考，对方是否是你真正的朋友，对方是否值得你为他花费这些时间？</p>
<h2 id="1-2-”恶意“的拒绝"><a href="#1-2-”恶意“的拒绝" class="headerlink" title="1.2 ”恶意“的拒绝"></a>1.2 ”恶意“的拒绝</h2><p>在我们想着如何拒绝别人的时候，我们有时也会遭遇拒绝，但是大多情况下，我们请求别人的时候都会有被拒绝的心理预期，所以即使被拒绝，我们也不会太难过。但是有些”恶意“的拒绝，会让人气的火冒三丈，比如：我们请求别人办事时，对方提出各种各样的要求，当我们排除万难达到要求之后，对方却说他办不了。遇到这种情况，我只想问对方祖坟在哪？</p>
<blockquote>
<p>声明一下，作为一个现代文明人，刨别人祖坟这事我可做不出来，除非是太生气了</p>
</blockquote>
<h2 id="1-3-维持“好人”人设"><a href="#1-3-维持“好人”人设" class="headerlink" title="1.3 维持“好人”人设"></a>1.3 维持“好人”人设</h2><p>从小我们就被教育要成为一个“好人”，要扶老奶奶过马路，在公交车上主动给有需要的人让座等。不知道大家有没有遇到过这样的情况，当你坐公交车时，车上上来几位老人站在你的旁边。要是在平时你肯定会主动让座，但是由于今天身体不舒服，你也需要这个座位，但是不让座又违背了自己心中“好人”的人设，听到公交车上播放的录音：“尊老爱幼是中华民族的传统美德”时更是如芒在背，遭受着肉体和心灵的双重折磨。</p>
<p>“好人”最难的是跨越自己心中的那道坎，但是从事实来看，我们是在做好人好事，还是在委曲求全？”好人“往往容易被道德或规则所束缚，所以当你发现做”好人“要委屈自己的时候，那么你就应该停下来，尝试表达自己真实的感受，而不是委屈自己。</p>
<h2 id="1-4-寻求认同"><a href="#1-4-寻求认同" class="headerlink" title="1.4 寻求认同"></a>1.4 寻求认同</h2><p>社会心理学中提到一个现象，当我们身处一个集体之中时我们丧失自主思维，会主动寻求集体的认同，即使有时候不同意，也不会公然反对，因为我们不想成为最碍眼的那一个。所以当我们身处集体之中时，为了寻求认同而答应了我们平时会拒绝的请求。这种情况下，我们必须有个强大的内心，更要认清一个事实，无论你怎样做，你都没办法保证集体中的每一个人都满意。即使是美国总统，他们也没有获得百分百的选票的。我们必须要弄清哪一部分是我们可以争取到的人，哪一部分是我们无论如果都无法争取到的人，把努力用在可以争取的人身上。</p>
<h1 id="二、吃亏是福"><a href="#二、吃亏是福" class="headerlink" title="二、吃亏是福"></a>二、吃亏是福</h1><p>我妈从小教我了一个道理；”少沾光，多吃亏“，这个道理我从小践行，到现在帮我结交到一群可以信赖的朋友。如今我对这句话有了更深层次的理解，那就是”学会付出和奉献“。人际交往的本质是利益交换，一味的索取只会让周围的人远离你，所以在最初时的交往过程中，我们必须要学会付出，在付出和索取之间尽量达成平衡，直到我们在不断的公平交易中建立信任以后，我们才可以抛开等价交换来保持人际交往了。</p>
<p>所以在没有建立信任关系的时候，我们尽量遵循等价交换的原则进行索取和付出，否则往往会导致关系的破裂，索取的太多对方不满意，付出的太多自己不满意。在起初的利益交换中，如果你更愿意优先付出，那么对信任的建立以及信任的牢固程度非常有益，这是我所理解的：”少沾光，多吃亏“。</p>
<p>对于我们周围那些只知道一味索取的人，在早期的交往过程中发现后，清尽早远离，因为这注定是一场不公平的交易。</p>
<h1 id="三、过度牺牲式的付出不是爱"><a href="#三、过度牺牲式的付出不是爱" class="headerlink" title="三、过度牺牲式的付出不是爱"></a>三、过度牺牲式的付出不是爱</h1><p>一个女人为了支持丈夫求学深造放弃了自己的晋升机会，后面为了支持丈夫的工作毅然辞去了工作成为家庭主妇，但是最终却换来了丈夫的离婚请求。在生活中我们也经常听到这样的话：“我为你付出了这么多，你却这么对我”。之前我是一直不懂，但是如今我有了一些理解，那就是 —— 心灵不能承受之重。很多时候牺牲式的付出，成为了接受付出者的心理负担，使得双发不能再以平等的方式相处，反而变得像老板与员工的关系。付出的一方在想我为你付出了那么多，你的表现必须符合我的预期；而接受付出的一方内心除了感激，反而会承担更大的压力。一方面因为你的付出会产生了挫败感，另一方面他必须处在高压之下努力奋斗，防止你的牺牲和付出白费。</p>
<blockquote>
<p>作为一个北方人，和朋友一起出去吃饭一般都是你买一次单我买一次单，轮流着来，大致公平即可。然而每次和大学室友出去吃饭买单后，他总要AA转给我，我说下次他买单就行，不用转了，但是他就是不同意，可恶，每次都被他AA了，好不甘啊。后来吃饭时，也和他聊到这个问题，为啥非要AA呢？他说如果没有AA还得记在心里，下次吃饭指不定是在什么时候呢？AA后就不用那么麻烦了，所以有时候你的付出反而会成为别人的心里负担。很多时候我确实应该像我的室友学习一下，不要“下次一定”，而是这次一定。</p>
</blockquote>
<p>过度牺牲式的付出不是爱，反而像绑架一般，结局往往是一个悲剧。之前也和张英俊同学讨论过这个话题，付出的时候你需要考虑对方是否能够坦然的接受你的付出，其中的核心是你的付出能否让你们保持一个平等的关系相处，如果是，那么换来的则是对方的感激，否则换来的是对方的挫败感而且使对方产生心里负担。</p>
<h1 id="四、认识自我"><a href="#四、认识自我" class="headerlink" title="四、认识自我"></a>四、认识自我</h1><p>之前看到过一句话叫：和过去的自己和解，想要做到这一点，我们先要去认识自己，盲目的和解或放下只是在逃避而已。我们很多时候都任由情绪把控自己，做出了违背我们内心想法的行为。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这本书想表达的是要成为一个有原则的人，当我们的原则受到挑战或被打破时，我们就要进行<code>fight</code>。当我们还缺失某些原则的时候，我们要尝试去建立这些的原则。</p>
<p>此外，这本书是一本心灵鸡汤类的书籍，能引起你的共鸣，但是无法切实的帮助你解决问题。而且我发现心灵鸡汤类的书籍的缺点是往往只分析了现象，而且是面向结果的，所以往往能引起你的共鸣，但是不能帮助你解决实际问题。而当你恢复冷静后又要面对现实与书中结果的巨大落差，从而产生深深的挫败感。而我所看过的干货书籍，它们是分析现象及原因，并且面向过程提供了切实可行的解决方案，所以心灵鸡汤还是要少读。</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>你的善良必须有点锋芒</tag>
      </tags>
  </entry>
  <entry>
    <title>《能力陷阱》</title>
    <url>/2022/05/04/book/neng-li-xian-jing/</url>
    <content><![CDATA[<p><em><strong>《能力陷阱》（Act Like A Leader, Think Like A Leader）—— 像领导者一样行动，像领导者一样思考。</strong></em></p>
<p><img src="/images/book/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1.jpeg" alt="能力陷阱"></p>
<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>这本书很早就在樊登读书的APP上听过一次，当时听完后并未留下深刻的印象。随着自己工作经历的增加，开始不断反思自己的人生，发现自己像是掉入泥潭之中，不断挣扎，但却找不到方法和方向。有天在下班的路上，想起了这本书于是重新把这本书听了一遍，从中仿佛找到了方向。于是买了实体书来看，刚开始翻看了一部分，然后由于这样那样的原因一直无法静下心来去读完，直至今年五一假期，一鼓作气读完了这本书。起初我以为这是面向领导者的书籍，读完后发现，这本书适合每个想要在职业生涯中更进一步的人。我自己今年在工作中担任了小组长的角色，需要进行一些自我转变，这本书帮我分析清了自我转变的过程以及过程中会遇到的问题，并提供了许多方法。同时这本书让我学会了重新定义自己，打破自己曾经的思维困境，走出泥潭。</p>
<p>“有些书你可能早早的买来了，但是翻看了几页由于未能提起你的兴致，就搁置在书架上去了，直到有一天你从书架上看到了它并拿起翻看了一下，然后一下子被内容吸引一鼓作气读完了。当我们的人生经历无法和书中的内容产生共鸣时，很难有兴致继续读下去，即使坚持读完也是读的似懂非懂。当我们经历了足够多的事情后，再拿起这本书时，有一种豁然开朗的感觉，读的如痴如醉。所以不必着急清理你的书架上还未曾读完的书，也许你们的缘分要迟一点到“。这是我曾在另一本书中看到的一段话，完全印证了我读这本书的经历。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>[美]埃米尼亚·伊贝拉 —— 著 / 王臻 —— 译</p>
</blockquote>
<blockquote>
<p>我们很乐于去做我们擅长的事，于是就会一直去做，最终就使得我们会一直擅长那些事。做的越多，就越擅长，越擅长就越愿意去做。这样的一个循环能让我们在这方面获得更多的经验，但却容易陷入能力陷阱，在其它方面无法突破。</p>
</blockquote>
<blockquote>
<p>每个人都要特别警惕这种能力陷阱，避免把大量时间花在日常琐事上。如果你想获得更多更好的发展，就要从日常琐事中解脱出来，转变到更多策略性思考、在日常工作外建立人际关系网络、提升影响力等能够给你带来持续价值的工作上，这样你才能在各领域获得更好的发展。</p>
</blockquote>
<p>这不是一本鸡汤励志书籍，本书作者埃米尼亚·伊贝拉是欧洲工商管理学院（INSEAD）组织行为学教授兼领导与学习首席教授。在加入INSEAD前，她在哈佛商学院工作了13年。书中结合了大量的研究及教学案例，是作者数十年研究的精华所在，内容通俗易懂，满满的全是干货。</p>
<h1 id="一、领导者的能力陷阱"><a href="#一、领导者的能力陷阱" class="headerlink" title="一、领导者的能力陷阱"></a>一、领导者的能力陷阱</h1><h2 id="1-1-改变思想从行动开始"><a href="#1-1-改变思想从行动开始" class="headerlink" title="1.1 改变思想从行动开始"></a>1.1 改变思想从行动开始</h2><blockquote>
<p>很多传统的领导力培训或辅导的目的是改变你思考的方式，教你学会反思你是谁以及你要成为谁的问题。的确，自省和反思是成为一个领导者的黄金法则。首先要提高自我意识，认识自己。如果你尝试过这些方法，你就会发现它们是非常有局限性的。虽然在很大程度上，它们能帮助你认识到你当前的能力以及领导方式，但是我们会发现，当前的想法恰恰是阻碍你继续前行的绊脚石。所以你需要改变的是你的思考方式，而只有一种方法能改变它：改变你的做事方法。</p>
</blockquote>
<blockquote>
<p>亚里士多德发现，一个人如果表现得很有美德，那他最终会成为一个有美德的人，即多做好事就会变成好人。他的这一说法得到很多社会心理学家的证实，研究表明一个人若改变了他的想法，是因为他的行为先发生了改变。简单来说，改变是由外而内，而并非由内而外产生的。正如管理专家理查德·帕斯卡尔（Richard Pascale）所说：“成年人更倾向于先做而后产生新的想法，而不是先想再以一种新的方式去做。”</p>
</blockquote>
<p>古语有云：三思而后行。在做一件事前，我们仔细思考然后做好详细计划，这在正常情况下通常都非常有用。但是当我们去做新的事情、面对新的挑战的时候，由于从未有过经验，我们会犹豫再三，努力思考我们的方案或计划是否可行，很多时候在思考中错过了最佳时机。所以当面对新的事物，或者面临改变的时候，思想仍然停留在过去，必须先行动再思考。</p>
<p>此外我还发现一个规律：<code>完美的表现 = 适当的状态 + 恰当的时机</code>，一直以来我抱着“十年磨一剑”的心态，常常希望自己达到最佳状态再行动。很多时候，当我们准备好的时候，但是却错过了最佳的时机，结果反不如提前行动的效果好。</p>
<h2 id="1-2-由外而内的转变"><a href="#1-2-由外而内的转变" class="headerlink" title="1.2 由外而内的转变"></a>1.2 由外而内的转变</h2><blockquote>
<p>如果我们像一个领导者一样做事：如不断提出新观点，在专业领域之外做出贡献，或是集合人力物力做成一件很有价值的事，等等。身边的其他人也就会觉得我们越来越像一个真正的领导者。研究发现，社会认同及个人名声给心理学家所谓的领导者身份内在化（Internalizing，即把自己看作一个领导者）提供了条件，从而使他们能抓住更多的机会来展现自己的领导才能。</p>
</blockquote>
<blockquote>
<p>先像领导者一样做事，而后才能像领导者一样思考，这样的一个循环——外在改变引起的内在改变——也就是我所谓的“由外而内”（Outsight）。</p>
</blockquote>
<h2 id="1-3-“由外而内“原则"><a href="#1-3-“由外而内“原则" class="headerlink" title="1.3 “由外而内“原则"></a>1.3 “由外而内“原则</h2><blockquote>
<p>一个人的思维方式是很难改变的，因为改变需要外在经历。如果不是由外而内地改变，我们的自我认知会被过去所禁锢，从而导致思想和行为也无法改变。没有人会比我们自己更适合给自己进行定位。改变的矛盾在于，改变想法的唯一办法就是要做一些之前没有做过的事，而这些事正是之前的想法所不认同的事。</p>
</blockquote>
<blockquote>
<p>先像领导者一样行事，如积极参与新项目以及新活动，与各式各样的人打交道以及尝试采用新方法做事等。那些充满挑战的新经历以及它们所带来的成就会改变那些一直限制你的固有行为和思维。在改变的不稳定时期，思考和反省是会跟随你的行为和尝试而发生改变的，而非反方向行之。新的经历不仅会改变你的想法——你认为什么是重要的，什么是值得去做的，还会改变你未来的样子。它们可以帮助你从一些新的成就里获得自信，使你放弃过去的目标，还可以改变你过去所习惯的做事方法。</p>
</blockquote>
<blockquote>
<p>与自省相比，由外而内地改变更能帮助你重塑形象，告诉你你能做什么。成为一名优秀的领导者并非是你发展道路上的起点，而是你自我身份认知的结果。这种认知只有在你与新认识的人，一起做新的工作时才会产生。这并不是说你因此发现了真正的自我，而是说你所做的事折射出了真实的你。</p>
</blockquote>
<blockquote>
<p>如果我们从相反的方向，也就是由内而外的方向来改变，那是行不通的。与大众普遍认为的观点相反，自省大多时候只会让我们停留在过去，蒙蔽我们的双眼，使我们无法发现我们的领导潜能，还会让我们毫无准备地去面对周围环境的根本转变。这就好比在昏暗的路灯下寻找丢失的手表，你需要有很强的观察力；同样地，解决新问题也需要这种能力，而这种能力来源于我们在做与以往不一样的事情时所获得的新的见解。伟大的社会心理学家卡尔·韦克（Karl Weick）将其简述为：“我何以知道自己在想什么呢？——只有在看到我做了什么以后才能知道。”</p>
</blockquote>
<h2 id="1-4-“三步走”助你实现领导者转变"><a href="#1-4-“三步走”助你实现领导者转变" class="headerlink" title="1.4 “三步走”助你实现领导者转变"></a>1.4 “三步走”助你实现领导者转变</h2><blockquote>
<p>领导者转变方法都是根据以下三个增强外在表现力的方法而写成的：</p>
<ul>
<li>一是思考你所做工作的类型；</li>
<li>二是转换新角色或参与新活动能让你接触到不同的人，这些人有着与你不一样的世界观；</li>
<li>三是重新审视自己。因为只有当你受到新环境的挑战或接受外界新的刺激时，你才会产生如此多新的想法。</li>
</ul>
</blockquote>
<blockquote>
<p>实现“由外而内”的转变并非是一件一次就能成功的事，而是一个不断检验旧的假设，提出新可能性的过程。所以要实现转变，最好的出发点就是先重新定义工作，然后重建人际关系网络，最后再改变做事方法。</p>
</blockquote>
<h1 id="二、重新定义你的工作"><a href="#二、重新定义你的工作" class="headerlink" title="二、重新定义你的工作"></a>二、重新定义你的工作</h1><h2 id="2-1-从“不对”转变到“对”"><a href="#2-1-从“不对”转变到“对”" class="headerlink" title="2.1 从“不对”转变到“对”"></a>2.1 从“不对”转变到“对”</h2><blockquote>
<p>他们根据各自的专长，把工作定义在一个较窄的范围内，把自己的活动范围限制在过去能给他们带来最大价值的持续性成果的领域。事业初期，他们需要扮演这样一个角色。但是经过一段时间以后，别人对他们的期望会发生改变。所以想要避免发生这种能力陷阱（Competency Trap），你就需要明白，那些曾经对你有用的想法和工作习惯只有在经受住考验后才可能一直适用，否则它们就需要做出改变。</p>
</blockquote>
<h2 id="2-2-避免能力陷阱"><a href="#2-2-避免能力陷阱" class="headerlink" title="2.2 避免能力陷阱"></a>2.2 避免能力陷阱</h2><blockquote>
<p>我们很乐于去做那些我们擅长的事，于是就会一直去做，最终就使得我们会一直擅长那些事。做得越多，就越擅长，越擅长就越愿意去做。这样的一个循环能让我们在这方面获得更多的经验。而它就像是毒品一样，我们被它深深吸引，因为我们的快乐和自信都来源于它。它还会让我们产生误区，让我们相信我们擅长的事就是最有价值的且最重要的事，所以值得我们花时间去做。</p>
</blockquote>
<h3 id="让自己在团队里过于有价值"><a href="#让自己在团队里过于有价值" class="headerlink" title="让自己在团队里过于有价值"></a>让自己在团队里过于有价值</h3><blockquote>
<p>管理者把太多精力放在细节上——尤其是在他的专业领域范围内，并且对他的团队进行了太多的微观管理，以至于团队的成绩完全由他一个人来领导完成。</p>
</blockquote>
<p>这样的方式让我们觉得我们是团队中不可或缺的，但是同时，也限制了我们发展的可能，因为我们在团队中是不可或缺的，你没法脱离现在的职位。</p>
<h2 id="2-3-了解领导者真正需要做的事情"><a href="#2-3-了解领导者真正需要做的事情" class="headerlink" title="2.3 了解领导者真正需要做的事情"></a>2.3 了解领导者真正需要做的事情</h2><p>要像领导者一样行事，我们需要把时间花在以下这些事上：</p>
<ul>
<li>像桥梁一样连接不同的人或组织</li>
<li>展望新未来</li>
<li>提升影响力</li>
<li>将想法与个人经历结合</li>
</ul>
<p>有魅力的领导者都有以下三个共同点：</p>
<ul>
<li>人生阅历丰富，从而产生了坚定的信念</li>
<li>能通过讲述个人故事来与他人进行良好的交流</li>
<li>他们的想法、实际所做的事以及他们自己之间有很强的一致性</li>
</ul>
<h3 id="劝说的秘诀"><a href="#劝说的秘诀" class="headerlink" title="劝说的秘诀"></a>劝说的秘诀</h3><blockquote>
<p>我们很多人都通过讨论需要做什么以及应该如何去做来劝服别人。劝说的秘诀是展示出你最有力的论据。依据我们自己的逻辑和优势，把我们的想法强加给别人，这样的做法并不会十分有用，因为我们最终会跟随那些能鼓舞我们的人，而不仅仅是有能力的人。相反，成功的领导者们会以解释“为什么”——解释他们内心深处的信念和目的——来开始对人们进行鼓舞。这样一来，他们更能打动人。</p>
</blockquote>
<p>这个现象同样出现在我们生活中，我们经常通过摆道理讲事实方式去劝说别人，然而效果往往不佳。因为道理大家都懂，讲得太多反而遭人厌烦引起反感，对方真正需要的是鼓舞。</p>
<h2 id="2-4-把你的工作当成一个平台"><a href="#2-4-把你的工作当成一个平台" class="headerlink" title="2.4 把你的工作当成一个平台"></a>2.4 把你的工作当成一个平台</h2><p>不管你目前的情况是什么样的，以下五件事都可以开始让你的工作变成一个能增强你领导力的平台：</p>
<ul>
<li>增强你对形势的定位感</li>
<li>接触你专业领域之外的项目</li>
<li>参与外部活动</li>
<li>结合个人经历谈谈“为什么”</li>
<li>放松你的日程安排</li>
</ul>
<blockquote>
<p>如果你觉得自己已经停滞不前或是缺乏新鲜感，那就参加行业会议或者其他聚集各行各业的专业聚会来增长你的见识。</p>
</blockquote>
<p>参加行业会议和专业聚会确实是一个好主意，当再遇到这样的机会应该尽可能参加，不应当再错过。</p>
<h3 id="最成功的管理者看起来反而是最没有效率的那个"><a href="#最成功的管理者看起来反而是最没有效率的那个" class="headerlink" title="最成功的管理者看起来反而是最没有效率的那个"></a>最成功的管理者看起来反而是最没有效率的那个</h3><blockquote>
<p>很多年前，一个不为人所知的管理学者约翰·科特（John Kotter）拿着一台手持相机，跟踪拍摄了一群总经理的生活，看看实际上他们每天都在做什么（和大家以为他们每天所做的恰恰相反）。最令他惊讶的是，最成功的管理者看起来反而是最没有效率的那个。</p>
</blockquote>
<p>很多时候我们都让自己陷入忙碌之中，但是我们的效率并不一定是最高的，所以要摆脱那种劳模的心态，尝试更有效率的方式。</p>
<h3 id="“空出一个手术室”"><a href="#“空出一个手术室”" class="headerlink" title="“空出一个手术室”"></a>“空出一个手术室”</h3><blockquote>
<p>美国哈佛大学经济学家森德希尔·穆莱纳桑（Sendhil Mullainathan）和普林斯顿大学心理学教授埃尔德·沙菲尔（Eldar Shafir）合著的名为《稀缺》（Scarcity）的书中在缺钱和缺时间之间做了一个很有意思的对比。他们指出，两者都能将你限制在一根“管子”（Tunneling）中，人们只能看到“管子”中的事物，虽然这能给我们带来短期利益，但从长远来看，反而会起到限制作用。<br>穆莱纳桑和沙菲尔用某医院的故事来证明这个观点，该医院的病房常常被提前预约满了。而由于病房都满了，所以当有急诊时——常常出现这样的情况——医院只能把手术计划拖延。“因此，医务人员常常在深夜两点都还在做手术，而医师们常常要等上好几个小时才能做大约只有两个小时的手术，其他工作人员也常常不定时地加班。”因为医院的手术经常滞后，所以经常需要不停地重新安排工作，从而造成了一个低效又高压的工作形式。<br>像大多数遇到问题的公司一样，医院从外部聘用了一个顾问，他提出一个令人惊讶的解决方法：空出一个手术室来应对急诊病人。像我们大多数人会有的反应一样，医院的管理者说：“我们都已经非常忙了，他还要我们空出一个手术室，这太过分了。”<br>就像对于很多过于投入的人来说，他们无法想象把花费大量时间一直在做的事停下来重新组织，更不要说放弃有用或是没用的珍贵资源，医院管理者也产生了同样的怀疑。但是空出一个手术室的方法奏效了。有了一个空手术室后，医务人员能更有效地处理一些紧急病例，不用重新计划所有的一切。因此，他们加班的时间也减少了，手术的效率也提高了。</p>
</blockquote>
<h1 id="三、建立良好的人际关系网络"><a href="#三、建立良好的人际关系网络" class="headerlink" title="三、建立良好的人际关系网络"></a>三、建立良好的人际关系网络</h1><blockquote>
<p>良好的人际关系网络是如何为你服务的？首先，它能让你的消息变得更灵通，更容易获取最新的信息；其次，它让你更富有创新精神，为你的创想提供更坚实的基础；最后，它还可能在你遭遇危机时，助你脱离险境，这样的例子不胜枚举。</p>
</blockquote>
<h2 id="3-1-寻找你的人际“结构洞”"><a href="#3-1-寻找你的人际“结构洞”" class="headerlink" title="3.1 寻找你的人际“结构洞”"></a>3.1 寻找你的人际“结构洞”</h2><blockquote>
<p>你的人际关系网络的战略性优势能帮助你成为一名优秀的领导者，该优势取决于以下三点性质：</p>
<ul>
<li>广泛性（Breadth）：一个广泛的人际关系网络，与各行各业的人建立联系</li>
<li>连接性（Connectivity）：作为桥梁连接一些在其他方面没有关联的人和团队的能力</li>
<li>动态性（Dynamism）：随着你的进步而发展</li>
</ul>
<p>我把以上三点性质称为人际关系网络的优势：广连动，或是人际关系网络的优势=广泛性+连接性+动态性。</p>
</blockquote>
<blockquote>
<p>人际关系网络的多元性、连接性和动态性这三大优势都是相互联系、相辅相成的。如果没有这些优势，你就没有办法认识新的人，你的人际关系网络就会陷入死循环，久而久之，你就会丧失洞察力和关联力。</p>
</blockquote>
<h2 id="3-2-如何在公司内外建立人际关系网络"><a href="#3-2-如何在公司内外建立人际关系网络" class="headerlink" title="3.2 如何在公司内外建立人际关系网络"></a>3.2 如何在公司内外建立人际关系网络</h2><ul>
<li>展示自我</li>
<li>利用二度分割理论</li>
<li>维持关系</li>
<li>找到志同道合的人</li>
</ul>
<h1 id="四、试着朝更多不同的方向发展自己"><a href="#四、试着朝更多不同的方向发展自己" class="headerlink" title="四、试着朝更多不同的方向发展自己"></a>四、试着朝更多不同的方向发展自己</h1><blockquote>
<p>在我25年的执教生涯中，我发现有一件事一直没有改变：人们一直有着强烈的想要做真实的自己的愿望，对于做那些让他们觉得虚假的事也有着同样强烈的厌恶。这些行为背后最重要的刺激因素之一是，人们认为这是内心深处真实自我的基本表现。而正是这样的想法，让我们在领导者转变道路上遇到了阻碍。</p>
</blockquote>
<p>这一点着实戳中了我的痛点，每当自己尝试做一些改变时，内存就会产生疑惑，如果我这样做了，我还是我吗？</p>
<h2 id="4-1-“随机应变者”与“坚持真实者”"><a href="#4-1-“随机应变者”与“坚持真实者”" class="headerlink" title="4.1 “随机应变者”与“坚持真实者”"></a>4.1 “随机应变者”与“坚持真实者”</h2><p>真实性与自我保护之间的界线应该在哪儿呢？</p>
<blockquote>
<p>“随机应变者”有一个核心的自我价值观和目标，他们并不会担心转变自己会对自己的信仰造成影响.<br>“坚持真实者”则与之相反，他们认为如果要根据环境而变换自己，使得他们远离了自己最自然的风格，这是对他们真实性的一种威胁。<br>“坚持真实者”就遵循着旧的方式和风格，因此停滞不前。他们通过展示自己高超的技术来证明自己的能力，这里引用以下他们所相信的观点：“注重实质结果，而不是形式。”（Substance Rather Than Form）通常情况下，他们把上级的成功总结为：“光说不做，没实际能力”（All Talk and Little Content）——那些技术高超的专业人士所追求的，尽管看上去没有太大的吸引力。他们认为，相比起那些“随机应变者”善于变换自己的能力，高超的技术是更为真实的，并以此为豪。</p>
</blockquote>
<p>从上面话中仿佛看到了我自己，现在的我更多的是倾向于是一个“坚持真实者”，需要向“随机应变者”转变。</p>
<blockquote>
<p>在很多工作中，凭借着自己精湛的技术，“坚持真实者”获得了成果。尽管如此，在他们想要成为一名优秀的领导者过程中还是会遭遇很多挫折。对于一名优秀的领导者来说，他们的悟性和他们目前的知识一样重要，成功需要的是把要担任的新角色内在化。有些讽刺的是，“坚持真实者”尝试保持真实性，这却削弱了他们梦想成为的那种领导者的能力。相反，“随机应变者”——他们“假装自己是一个优秀领导者，最后真的成了一个这样的人”，这样的人反而能更快达到自己的目标，最终成为一个真实的，不一样的，能力更强的自己：他们用一种新的方法来行事，最终成就了一个新的真实的自己</p>
</blockquote>
<blockquote>
<p>哥伦比亚大学心理学教授 托里· 希金斯（Tory Higgins）所说的“阻碍”（Prevention）——与“促进”（Promotion）相反。当你在“促进”模式时，你会不停地追求目标，注重你能从自己的努力中获取多少。而在“阻碍”模式时，你会试图避开那些可能对目前的你造成威胁的事，关注点放在你可能会失去什么。正如我们在本章所看到的，成为一个优秀的领导者需要处在一个“促进”模式，但是在转变过程中遇到的很多问题都会触发“阻碍”模式</p>
</blockquote>
<h2 id="4-2-真实性的定义"><a href="#4-2-真实性的定义" class="headerlink" title="4.2 真实性的定义"></a>4.2 真实性的定义</h2><ul>
<li>忠实于自己</li>
<li>真诚，你的所说所做和你想的一致</li>
<li>忠实于自己的价值观和目标</li>
<li>我们不能完全控制我们的身份</li>
</ul>
<h2 id="4-3-“真实性”陷阱"><a href="#4-3-“真实性”陷阱" class="headerlink" title="4.3 “真实性”陷阱"></a>4.3 “真实性”陷阱</h2><blockquote>
<p>我们能学到东西的场合恰恰也正是我们自我认识会面临挑战的时候，这就是为什么在我们成为领导者的道路上，很多人会觉得自己面临着失败或是虚假的两难选择。</p>
</blockquote>
<h3 id="更容易陷入“真实性”陷阱的三种情况"><a href="#更容易陷入“真实性”陷阱的三种情况" class="headerlink" title="更容易陷入“真实性”陷阱的三种情况"></a>更容易陷入“真实性”陷阱的三种情况</h3><blockquote>
<p>第一种情况是，在转变到一个新的角色时，一些人很难与他们的团队保持一个合适的距离，要不就是太近，要不就是太远，把自己的想法都藏在心里不说出来；第二种情况是，另一些人认为他们不需要出售他们的观点，或是不需要刻意地去鼓励其他人。他们不会做一些费劲的事去和别人建立关系，因为他们认为那是在“利用别人”；第三种情况是，一些人通过他们真实的自我的“透镜”过滤掉一些不好的反馈，他们说服自己不自然的领导风格体现出来的不正常的东西，正好是提高自己效率的重要方面。</p>
</blockquote>
<blockquote>
<p>忠实于自己并不意味着你需要举着灯，把自己内心照得透亮，让人们一眼就能看穿你。你没有必要把心里所想的每一个想法和感受都和别人说。</p>
</blockquote>
<blockquote>
<p>利用权力和打感情牌会让人觉得很不舒服。但事实上，领导别人和利用权力之间唯一的不同是，领导别人是一种为了达到一个共同目标而相互影响的行为。</p>
</blockquote>
<blockquote>
<p>作为一个领导者，如果你能明白，给你的下属分派任务是为了完成更高级别的组织任务，那么你就再也不会认为虚假或是在操纵别人了。当你是为了更高的目标工作时，你就再也不会觉得这是在为了你自己或是你的自我意识或是你的事业而工作了。给别人分派任务只是为了完成共同的目标。</p>
</blockquote>
<h2 id="4-4-扩展你的自我概念"><a href="#4-4-扩展你的自我概念" class="headerlink" title="4.4 扩展你的自我概念"></a>4.4 扩展你的自我概念</h2><blockquote>
<p>LinkedIn的创建者雷德·霍夫曼（Reid Hoffman）和本·卡斯诺查（BenCasnocha）合著的书中说到“很多人对于建立人际关系网络的感觉和用牙线的感觉一样：对你是有益的，但不有趣”。我发现当你发展自己的时候，也会有同样的感觉。你常常会觉得这很费劲。</p>
</blockquote>
<h3 id="像艺术家一样偷师学艺"><a href="#像艺术家一样偷师学艺" class="headerlink" title="像艺术家一样偷师学艺"></a>像艺术家一样偷师学艺</h3><blockquote>
<p>如果说有一门职业是注重真实性的，那就是艺术。同时，除了一个艺术家，没有任何人更清楚没有什么是原创的。<br>模仿别人这件事对于他们来说很困难，还会让他们觉得自己不真实。就像作家威尔逊·米茨纳（Wilson Mizner）所说的，如果你模仿一个作家，那就是剽窃，但是如果你模仿很多个作家，那就是研究。</p>
</blockquote>
<p>真正重要的不是“偷”别人的风格，而是“偷”隐藏在风格背后的思想。</p>
<h2 id="4-5-为什么要像水一样"><a href="#4-5-为什么要像水一样" class="headerlink" title="4.5 为什么要像水一样"></a>4.5 为什么要像水一样</h2><blockquote>
<p>李小龙认为你应该“利用一切你能利用的资源”。他所说的“像水一样”，是指不要仅仅局限在一个形象里，要能适应新的环境，在新的环境里塑造一个新的自我形象（例如，把水倒进杯子里，它就是杯子的形状；把水倒进瓶子里，它就是瓶子的形状）</p>
</blockquote>
<blockquote>
<p>人类所具有的一项很神奇的缺点就是，我们没有办法完全模仿别人。在我们未能成功模仿我们的偶像时，便会发现真实的自己。这就是进步过程。</p>
</blockquote>
<h1 id="五、合理的规划前进的道路"><a href="#五、合理的规划前进的道路" class="headerlink" title="五、合理的规划前进的道路"></a>五、合理的规划前进的道路</h1><blockquote>
<p>要成为一个优秀的领导者，并不是一件突然就发生的事，而是一个漫长的积累过程。采取新的行动很重要，即使有时候做一些新的事情会让我们觉得虚假，因为它们很快就能带来成果，并不断刷新可能性，但是很少会有一条清晰的完成界线。</p>
</blockquote>
<h2 id="5-1-照食谱做菜并不能让你成为一个好厨师"><a href="#5-1-照食谱做菜并不能让你成为一个好厨师" class="headerlink" title="5.1 照食谱做菜并不能让你成为一个好厨师"></a>5.1 照食谱做菜并不能让你成为一个好厨师</h2><blockquote>
<p>很多改变的方法告诉你开始的时候要想好，改变以后获得的结果是什么。但实际上，弄清楚你想要成为什么样的领导者是改变中最后一件需要做的事，而不是第一件。</p>
</blockquote>
<h3 id="“进步的过程”"><a href="#“进步的过程”" class="headerlink" title="“进步的过程”"></a>“进步的过程”</h3><blockquote>
<p>我所说的“进步过程”（Stepping-upProcess）。这个过程发生在A（现在的你）与B（未来的你）之间（如图5-1）。进步是一种转变，这种转变无法预测，混乱不清，曲曲折折，并受情绪的控制，之所以会这样，有以下几点原因：</p>
<ul>
<li>B是未知和不确定的</li>
<li>A已经不再适用了</li>
<li>B有很多种可能性</li>
<li>当我们接近它的时候，B发生了改变</li>
</ul>
<p>成为一个优秀的厨师取决于增加你创造新食物可能性的条件，比如受到一个优秀厨师的指导，去远方旅游寻找新食材，偶遇一位著名的美食评论家或是与最好的食物供应商建立良好的人际关系。但是这些东西都不会保证你能达到自己的目标。在这种情况下，成功取决于你是否成了一个不一样的自己。成为一名优秀的领导者的进步过程更像是成为一个优秀的厨师的过程，而不仅仅是照着食谱做出好吃的东西。进步过程中有一些你可能没有预想到的方式改变了你。</p>
</blockquote>
<h2 id="5-2-转变过程的可能阶段"><a href="#5-2-转变过程的可能阶段" class="headerlink" title="5.2 转变过程的可能阶段"></a>5.2 转变过程的可能阶段</h2><p>成为一名优秀领导者的进步阶段</p>
<blockquote>
<p>阶段1：发现差异</p>
</blockquote>
<p>● 发现目前的你是谁和你想要成为什么样的人之间的差异<br>● 增加采取行动的紧迫感</p>
<blockquote>
<p>阶段2：只加不减</p>
</blockquote>
<p>● 增加新的角色或行为方式（不会放弃旧的角色或行为方式）<br>● 增加外在表现力，获得一些容易得到的成果</p>
<blockquote>
<p>阶段3：混乱迷茫</p>
</blockquote>
<p>● 遭遇挫折<br>● 把时间和精力花在新旧角色转换或行为方式上，感到筋疲力尽；受到周围人对于以前的那个你的肯定，从而进步之路受到阻碍</p>
<blockquote>
<p>阶段4：重新设定前进方向</p>
</blockquote>
<p>● 挫折，带来更大的职位问题<br>● 是时候将外在表现内在化了：反思新的经历来重新检验过去的目标，从而提出新的目标</p>
<blockquote>
<p>阶段5：内在化</p>
</blockquote>
<p>● 你的新身份会使改变继续进行下去</p>
<h2 id="5-3-人的一生都在不停地改变"><a href="#5-3-人的一生都在不停地改变" class="headerlink" title="5.3 人的一生都在不停地改变"></a>5.3 人的一生都在不停地改变</h2><blockquote>
<p>事业中期转变一个最大的挑战之一是弄清楚该改变什么以及该保持什么。有时候诱惑会让一切马上改变。但是像改变工作或是事业这样重要的事情不一定会给我们带来好的结果。</p>
</blockquote>
<h1 id="六、行动起来"><a href="#六、行动起来" class="headerlink" title="六、行动起来"></a>六、行动起来</h1><blockquote>
<p>身边的每一个人都会告诉你，如果想成为一名优秀的领导者，那就需要学会自省反思，清楚地知道自己想要什么，增强自我意识。这些建议都很好，但是这只会在改变后期起到作用，而一开始你必须要先有一些新的经历，要不然你所反思的结果只会停留在过去。内在洞察力是外在表现力的反映，而并不是创造外在表现力的源泉。弄清楚你想要成为什么样的领导者并不是你成长之路上的起点，而是在改变你外在表现力的时候获得的结果。你必须把传统的“先思考后行动”的观点反过来，这样才能成功地实现转变。</p>
</blockquote>
<h2 id="过去的经历有用吗？"><a href="#过去的经历有用吗？" class="headerlink" title="过去的经历有用吗？"></a>过去的经历有用吗？</h2><blockquote>
<p>乔布斯在他著名的斯坦福大学毕业演讲中说道，他在大学时辍学去做了其他事，比如去上美术课，而这个经历对多年以后他所生产的苹果产品的外观及触感产生了很大的影响。他从来没有想过这个兴趣爱好会对后来所取得的成绩产生至关重要的作用。“向前展望时你不能把点点滴滴的经历联系在一起，只有在向后回顾时才能发现它们之间的联系。”</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这本书解答了好多我在改变过程中遇到的困惑，这些思想犹如灯塔，为个人转变之路指明了方向。这里列举我印象深刻的几个观点：</p>
<ul>
<li>改变思想从行动开始</li>
<li>“由外到内”转变</li>
<li>重新定义你的工作、人际关系网络、你自己</li>
<li>劝说的秘诀</li>
<li>“空出一间手术室”</li>
<li>“随机应变者”</li>
<li>“真实性”的陷阱</li>
<li>像艺术家一样偷师</li>
<li>“像水一样”</li>
<li>转变过程的阶段</li>
</ul>
<p>难得在五一假期静下心来读完了这本书，读完后收获良多，忽然想起了曾经听到过的一句话：“孤独是一个人的狂欢”，此刻我仿佛真正领悟到了这句话的真意。</p>
]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>能力陷阱</tag>
      </tags>
  </entry>
  <entry>
    <title>EnvironmentChangeEvent的Listener执行顺序</title>
    <url>/2022/04/06/springcloud/environmentchangeevent-de-listener-zhi-xing-shun-xu/</url>
    <content><![CDATA[<h1 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h1><p>项目中使用Nacos作为配置中心，实现配置动态更新，在配置类中监听<code>EnvironmentChangeEvent</code>事件对更新后的配置做一些初始化处理，代码如下：</p>
<h2 id="CallbackConfig"><a href="#CallbackConfig" class="headerlink" title="CallbackConfig"></a>CallbackConfig</h2><pre class="line-numbers language-none"><code class="language-none">@Order()
@Data
@Accessors(chain &#x3D; true)
@ConfigurationProperties(prefix &#x3D; &quot;transparent-delivery.callback&quot;)
@Component
@RefreshScope
public class CallbackConfig implements InitializingBean, ApplicationListener&lt;EnvironmentChangeEvent&gt; &#123;
    private static final Logger log &#x3D; LoggerFactory.getLogger(&quot;CONFIG_LOG&quot;);

    private List&lt;ChatbotConfig&gt; configs;
    private Map&lt;Integer, ChatbotConfig&gt; CHATBOT_MAP;

    public ChatbotConfig fetchByUserId(Integer userId) &#123;
        return CHATBOT_MAP.get(userId);
    &#125;

    @Override
    public void afterPropertiesSet() throws Exception &#123;
        log.info(&quot;Config chatbot callback information:&#123;&#125;!&quot;, JSON.toJSONString(configs));
        initConfigs(configs);
    &#125;

    @Override
    public void onApplicationEvent(EnvironmentChangeEvent event) &#123;
        log.info(&quot;Nacos refresh config information the current information is:&#123;&#125;!&quot;, JSON.toJSONString(configs));
        initConfigs(configs);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是每次在Nacos更新配置后，日志打印的值仍是修改之前的，为什么会出现这个现象？</p>
<h1 id="二、EnvironmentChangeEvent的Listener执行顺序"><a href="#二、EnvironmentChangeEvent的Listener执行顺序" class="headerlink" title="二、EnvironmentChangeEvent的Listener执行顺序"></a>二、EnvironmentChangeEvent的Listener执行顺序</h1><p>在Nacos上更新配置后，Spring会发布一个<code>RefreshEvent</code>事件，这个事件最后会被委托给<code>ContextRefresh</code>去处理，接下来我们结合源码，看一下处理流程。</p>
<h2 id="RefreshEventListener"><a href="#RefreshEventListener" class="headerlink" title="RefreshEventListener"></a>RefreshEventListener</h2><pre class="line-numbers language-none"><code class="language-none">package org.springframework.cloud.endpoint.event;

public class RefreshEventListener implements SmartApplicationListener &#123;

	@Override
	public void onApplicationEvent(ApplicationEvent event) &#123;
		if (event instanceof ApplicationReadyEvent) &#123;
			handle((ApplicationReadyEvent) event);
		&#125;
		else if (event instanceof RefreshEvent) &#123;
			handle((RefreshEvent) event);
		&#125;
	&#125;

	public void handle(ApplicationReadyEvent event) &#123;
		this.ready.compareAndSet(false, true);
	&#125;

	public void handle(RefreshEvent event) &#123;
		if (this.ready.get()) &#123; &#x2F;&#x2F; don&#39;t handle events before app is ready
			Set&lt;String&gt; keys &#x3D; this.refresh.refresh();
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>当SpringCloud接收到一个<code>RefreshEvent</code>事件后会委托给<code>ContextRefresher</code>的<code>refresh()</code>方法去处理。</p>
</blockquote>
<h2 id="ContextRefresher"><a href="#ContextRefresher" class="headerlink" title="ContextRefresher"></a>ContextRefresher</h2><pre class="line-numbers language-none"><code class="language-none">package org.springframework.cloud.context.refresh;

&#x2F;**
 * @author Dave Syer
 * @author Venil Noronha
 *&#x2F;
public class ContextRefresher &#123;

	public synchronized Set&lt;String&gt; refresh() &#123;
		Set&lt;String&gt; keys &#x3D; refreshEnvironment();
		this.scope.refreshAll();
		return keys;
	&#125;

	public synchronized Set&lt;String&gt; refreshEnvironment() &#123;
		Map&lt;String, Object&gt; before &#x3D; extract(
				this.context.getEnvironment().getPropertySources());
		addConfigFilesToEnvironment();
		Set&lt;String&gt; keys &#x3D; changes(before,
				extract(this.context.getEnvironment().getPropertySources())).keySet();
		this.context.publishEvent(new EnvironmentChangeEvent(this.context, keys));
		return keys;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>ContextRefresher</code>的<code>Refresh()</code>方法先将配置文件添加到<code>Environment</code>中，然后发布<code>EnvironmentChangeEvent</code>事件。</p>
</blockquote>
<h2 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a>AbstractApplicationContext</h2><pre class="line-numbers language-none"><code class="language-none">   @Override
public void publishEvent(ApplicationEvent event) &#123;
	publishEvent(event, null);
&#125;
   
protected void publishEvent(Object event, @Nullable ResolvableType eventType) &#123;
	&#x2F;&#x2F; 此处略去部分代码......

	&#x2F;&#x2F; Multicast right now if possible - or lazily once the multicaster is initialized
	if (this.earlyApplicationEvents !&#x3D; null) &#123;
		this.earlyApplicationEvents.add(applicationEvent);
	&#125;
	else &#123;
           &#x2F;&#x2F; 核心处理逻辑
		getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
	&#125;

	&#x2F;&#x2F; Publish event via parent context as well...
	if (this.parent !&#x3D; null) &#123;
		if (this.parent instanceof AbstractApplicationContext) &#123;
			((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
		&#125;
		else &#123;
			this.parent.publishEvent(event);
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</code>通过事件广播器将事件广播出去。</p>
</blockquote>
<h2 id="SimpleApplicationEventMulticaster"><a href="#SimpleApplicationEventMulticaster" class="headerlink" title="SimpleApplicationEventMulticaster"></a>SimpleApplicationEventMulticaster</h2><pre class="line-numbers language-none"><code class="language-none">package org.springframework.context.event;

public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster &#123;
	@Override
	public void multicastEvent(ApplicationEvent event) &#123;
		multicastEvent(event, resolveDefaultEventType(event));
	&#125;

	@Override
	public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123;
		ResolvableType type &#x3D; (eventType !&#x3D; null ? eventType : resolveDefaultEventType(event));
		Executor executor &#x3D; getTaskExecutor();
		for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;
			if (executor !&#x3D; null) &#123;
				executor.execute(() -&gt; invokeListener(listener, event));
			&#125;
			else &#123;
				invokeListener(listener, event);
			&#125;
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>multicastEvent</code>方法中获取当前事件的所有Listener后，循环调用Listener的<code>onApplicationEvent</code>方法。</p>
</blockquote>
<h2 id="AbstractApplicationEventMulticaster"><a href="#AbstractApplicationEventMulticaster" class="headerlink" title="AbstractApplicationEventMulticaster"></a>AbstractApplicationEventMulticaster</h2><pre class="line-numbers language-none"><code class="language-none">protected Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(
		ApplicationEvent event, ResolvableType eventType) &#123;
       &#x2F;&#x2F; 此处略去部分代码......

	if (this.beanClassLoader &#x3D;&#x3D; null ||
			(ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &amp;&amp;
					(sourceType &#x3D;&#x3D; null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) &#123;
		&#x2F;&#x2F; Fully synchronized building and caching of a ListenerRetriever
		synchronized (this.retrievalMutex) &#123;
			retriever &#x3D; this.retrieverCache.get(cacheKey);
			if (retriever !&#x3D; null) &#123;
				return retriever.getApplicationListeners();
			&#125;
			retriever &#x3D; new ListenerRetriever(true);
			Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners &#x3D;
					retrieveApplicationListeners(eventType, sourceType, retriever);
			this.retrieverCache.put(cacheKey, retriever);
			return listeners;
		&#125;
	&#125;
	else &#123;
		&#x2F;&#x2F; No ListenerRetriever caching -&gt; no synchronization necessary
		return retrieveApplicationListeners(eventType, sourceType, null);
	&#125;
&#125;

private Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners(
		ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType, @Nullable ListenerRetriever retriever) &#123;

	List&lt;ApplicationListener&lt;?&gt;&gt; allListeners &#x3D; new ArrayList&lt;&gt;();
	Set&lt;ApplicationListener&lt;?&gt;&gt; listeners;
	Set&lt;String&gt; listenerBeans;
	synchronized (this.retrievalMutex) &#123;
		listeners &#x3D; new LinkedHashSet&lt;&gt;(this.defaultRetriever.applicationListeners);
		listenerBeans &#x3D; new LinkedHashSet&lt;&gt;(this.defaultRetriever.applicationListenerBeans);
	&#125;

	&#x2F;&#x2F; Add programmatically registered listeners, including ones coming
	&#x2F;&#x2F; from ApplicationListenerDetector (singleton beans and inner beans).
	for (ApplicationListener&lt;?&gt; listener : listeners) &#123;
		if (supportsEvent(listener, eventType, sourceType)) &#123;
			if (retriever !&#x3D; null) &#123;
				retriever.applicationListeners.add(listener);
			&#125;
			allListeners.add(listener);
		&#125;
	&#125;

	AnnotationAwareOrderComparator.sort(allListeners);
	if (retriever !&#x3D; null &amp;&amp; retriever.applicationListenerBeans.isEmpty()) &#123;
		retriever.applicationListeners.clear();
		retriever.applicationListeners.addAll(allListeners);
	&#125;
	return allListeners;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>上述代码中根据事件类型获取所有Listener，然后根据<code>AnnotationAwareOrderComparator.sort(allListeners)</code>对Listener进行排序。</p>
</blockquote>
<h1 id="三、AnnotationAwareOrderComparator排序原理"><a href="#三、AnnotationAwareOrderComparator排序原理" class="headerlink" title="三、AnnotationAwareOrderComparator排序原理"></a>三、AnnotationAwareOrderComparator排序原理</h1><h2 id="AnnotationAwareOrderComparator"><a href="#AnnotationAwareOrderComparator" class="headerlink" title="AnnotationAwareOrderComparator"></a>AnnotationAwareOrderComparator</h2><pre class="line-numbers language-none"><code class="language-none">public class AnnotationAwareOrderComparator extends OrderComparator &#123;

	&#x2F;**
	 * This implementation checks for &#123;@link Order @Order&#125; or
	 * &#123;@link javax.annotation.Priority @Priority&#125; on various kinds of
	 * elements, in addition to the &#123;@link org.springframework.core.Ordered&#125;
	 * check in the superclass.
	 *&#x2F;
	@Override
	@Nullable
	protected Integer findOrder(Object obj) &#123;
		Integer order &#x3D; super.findOrder(obj);
		if (order !&#x3D; null) &#123;
			return order;
		&#125;
		return findOrderFromAnnotation(obj);
	&#125;

	@Nullable
	private Integer findOrderFromAnnotation(Object obj) &#123;
		AnnotatedElement element &#x3D; (obj instanceof AnnotatedElement ? (AnnotatedElement) obj : obj.getClass());
		MergedAnnotations annotations &#x3D; MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY);
		Integer order &#x3D; OrderUtils.getOrderFromAnnotations(element, annotations);
		if (order &#x3D;&#x3D; null &amp;&amp; obj instanceof DecoratingProxy) &#123;
			return findOrderFromAnnotation(((DecoratingProxy) obj).getDecoratedClass());
		&#125;
		return order;
	&#125;
&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="OrderComparator"><a href="#OrderComparator" class="headerlink" title="OrderComparator"></a>OrderComparator</h2><pre class="line-numbers language-none"><code class="language-none">public class OrderComparator implements Comparator&lt;Object&gt; &#123;
    	@Override
	public int compare(@Nullable Object o1, @Nullable Object o2) &#123;
		return doCompare(o1, o2, null);
	&#125;

	private int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) &#123;
		boolean p1 &#x3D; (o1 instanceof PriorityOrdered);
		boolean p2 &#x3D; (o2 instanceof PriorityOrdered);
		if (p1 &amp;&amp; !p2) &#123;
			return -1;
		&#125;
		else if (p2 &amp;&amp; !p1) &#123;
			return 1;
		&#125;

		int i1 &#x3D; getOrder(o1, sourceProvider);
		int i2 &#x3D; getOrder(o2, sourceProvider);
		return Integer.compare(i1, i2);
	&#125;

	private int getOrder(@Nullable Object obj, @Nullable OrderSourceProvider sourceProvider) &#123;
		Integer order &#x3D; null;
		&#x2F;&#x2F; 此处略去部分代码
		return (order !&#x3D; null ? order : getOrder(obj));
	&#125;

	protected int getOrder(@Nullable Object obj) &#123;
		if (obj !&#x3D; null) &#123;
			Integer order &#x3D; findOrder(obj);
			if (order !&#x3D; null) &#123;
				return order;
			&#125;
		&#125;
		return Ordered.LOWEST_PRECEDENCE;
	&#125;
&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>AnnotationAwareOrderComparator</code> 继承 <code>OrderComparator</code>，获取对象的Order值并进行排序，如果Order为空，则会被设置为最小优先级。</p>
</blockquote>
<h2 id="OrderUtils获取对象Order值"><a href="#OrderUtils获取对象Order值" class="headerlink" title="OrderUtils获取对象Order值"></a>OrderUtils获取对象Order值</h2><pre class="line-numbers language-none"><code class="language-none">public abstract class OrderUtils &#123;

	&#x2F;**
	 * Return the order from the specified annotations collection.
	 * &lt;p&gt;Takes care of &#123;@link Order @Order&#125; and
	 * &#123;@code @javax.annotation.Priority&#125;.
	 * @param element the source element
	 * @param annotations the annotation to consider
	 * @return the order value, or &#123;@code null&#125; if none can be found
	 *&#x2F;
	@Nullable
	static Integer getOrderFromAnnotations(AnnotatedElement element, MergedAnnotations annotations) &#123;
		if (!(element instanceof Class)) &#123;
			return findOrder(annotations);
		&#125;
		Object cached &#x3D; orderCache.get(element);
		if (cached !&#x3D; null) &#123;
			return (cached instanceof Integer ? (Integer) cached : null);
		&#125;
		Integer result &#x3D; findOrder(annotations);
		orderCache.put(element, result !&#x3D; null ? result : NOT_ANNOTATED);
		return result;
	&#125;

	@Nullable
	private static Integer findOrder(MergedAnnotations annotations) &#123;
		MergedAnnotation&lt;Order&gt; orderAnnotation &#x3D; annotations.get(Order.class);
		if (orderAnnotation.isPresent()) &#123;
			return orderAnnotation.getInt(MergedAnnotation.VALUE);
		&#125;
		MergedAnnotation&lt;?&gt; priorityAnnotation &#x3D; annotations.get(JAVAX_PRIORITY_ANNOTATION);
		if (priorityAnnotation.isPresent()) &#123;
			return priorityAnnotation.getInt(MergedAnnotation.VALUE);
		&#125;
		return null;
	&#125;
&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>从上面源码可以看出,如果没有设置<code>@Order</code>或是<code>javax.annotation.Priority</code>, Order值返回为<code>null</code>。</p>
</blockquote>
<h1 id="四、EnvironmentChangeEvent的Listener有哪些"><a href="#四、EnvironmentChangeEvent的Listener有哪些" class="headerlink" title="四、EnvironmentChangeEvent的Listener有哪些"></a>四、EnvironmentChangeEvent的Listener有哪些</h1><p>EnvironmentChangeEvent的Listener：</p>
<ul>
<li>默认的EnvironmentChangeEvent的Listener <code>ConfigurationPropertiesRebinder</code></li>
<li>自定义的EnvironmentChangeEvent的Listener <code>CallbackConfig</code></li>
</ul>
<p>其它EnvironmentChangeEvent的Listener暂不做分析处理。</p>
<h2 id="ConfigurationPropertiesRebinder"><a href="#ConfigurationPropertiesRebinder" class="headerlink" title="ConfigurationPropertiesRebinder"></a>ConfigurationPropertiesRebinder</h2><pre class="line-numbers language-none"><code class="language-none">package org.springframework.cloud.context.properties;

@Component
@ManagedResource
public class ConfigurationPropertiesRebinder
		implements ApplicationContextAware, ApplicationListener&lt;EnvironmentChangeEvent&gt; &#123;
    
    @ManagedOperation
	public void rebind() &#123;
		this.errors.clear();
		for (String name : this.beans.getBeanNames()) &#123;
			rebind(name);
		&#125;
	&#125;

	@ManagedOperation
	public boolean rebind(String name) &#123;
		if (!this.beans.getBeanNames().contains(name)) &#123;
			return false;
		&#125;
		if (this.applicationContext !&#x3D; null) &#123;
			try &#123;
				Object bean &#x3D; this.applicationContext.getBean(name);
				if (AopUtils.isAopProxy(bean)) &#123;
					bean &#x3D; ProxyUtils.getTargetObject(bean);
				&#125;
				if (bean !&#x3D; null) &#123;
					&#x2F;&#x2F; 此处省略部分代码......
					this.applicationContext.getAutowireCapableBeanFactory()
							.destroyBean(bean);
					this.applicationContext.getAutowireCapableBeanFactory()
							.initializeBean(bean, name);
					return true;
				&#125;
			&#125;
			&#x2F;&#x2F; 此处省略异常处理代码......
		&#125;
		return false;
	&#125;
&#125;            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在上述Listener中对<code>@ConfigurationProperties</code>标注的类进行销毁和重新创建，实现了配置更新。</p>
</blockquote>
<h2 id="CallbackConfig-1"><a href="#CallbackConfig-1" class="headerlink" title="CallbackConfig"></a>CallbackConfig</h2><pre class="line-numbers language-none"><code class="language-none">@Order()
@Data
@Accessors(chain &#x3D; true)
@ConfigurationProperties(prefix &#x3D; &quot;config.callback&quot;)
@Component
@RefreshScope
public class CallbackConfig implements InitializingBean, ApplicationListener&lt;EnvironmentChangeEvent&gt; &#123;
    private static final Logger log &#x3D; LoggerFactory.getLogger(&quot;CONFIG_LOG&quot;);

    private List&lt;ChatbotConfig&gt; configs;
    private Map&lt;Integer, ChatbotConfig&gt; CHATBOT_MAP;

    public ChatbotConfig fetchByUserId(Integer userId) &#123;
        return CHATBOT_MAP.get(userId);
    &#125;

    @Override
    public void afterPropertiesSet() throws Exception &#123;
        log.info(&quot;Config chatbot callback information:&#123;&#125;!&quot;, JSON.toJSONString(configs));
        initConfigs(configs);
    &#125;

    @Override
    public void onApplicationEvent(EnvironmentChangeEvent event) &#123;
        log.info(&quot;Nacos refresh config information the current information is:&#123;&#125;!&quot;, JSON.toJSONString(configs));
        initConfigs(configs);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="五、原因分析"><a href="#五、原因分析" class="headerlink" title="五、原因分析"></a>五、原因分析</h1><p>EnvironmentChangeEvent的Listener中有个默认的 <code>ConfigurationPropertiesRebinder</code>，这个Listener实现了配置的动态更新，但是这个Listener未使用<code>@Order</code> 注解，所以优先级是最小的。<br>我们自定义的EnvironmentChangeEvent的Listener <code>CallbackConfig</code> 中虽然设置了 <code>@Order</code> 注解并且默认值为最小优先级，但是和 <code>ConfigurationPropertiesRebinder</code> 的优先级是相同的，它们的执行顺序取决于加入集合的顺序，所以执行顺序不可控。无法通过设置 <code>@Order</code> 将自定的Listener放在 <code>ConfigurationPropertiesRebinder</code> 之后执行。</p>
<h1 id="六、解决方案"><a href="#六、解决方案" class="headerlink" title="六、解决方案"></a>六、解决方案</h1><p>如果是单独使用 <code>@ConfigurationProperties</code> 注解，则可以将配置的初始化验证放在 <code>@PostConstruct</code> 中处理。</p>
<blockquote>
<p>There is one exception. Any @ConfigurationProperties bean that is also in @RefreshScope is not rebound when the event is consumed. They could be rebound, but in the light of what happens in @RefreshScope, it would be redundant. Instead, they follow the usual path of @RefreshScope beans.</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://gist.github.com/dsyer/a43fe5f74427b371519af68c5c4904c7">Dynamic Configuration Properties in Spring Boot and Spring Cloud</a></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>EnvironmentChangeEvent</tag>
        <tag>ApplicationListener</tag>
      </tags>
  </entry>
  <entry>
    <title>到了一定年龄，低配生活，高配灵魂</title>
    <url>/2022/03/03/thought/dao-liao-yi-ding-nian-ling-di-pei-sheng-huo-gao-pei-ling-hun/</url>
    <content><![CDATA[<blockquote>
<p>本文摘录自新华社夜读文章: <a href="https://mp.weixin.qq.com/s/mij2iW2C0UTIhWtl4lzdCQ">到了一定年龄，低配生活，高配灵魂</a></p>
</blockquote>
<blockquote>
<h1 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h1></blockquote>
<p>有位作家说：<font color="#FF0000">“简朴的生活、高贵的灵魂，是人生的至高境界。”</font></p>
<p>年轻时，我们总以为人生就是要追求“高配置”的生活，追求豪华的车子、高档的房子、体面的工作……</p>
<p>渐渐地，聪明的人懂得：如果过于追求物质的“高配”，身体累，心更累；适当减减配置，人生才能活得自在从容。</p>
<p>看过一句话：“拥有就是被拥有。”意思是说，一旦我们拥有了某样东西，从那一刻起，我们也被这个东西所拥有。</p>
<p>比如，你拥有了一辆汽车，你同时被这辆汽车拥有，你常担心它被剐蹭、被偷，你要给它买保险、做保养。</p>
<p>比如，你拥有了一件奢侈品衣服，你同时也被这件衣服拥有，脏了要洗、皱了要烫、破了要修。</p>
<p>我们拥有的东西越多，需要担心和关注的外部事物就越多。</p>
<p>相反，如果我们在物质上追求简单，注意力就不会被太多的外物分散，就能集中精力去做自己喜欢的事。</p>
<p>很认可一句话：“简单的生活，不是苦行僧式的自虐，而是一种更为人性化的、经济的、环保的、轻松愉悦的生活。”</p>
<p>我们总是尝试拥有更多，却很少问问自己：拥有这么多之后，我就会幸福吗？</p>
<p>所谓物质低配，不是让你降低生活质量，而是在这个充满选择与欲望的世界里，学会辨别与舍弃。</p>
<p>低配物质生活，更能有力地掌控自己的人生。</p>
<blockquote>
<h1 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h1></blockquote>
<p>有一句话很经典：<font color="#FF0000">“当你的能力、地位、资源配不上你的社交野心，你所做的不过是无效社交。”</font></p>
<p>生活中，有些人逢人就添加好友，以为这就算拥有了人脉。</p>
<p>但当你有求于人时，发现自身不厉害，认识再多厉害的人也是徒劳。</p>
<p>人到了一定年龄，要懂得给自己的圈子做减法，减少能耗，把更多的时间留给自己，留给家人。</p>
<p>人的精力是有限的。时间在哪里，成就也就在哪里。</p>
<p>如果把所有的时间都用来去攀附所谓的“牛人圈子”，哪有时间去提升自己呢？</p>
<p>真正有质量的人生，都不是靠拼命社交建立起来的。</p>
<p>与其讨好攀附高配的圈子，不如过好自己的人生。</p>
<blockquote>
<h1 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a>part 3</h1></blockquote>
<p>有人曾说：<font color="#FF0000">“一个人对外在的物质要求越低，他对内在的要求越高。”</font></p>
<p>一个人只活在物质世界里，会一生劳碌、心灵空虚。</p>
<p>当我们不再追求物质的高配，而是保持宁静的心态，就容易做到灵魂的高配。</p>
<p>“非淡泊无以明志，非宁静无以致远。”</p>
<p>淡泊与宁静，是一种宠辱不惊的淡然与豁达，是一种成熟与从容，也是灵魂高配的一种境界。</p>
<p>到了一定年龄，请过“低配”生活。“低配”不是不思进取，而是张弛有度，不攀不比，不想太多。</p>
<p>衣服不一定要穿名牌，舒适就好；房子不一定要豪华，干净就好；车子不一定要高档，能代步就好；圈子不一定高端，有三五个知心朋友就好。</p>
<h1 id="一点点想法"><a href="#一点点想法" class="headerlink" title="一点点想法"></a>一点点想法</h1><p>新华社的夜读文章总是引人深思，“低配生活，高配灵魂”这种思想更是引起了我的共鸣，在这不久之前，自己喜欢买一些小物件以及一些流行的东西，喜欢把桌子摆的满满当当的。遇到一些喜欢的小物件，总是想买来摆在屋里。<br>最近读了《活出生命的意义》、《极简主义》这两本书，忽然内心生出一丝明悟，在人生有限的时间里，到底什么才是对自己来说比较重要的东西？在当代物欲横流的社会，存在着多少物质上的富人，精神上的穷人呢？<br>随着经历人生的种种事情，我对一个人的强大有了新的定义：一个真正强大的人，不是他身居高位、也不是他拥有多少财富，而是他面对任何事情的宠辱不惊的淡然与豁达。而这种淡然与豁达是经历了多少艰难险阻、刻骨铭心的经历了之后练就的，<br>人生是一场修炼，趁着年轻多去经历一些好的坏的事情，追求自己真正想要的幸福，努力成长为一个淡然与豁达的人。</p>
]]></content>
      <categories>
        <category>thought</category>
      </categories>
      <tags>
        <tag>低配生活</tag>
        <tag>高配灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title>Jack Welch关于绩效、活力曲线的观点</title>
    <url>/2022/04/04/thought/jackwelch-guan-yu-ji-xiao-huo-li-qu-xian-de-guan-dian/</url>
    <content><![CDATA[<blockquote>
<p>视频地址：<a href="https://www.bilibili.com/video/BV1BK4y1L7AU?p=1&share_medium=iphone&share_plat=ios&share_session_id=D3F36362-7E54-4577-9988-7E9E87ABBEBF&share_source=GENERIC&share_tag=s_i&timestamp=1648028847&unique_k=sXlj4Kj">Jack Welch关于绩效、活力曲线的观点</a></p>
</blockquote>
<h1 id="一、Jack-Welch简介"><a href="#一、Jack-Welch简介" class="headerlink" title="一、Jack Welch简介"></a>一、Jack Welch简介</h1><p>杰克·韦尔奇，美国企业家，于1981年至2001年担任通用电气（GE, General Electric）第八任首席执行官期间将该公司营业额提升到4100亿美金，有“中子弹杰克”（Neutron Jack）之称。</p>
<h2 id="1-1-职业履历"><a href="#1-1-职业履历" class="headerlink" title="1.1 职业履历"></a>1.1 职业履历</h2><p>韦尔奇在1960年进入通用电气位于麻州皮茨菲尔德的塑胶部门担任工程师，当时年薪10,500美元。1972年升为该部门的副总，1977年升为部门总经理，1979年升为副董事长，1981年升为第八任最高首席执行官。在20年的生涯后于2001年退休。</p>
<h2 id="1-2-经营手法"><a href="#1-2-经营手法" class="headerlink" title="1.2 经营手法"></a>1.2 经营手法</h2><p>韦尔奇担任通用电气首席执行官起，开始针对公司进行组织再造，他以“三个圈圈”列出通用电气的留存事业，将其他绩效不好的事业部出售或关闭，包括了成为通用电气传统的家电事业。因此，通用电气原有数百个事业，被缩减到不到20个事业。</p>
<p>1996年起，韦尔奇推动“六标准差”（6-Sigma），以将通用电气产品的不良率降低到千万分之34。</p>
<p>韦尔奇最受争议的改革，就是大幅裁员。通用电气员工人数由最高时的41万人裁减到23万人，裁员率高达40%。韦尔奇外号“中子弹杰克”的由来，即因为韦尔奇的大幅裁员有如中子弹一样的特性：杀人而不伤一物。</p>
<p>韦尔奇将通用电气转变为学习型组织，将原有企业内的教育中心投入经费改造为克顿维尔（Crotonville）管理学院。通用电气许多中高阶主管皆到过此学院学习。</p>
<p>借由一连串的兴革，在韦尔奇2001年9月底退休时，通用电气的年营业额从上任前的250亿美元成长到1400亿美元，获利由15亿美元上升到127亿美元。</p>
<h1 id="二、绩效及活力曲线"><a href="#二、绩效及活力曲线" class="headerlink" title="二、绩效及活力曲线"></a>二、绩效及活力曲线</h1><p>Jack Welch作为经理人最显著的4大特点：真实、活力、坦率、差异化管理。</p>
<h2 id="2-1-真实"><a href="#2-1-真实" class="headerlink" title="2.1 真实"></a>2.1 真实</h2><p>一个领导者必须真实。领导者不必刻意去扮演什么样的角色，因为人们轻易发现“伪君子”，人们希望看到的是表里如一你，你可以信任、可以依赖、可以和睦、融洽相处。</p>
<h2 id="2-2-活力"><a href="#2-2-活力" class="headerlink" title="2.2 活力"></a>2.2 活力</h2><p>活力与激励紧密关联，领导者应该具有强烈的使命感和明确的愿景，并且对此坚信不疑。同时激励感染与这个愿景相关的人主动追随你去追求勾勒出的使命和愿景。激励的关键在于让团队成员感受到愿景，明白前进的方向。</p>
<h3 id="2-2-1-如何激发活力？"><a href="#2-2-1-如何激发活力？" class="headerlink" title="2.2.1 如何激发活力？"></a>2.2.1 如何激发活力？</h3><p>激发团队成员的活力，需要激发大家的互动，分享每个人的知识与经验，从成员身上互相学习，汲取集体的智慧，最后达成统一共识。</p>
<h2 id="2-3-坦率"><a href="#2-3-坦率" class="headerlink" title="2.3 坦率"></a>2.3 坦率</h2><p>坦率就是要讲实话，鼓励员工说出自己的真实想法。在进行差异化管理的时候，坦率是差异化管理的基础，组织要对员工进行客观真实的评估。</p>
<h2 id="2-4-差异化管理"><a href="#2-4-差异化管理" class="headerlink" title="2.4 差异化管理"></a>2.4 差异化管理</h2><p>每个人都应该清楚自己在团队中的位置，271原则可以让每个人能够明确自己的位置。虽然这个机制存在不少偏见、不公，甚至会造成积怨，但是就实际来说它是最有效的方式让成员清楚自己在组织中的定位。</p>
<h3 id="顶尖的20"><a href="#顶尖的20" class="headerlink" title="顶尖的20%"></a>顶尖的20%</h3><p>这类人活力十足、会鼓舞他人、讨人喜欢，同时它们喜欢看到别人成长、喜欢鼓励别人，不自私小气，在他们身上有一种慷慨的精神。他们真心的为他人的成功感到高兴、能够主动提拔人才，形成一种积极的氛围，极大大家的潜力。</p>
<h3 id="中坚力量70"><a href="#中坚力量70" class="headerlink" title="中坚力量70%"></a>中坚力量70%</h3><p>这个群里虽然不是举足轻重的，但是也是非常重要的，这类人聪明、优秀、有价值、努力工作。</p>
<blockquote>
<h4 id="存在失去21-26-这个区间成员的风险"><a href="#存在失去21-26-这个区间成员的风险" class="headerlink" title="存在失去21% - 26%这个区间成员的风险"></a>存在失去21% - 26%这个区间成员的风险</h4><p>必须要不断的去解释当前的评估是周期性的而非永久的，他们还有提升的空间，同时在评估中记录他们做的好的地方以及存在的问题和需要改进的地方，定期沟通同步，达成一致。</p>
</blockquote>
<h3 id="末尾的10"><a href="#末尾的10" class="headerlink" title="末尾的10%"></a>末尾的10%</h3><p>这类群里的特点有：不擅长团队合作、无精打采、冷嘲热讽，这些人身上充满负能量而且总喜欢泼冷水。</p>
<blockquote>
<h4 id="搅局者或者是泼凉水的人"><a href="#搅局者或者是泼凉水的人" class="headerlink" title="搅局者或者是泼凉水的人"></a>搅局者或者是泼凉水的人</h4><p>这些人中有一些聪明的人，他们勇于挑战权威，敢于说真话，这些人值得尊敬，领导着也应该听取他们的声音。所以对于这些人要给予适当的容忍 ，但要做好约束。</p>
</blockquote>
<p><font color="#ff0000">明令禁止：大会之后开小会</font></p>
<h2 id="2-5-经验建议"><a href="#2-5-经验建议" class="headerlink" title="2.5 经验建议"></a>2.5 经验建议</h2><h3 id="快速行动"><a href="#快速行动" class="headerlink" title="快速行动"></a>快速行动</h3><p>当我们做出决定后，我们应该立即行动。即使我们的决定面临重大的后果，但是犹豫不能让我们把这种后果降低或消除，该来的终究会来，犹豫不决畏畏缩缩反而会引起为严重的后果。</p>
<h3 id="继任计划，如何传递好交接棒？"><a href="#继任计划，如何传递好交接棒？" class="headerlink" title="继任计划，如何传递好交接棒？"></a>继任计划，如何传递好交接棒？</h3><p>提前启动选择候选人的几乎，人是会变的，生活在变化、家庭关系在变化，你无法知道在下一个阶段人会变成什么样？多挑选一些候选人，提前进行。</p>
<h3 id="鼓励庆祝胜利"><a href="#鼓励庆祝胜利" class="headerlink" title="鼓励庆祝胜利"></a>鼓励庆祝胜利</h3><p>任何小小的胜利都需要庆祝，这能激励整个团队，鼓励他们继续加油。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Jack Welch管理的4大特点：真实、活力、坦率、差异化管理。</p>
<ul>
<li>真实：一个真实的领导者才能够被信任和依赖，才能和团队成员和睦、融洽相处。</li>
<li>活力：领导者必须要要有明确的使命和愿景，同时感染激励团队成员主动追随你去追求勾勒出的使命和愿景。激励的关键在于让团队成员感受到使命和愿景，明白前进的方向。</li>
<li>坦率：坦率是差异化管理的基础，在进行差异化管理的时候，组织与成员之间沟通反馈必须建立在坦率的基础之上。</li>
<li>差异化管理看：组织内部需要建立271机制，虽然这个机制存在不少偏见、不公，甚至会造成积怨，但是就实际来说它是最有效的方式让成员清楚自己在组织中的定位，从而形成正向激励，激发团队的活力。271机制中：顶尖的20%，这些人属于A类员工，他们活力十足且能力优秀同时能够主动培养提拔人才，这类群体需要给予大幅激励倾斜；中坚力量70%：这些人属于B类员工，他们是团队的中坚力量，需要注意21%-26%区间人，要做好评估结果的反馈和沟通并达成一致，同时提供更多机会促进其发展；末尾的10%：存在问题的员工，对于这类群体，如果还有改变的空间，可以为其提供必要支持和帮助，帮助他们快速改变，否则应尽快优化处理。</li>
<li>快速行动： 当我们做出决定后，我们应该立即行动。即使我们的决定面临重大的后果，但是犹豫不能让我们把这种后果降低或消除，该来的终究会来，犹豫不决畏畏缩缩反而会引起为严重的后果。</li>
</ul>
]]></content>
      <categories>
        <category>thought</category>
      </categories>
      <tags>
        <tag>Jack Welch</tag>
        <tag>绩效</tag>
      </tags>
  </entry>
</search>
