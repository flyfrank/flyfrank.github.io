<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java 和 HTTP 的那些事（四） HTTPS 和 证书 | 逐光の博客</title><meta name="author" content="逐光"><meta name="copyright" content="逐光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="非原创，转载于：https:&amp;#x2F;&amp;#x2F;www.aneasystone.com&amp;#x2F;archives&amp;#x2F;2016&amp;#x2F;04&amp;#x2F;java-and-https.html  说起 HTTP 的那些事，则不得不提 HTTPS ，而说起 HTTPS ，则不得不提数字证书。这篇博客将从 Java 的角度，学习 HTTPS 和数字"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.mpoom.cn/2020/07/09/java/java-he-http-de-na-xie-shi-si-https-he-zheng-shu/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 和 HTTP 的那些事（四） HTTPS 和 证书',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-17 11:54:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/theme/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/book/"><i class="fa-fw fa fa-book"></i><span> 读书</span></a></div><div class="menus_item"><a class="site-page" href="/categories/thought/"><i class="fa-fw fa fa-lightbulb"></i><span> 思考感悟</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">逐光の博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/book/"><i class="fa-fw fa fa-book"></i><span> 读书</span></a></div><div class="menus_item"><a class="site-page" href="/categories/thought/"><i class="fa-fw fa fa-lightbulb"></i><span> 思考感悟</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java 和 HTTP 的那些事（四） HTTPS 和 证书</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-08T16:00:00.000Z" title="发表于 2020-07-09 00:00:00">2020-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T03:54:21.210Z" title="更新于 2025-09-17 11:54:21">2025-09-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 和 HTTP 的那些事（四） HTTPS 和 证书"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>非原创，转载于：<a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2016/04/java-and-https.html">https://www.aneasystone.com/archives/2016/04/java-and-https.html</a></p>
</blockquote>
<p>说起 HTTP 的那些事，则不得不提 HTTPS ，而说起 HTTPS ，则不得不提数字证书。这篇博客将从 Java 的角度，学习 HTTPS 和数字证书技术，并分享爬虫开发的过程中针对爬取 HTTPS 站点时可能遇到的一些问题。<br>在前面的几篇博客里，其实已经略微提到过 HTTPS 了，譬如使用 <code>HttpsURLConnection</code> 类发送 HTTPS 请求，在使用代理时 HTTP 和 HTTPS 的一些差异等等。关于 HTTPS 的概念就不废话了，下面直接进入正题。</p>
<h2 id="一、访问-HTTPS-站点"><a href="#一、访问-HTTPS-站点" class="headerlink" title="一、访问 HTTPS 站点"></a>一、访问 HTTPS 站点</h2><p>在前面的第一篇博客<a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2015/12/java-and-http-one.html">《模拟 HTTP 请求》</a>里，介绍了两种方法来模拟发送 HTTP 请求，访问 HTTP 站点。一种方式是通过 java.net 自带的 <code>HttpURLConnection</code>，另一种方式是通过 Apache 的 <code>HttpClient</code>，这两种方式各有各的优势。这里也使用这两种方式来访问 HTTPS 站点，从下面的代码可以看到，和前面访问 HTTP 站点几乎完全一样。</p>
<h3 id="1-1-使用-HttpURLConnection"><a href="#1-1-使用-HttpURLConnection" class="headerlink" title="1.1 使用 HttpURLConnection"></a>1.1 使用 HttpURLConnection</h3><pre class="line-numbers language-none"><code class="language-none">@Test
public void basicHttpsGet() throws Exception &#123;
     
    String url &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;;
    URL obj &#x3D; new URL(url);
 
    HttpsURLConnection con &#x3D; (HttpsURLConnection) obj.openConnection();    
    con.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) ...&quot;);
    con.setRequestProperty(&quot;Accept-Language&quot;, &quot;en-US,en;q&#x3D;0.5&quot;);
    con.setRequestMethod(&quot;GET&quot;);
 
    String responseBody &#x3D; readResponseBody(con.getInputStream());
    System.out.println(responseBody);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-2-使用-HttpClient"><a href="#1-2-使用-HttpClient" class="headerlink" title="1.2 使用 HttpClient"></a>1.2 使用 HttpClient</h3><pre class="line-numbers language-none"><code class="language-none">@Test
public void basicHttpsGet() throws Exception &#123;
     
    String url &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;;    
    HttpGet request &#x3D; new HttpGet(url);
    request.setHeader(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) ...&quot;);
     
    CloseableHttpClient httpclient &#x3D; HttpClients.createDefault();
    CloseableHttpResponse response &#x3D; httpclient.execute(request);
    String responseBody &#x3D; readResponseBody(response);
    System.out.println(responseBody);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>具体的代码解释参见第一篇博客，这里不再赘述。一般情况下，访问 HTTPS 站点就和访问 HTTP 站点一样简单，无论是 HttpURLConnection 还是 HttpClient ，都将底层的实现细节封装了起来，给我们提供了一致的对外接口，所以我们不用关心 HTTPS 的实现原理。对底层细节的封装，本来是一件好事，也是一种好的设计方式，可以让开发人员使用起来更方便，提高开发效率，但是对于那些不求甚解的人来说，可能带来的困惑比之带来的方便要更多。</p>
<h3 id="1-3-遭遇-PKIX-path-building-failed"><a href="#1-3-遭遇-PKIX-path-building-failed" class="headerlink" title="1.3 遭遇 PKIX path building failed"></a>1.3 遭遇 PKIX path building failed</h3><p>使用上面的代码作为爬虫程序爬取成千上万的网页，在大多数情况下，无论是 HTTP 也好，HTTPS 也罢，都可以很好的工作。不过有时候，你可能没那么好的运气，有些站点在墙外，被强大的防火长城拒之门外，这时你可以找一些境外代理，通过<a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2015/12/java-and-http-using-proxy.html">《使用代理》</a>这篇博客中介绍的方法来解决；有些站点需要使用身份认证输入用户名密码才能访问，这可以使用上一篇博客<a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2016/03/java-and-http-authentication.html">《代理认证》</a>中介绍的方法来解决；另外，在访问有些 HTTPS 站点时，你还可能会遇到下面的异常：</p>
<blockquote>
<p>javax.net.ssl.SSLHandshakeException:<br>sun.security.validator.ValidatorException: PKIX path building failed:<br>sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</p>
</blockquote>
<p>要解决这个异常，这就是我们这篇将要介绍的内容。</p>
<h2 id="二、证书认证的原理"><a href="#二、证书认证的原理" class="headerlink" title="二、证书认证的原理"></a>二、证书认证的原理</h2><p>大多数人第一次遇到上面的异常时的反应，估计都是一脸茫然，因为这个异常信息提示比较模糊，对于不懂 HTTPS 的人来说，什么 SSLHandshake ，什么 PKIX path ，完全不知所云。所以我们要先弄懂 HTTPS 的工作原理，才好去解决这个问题。我们知道 HTTPS 其实就是 HTTP + SSL&#x2F;TLS 的合体，它其实还是 HTTP 协议，只是在外面加了一层，SSL 是一种加密安全协议，引入 SSL 的目的是为了解决 HTTP 协议在不可信网络中使用明文传输数据导致的安全性问题。可以说，整个互联网的通信安全，都是建立在 SSL&#x2F;TLS 的安全性之上的。</p>
<h3 id="2-1-SSL-TLS-协议及其握手过程"><a href="#2-1-SSL-TLS-协议及其握手过程" class="headerlink" title="2.1 SSL&#x2F;TLS 协议及其握手过程"></a>2.1 SSL&#x2F;TLS 协议及其握手过程</h3><p>学过计算机网络的同学肯定都还记得 TCP 在建立连接时的三次握手，之所以需要 TCP 三次握手，是因为网络中存在延迟的重复分组，可能会导致服务器重复建立连接造成不必要的开销。SSL&#x2F;TLS 协议在建立连接时与此类似，也需要客户端和服务器之间进行握手，但是其目的却大相径庭，在 SSL&#x2F;TLS 握手的过程中，客户端和服务器彼此交换并验证证书，并协商出一个 “对话密钥” ，后续的所有通信都使用这个 “对话密钥” 进行加密，保证通信安全。</p>
<p>网上有很多 SSL&#x2F;TLS 握手的示意图，其中下面这副非常全面，也非常专业，想深入了解 SSL&#x2F;TLS 的同学可以研究下。</p>
<p><a target="_blank" rel="noopener" href="http://www.cheat-sheets.org/saved-copy/Ssl_handshake_with_two_way_authentication_with_certificates-1.pdf">http://www.cheat-sheets.org/saved-copy/Ssl_handshake_with_two_way_authentication_with_certificates-1.pdf</a></p>
<p>阮一峰在他的 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL&#x2F;TLS协议运行机制的概述》</a> 和 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解SSL&#x2F;TLS协议》</a> 两篇博客中详细介绍了 SSL&#x2F;TLS 的原理，感兴趣的同学可以去看看。我这里使用 <a target="_blank" rel="noopener" href="https://publib.boulder.ibm.com/tividd/td/TRM/SC23-4822-00/zh_CN/HTML/user277.htm">IBM Tivoli Risk Manager 用户手册</a> 里的一张图（因为这张图比较浅显易懂）来大概的说明下我们在平时使用浏览器访问 HTTPS 站点时，中间发生的握手过程。</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/3515553513.png" alt="ssl_handshake.png"></p>
<p>整个 SSL&#x2F;TLS 的握手和通信过程，简单来说，其实可以分成下面三个阶段：</p>
<ol>
<li>打招呼<ul>
<li>当用户通过浏览器访问 HTTPS 站点时，浏览器会向服务器打个招呼（ClientHello），服务器也会和浏览器打个招呼（ServerHello）。所谓的打招呼，实际上是告诉彼此各自的 SSL&#x2F;TLS 版本号以及各自支持的加密算法等，让彼此有一个初步了解。</li>
</ul>
</li>
<li>表明身份、验证身份<ul>
<li>第二步是整个过程中最复杂的一步，也是 HTTPS 通信中的关键。为了保证通信的安全，首先要保证我正在通信的人确实就是那个我想与之通信的人，服务器会发送一个证书来表明自己的身份，浏览器根据证书里的信息进行核实（为什么通过证书就可以证明身份呢？怎么通过证书来验证对方的身份呢？这个后面再说）。如果是双向认证的话，浏览器也会向服务器发送客户端证书。</li>
<li>双方的身份都验证没问题之后，浏览器会和服务器协商出一个 “对话密钥” ，要注意这个 “对话密钥” 不能直接发给对方，而是要用一种只有对方才能懂的方式发给他，这样才能保证密钥不被别人截获（或者就算被截获了也看不懂）。</li>
</ul>
</li>
<li>通信<ul>
<li>至此，握手就结束了。双方开始聊天，并通过 “对话密钥” 加密通信的数据。</li>
</ul>
</li>
</ol>
<p>握手的过程大致如此，我们现在已经了解到 HTTPS 通信需要进行一次握手，所以上面看到的 <code>javax.net.ssl.SSLHandshakeException</code> 这个异常，我们也不难理解，实际上也就是在 SSL&#x2F;TLS 握手的过程中出现了问题。当然，这其中还有很多很多细节，下面继续。</p>
<h3 id="2-2-HTTPS-中的密码学"><a href="#2-2-HTTPS-中的密码学" class="headerlink" title="2.2 HTTPS 中的密码学"></a>2.2 HTTPS 中的密码学</h3><p>HTTPS 协议之所以复杂，是为了保证通信过程中数据的安全性，而要保证通信安全，它在协议中运用了大量的密码学原理，可以说 HTTPS 是集密码学之大成。无论是在 SSL&#x2F;TLS 握手的过程中，还是在加密通信的过程中，HTTPS 都涉及了大量的密码学概念，譬如，在证书的数字签名中使用了哈希算法和非对称加密算法，在加密通信的过程中使用了对称加密算法，为了防止传输的数据被篡改和重放还使用了 MAC（消息认证码）等。</p>
<p>要想深入了解 HTTPS 的工作原理，下面这些概念还是得好好研究下，网上已经有很多文章介绍这些概念了，我在这里总结一下。</p>
<ul>
<li>哈希<ul>
<li>哈希算法又称散列，它是一种将任意长度的数据转化为固定长度的算法</li>
<li>哈希算法是不可逆的</li>
<li>常见的哈希算法有 MD5 和 SHA1</li>
</ul>
</li>
<li>对称加密<ul>
<li>对称加密指的是加密和解密使用相同一个密钥</li>
<li>对称加密的优点是速度快，缺点是密钥管理不方便，必须共享密钥</li>
<li>常见的对称加密算法有 DES、AES、Blowfish 等</li>
</ul>
</li>
<li>非对称加密<ul>
<li>非对称加密指的是加密和解密使用不同的密钥，其中一个是公钥，另一个是私钥，公钥是公开的，私钥只有自己知道</li>
<li>使用公钥加密的数据必须使用私钥解密，使用私钥加密的数据必须使用公钥解密</li>
<li>公钥和私钥之间存在着某种联系，但是从公钥不能（或很难）推导出私钥</li>
<li>非对称加密的缺点是速度慢，优点是密钥管理很方便</li>
<li>常见的非对称加密算法有 RSA、ECC 等</li>
</ul>
</li>
<li>数字证书</li>
</ul>
<h3 id="2-3-关于证书"><a href="#2-3-关于证书" class="headerlink" title="2.3 关于证书"></a>2.3 关于证书</h3><p>简单来说，数字证书就好比介绍信上的公章，有了它，就可以证明这份介绍信确实是由某个公司发出的，而证书可以用来证明任何一个东西的身份，只要这个东西能出示一份证明自己身份的证书即可，譬如可以用来验证某个网站的身份，可以验证某个文件是否可信等等。<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html">《数字证书及 CA 的扫盲介绍》</a> 和 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html">《数字证书原理》</a> 这篇博客对数字证书进行了很通俗的介绍。</p>
<p>知道了证书是什么之后，我们往往更关心它的原理，在上面介绍 SSL&#x2F;TLS 握手的时候留了两个问题：为什么通过证书就可以证明身份呢？怎么通过证书来验证对方的身份呢？</p>
<p>这就要用到上面所说的非对称加密了，非对称加密的一个重要特点是：使用公钥加密的数据必须使用私钥才能解密，同样的，使用私钥加密的数据必须使用公钥解密。正是因为这个特点，网站就可以在自己的证书中公开自己的公钥，并使用自己的私钥将自己的身份信息进行加密一起公开出来，这段被私钥加密的信息就是证书的数字签名，浏览器在获取到证书之后，通过证书里的公钥对签名进行解密，如果能成功解密，则说明证书确实是由这个网站发布的，因为只有这个网站知道他自己的私钥（如果他的私钥没有泄露的话）。</p>
<p>在非对称加密算法中，最出众的莫过于 RSA 算法，关于 RSA 算法的数学细节，可以参考阮一峰的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA算法原理（一）》</a>和<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">《RSA算法原理（二）》</a>这两篇博客，强烈推荐。</p>
<p>当然，如果只是简单的对数字签名进行校验的话，还不能完全保证这个证书确实就是网站所有，黑客完全可以在中间进行劫持，使用自己的私钥对网站身份信息进行加密，并将证书中的公钥替换成自己的公钥，这样浏览器同样可以解密数字签名，签名中身份信息也是完全合法的。这就好比那些地摊上伪造公章的小贩，他们可以伪造出和真正的公章完全一样的出来以假乱真。为了解决这个问题，信息安全的专家们引入了 CA 这个东西，所谓 CA ，全称为 Certificate Authority ，翻译成中文就是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84">证书授权中心</a>，它是专门负责管理和签发证书的第三方机构。因为证书颁发机构关系到所有互联网通信的身份安全，因此一定要是一个非常权威的机构，像 GeoTrust、GlobalSign 等等，这里有一份<a target="_blank" rel="noopener" href="https://www.sslshopper.com/certificate-authority-reviews.html">常见的 CA 清单</a>。如果一个网站需要支持 HTTPS ，它就要一份证书来证明自己的身份，而这个证书必须从 CA 机构申请，大多数情况下申请数字证书的价格都不菲，不过也有一些免费的证书供个人使用，像最近比较火的 <a target="_blank" rel="noopener" href="https://letsencrypt.org/">Let’s Encrypt</a> 。从安全性的角度来说，免费的和收费的证书没有任何区别，都可以为你的网站提供足够高的安全性，唯一的区别在于如果你从权威机构购买了付费的证书，一旦由于证书安全问题导致经济损失，可以获得一笔巨额的赔偿。</p>
<p>如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，便形成证书发给申请者。如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。通过这种方式，黑客就不能简单的修改证书中的公钥了，因为现在公钥有了 CA 的数字签名，由 CA 来证明公钥的有效性，不能轻易被篡改，而黑客自己的公钥是很难被 CA 认可的，所以我们无需担心证书被篡改的问题了。</p>
<p>下图显示了证书的申请流程（图片来自<a target="_blank" rel="noopener" href="https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/">刘坤的技术博客</a>）：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/3454538623.png" alt="shuzizhengshu_5.png"></p>
<p>CA 证书可以具有层级结构，它建立了自上而下的信任链，下级 CA 信任上级 CA ，下级 CA 由上级 CA 颁发证书并认证。 譬如 Google 的证书链如下图所示：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/3953592763.png" alt="shuzizhengshu_6.png"></p>
<p>可以看出：google.com.hk 的 SSL 证书由 Google Internet Authority G2 这个 CA 来验证，而 Google Internet Authority G2 由 GeoTrust Global CA 来验证，GeoTrust Global CA 由 Equifax Secure Certificate Authority 来验证。这个最顶部的证书，我们称之为根证书（root certificate），那么谁来验证根证书呢？答案是它自己，根证书自己证明自己，换句话来说也就是根证书是不需要证明的。浏览器在验证证书时，从根证书开始，沿着证书链的路径依次向下验证，根证书是整个证书链的安全之本，如果根证书被篡改，整个证书体系的安全将受到威胁。所以不要轻易的相信根证书，当下次你访问某个网站遇到提示说，请安装我们的根证书，它可以让你访问我们网站的体验更流畅通信更安全时，最好留个心眼。在安装之前，不妨看看这几篇博客：<a target="_blank" rel="noopener" href="https://www.jayxon.com/12306-certificate/">《12306的证书问题》</a>、<a target="_blank" rel="noopener" href="http://www.xieyidian.com/3213">《在线买火车票为什么要安装根证书？》</a>。</p>
<p>最后总结一下，其实上面说的这些，什么非对称加密，数字签名，CA 机构，根证书等等，其实都是 PKI 的核心概念。PKI（Public Key Infrastructure）中文称作公钥基础设施，它提供公钥加密和数字签名服务的系统或平台，方便管理密钥和证书，从而建立起一个安全的网络环境。而数字证书最常见的格式是 X.509 ，所以这种公钥基础设施又称之为 PKIX 。</p>
<p>至此，我们大致弄懂了上面的异常信息，<code>sun.security.validator.ValidatorException: PKIX path building failed</code>，也就是在沿着证书链的路径验证证书时出现异常，验证失败了。</p>
<p>讲了这么多，全都是些理论的东西，下面开始实践吧，看看怎么解决这个异常。</p>
<h3 id="2-4-关于-Java-里的证书"><a href="#2-4-关于-Java-里的证书" class="headerlink" title="2.4 关于 Java 里的证书"></a>2.4 关于 Java 里的证书</h3><p>上面所介绍的是浏览器对证书进行验证的过程，浏览器保存了一个常用的 CA 证书列表，在验证证书链的有效性时，直接使用保存的证书里的公钥进行校验，如果在证书列表中没有找到或者找到了但是校验不通过，那么浏览器会警告用户，由用户决定是否继续。与此类似的，操作系统也一样保存有一份可信的证书列表，譬如在 Windows 系统下，你可以运行 <code>certmgr.msc</code> 打开证书管理器查看，这些证书实际上是存储在 Windows 的注册表中，一般情况下位于：<code>\SOFTWARE\Microsoft\SystemCertificates\</code> 路径下。那么在 Java 程序中是如何验证证书的呢？</p>
<p>和浏览器和操作系统类似，Java 在 JRE 的安装目录下也保存了一份默认可信的证书列表，这个列表一般是保存在 <code>$JRE/lib/security/cacerts</code> 文件中。要查看这个文件，可以使用类似 <a target="_blank" rel="noopener" href="http://www.keystore-explorer.org/">KeyStore Explorer</a> 这样的软件，当然也可以使用 JRE 自带的 keytool 工具（后面再介绍），cacerts 文件的默认密码为 <code>changeit</code> （但是我保证，大多数人都不会 change it）。</p>
<p>我们知道，证书有很多种不同的存储格式，譬如 CA 在发布证书时，常常使用 PEM 格式，这种格式的好处是纯文本，内容是 BASE64 编码的，证书中使用 “—–BEGIN CERTIFICATE—–” 和 “—–END CERTIFICATE—–” 来标识。另外还有比较常用的二进制 DER 格式，在 Windows 平台上较常使用的 PKCS#12 格式等等。当然，不同格式的证书之间是可以相互转换的，我们可以使用 <code>openssl</code> 这个命令行工具来转换，参考 <a target="_blank" rel="noopener" href="https://www.sslshopper.com/ssl-converter.html">SSL Converter</a> ，另外，想了解更多证书格式的，可以参考这里：<a target="_blank" rel="noopener" href="https://blogs.msdn.microsoft.com/kaushal/2010/11/04/various-ssltls-certificate-file-typesextensions/">Various SSL&#x2F;TLS Certificate File Types&#x2F;Extensions</a> 。</p>
<p>在 Java 平台下，证书常常被存储在 KeyStore 文件中，上面说的 cacerts 文件就是一个 KeyStore 文件，KeyStore 不仅可以存储数字证书，还可以存储密钥，存储在 KeyStore 文件中的对象有三种类型：Certificate、PrivateKey 和 SecretKey 。Certificate 就是证书，PrivateKey 是非对称加密中的私钥，SecretKey 用于对称加密，是对称加密中的密钥。KeyStore 文件根据用途，也有很多种不同的格式：JKS、JCEKS、PKCS12、DKS 等等，PixelsTech 上有一系列文章对 KeyStore 有深入的介绍，可以学习下：<a target="_blank" rel="noopener" href="http://www.pixelstech.net/article/1408345768-Different-types-of-keystore-in-Java----Overview">Different types of keystore in Java</a> 。</p>
<p>到目前为止，我们所说的 KeyStore 其实只是一种文件格式而已，实际上在 Java 的世界里 KeyStore 文件分成两种：KeyStore 和 TrustStore，这是两个比较容易混淆的概念，不过这两个东西从文件格式来看其实是一样的。KeyStore 保存私钥，用来加解密或者为别人做签名；TrustStore 保存一些可信任的证书，访问 HTTPS 时对被访问者进行认证，以确保它是可信任的。所以准确来说，上面的 cacerts 文件应该叫做 TrustStore 而不是 KeyStore，只是它的文件格式是 KeyStore 文件格式罢了。</p>
<p>除了 KeyStore 和 TrustStore ，Java 里还有两个类 KeyManager 和 TrustManager 与此息息相关。<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html">JSSE 的参考手册</a>中有一张示意图，说明了各个类之间的关系：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/4013537635.jpg" alt="jsse-class.jpg"></p>
<p>可以看出如果要进行 SSL 会话，必须得新建一个 <code>SSLSocket</code> 对象，而 SSLSocket 对象是通过 <code>SSLSocketFactory</code> 来管理的，SSLSocketFactory 对象则依赖于 <code>SSLContext</code> ，SSLContext 对象又依赖于 <code>keyManager</code>、<code>TrustManager</code> 和 <code>SecureRandom</code>。我们这里最关心的是 TrustManager 对象，另外两个暂且忽略，因为正是 TrustManager 负责证书的校验，对网站进行认证，要想在访问 HTTPS 时通过认证，不报 <code>sun.security.validator.ValidatorException</code> 异常，必须从这里开刀。</p>
<h2 id="三、自定义-TrustManager-绕过证书检查"><a href="#三、自定义-TrustManager-绕过证书检查" class="headerlink" title="三、自定义 TrustManager 绕过证书检查"></a>三、自定义 TrustManager 绕过证书检查</h2><p>我们知道了 TrustManager 是专门负责校验证书的，那么最容易想到的方法应该就是改写 TrustManager 类，让它不要对证书做校验，这种方法虽然粗暴，但是却相当有效，而且 Java 中的 TrustManager 也确实可以被重写，下面是示例代码：</p>
<pre class="line-numbers language-none"><code class="language-none">@Test
public void basicHttpsGetIgnoreCertificateValidation() throws Exception &#123;
     
    String url &#x3D; &quot;https:&#x2F;&#x2F;kyfw.12306.cn&#x2F;otn&#x2F;&quot;;
     
    &#x2F;&#x2F; Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts &#x3D; new TrustManager[] &#123;
        new X509TrustManager() &#123;
            public X509Certificate[] getAcceptedIssuers() &#123;
                return null;
            &#125;
            public void checkClientTrusted(X509Certificate[] certs, String authType) &#123;
                &#x2F;&#x2F; don&#39;t check
            &#125;
            public void checkServerTrusted(X509Certificate[] certs, String authType) &#123;
                &#x2F;&#x2F; don&#39;t check
            &#125;
        &#125;
    &#125;;
     
    SSLContext ctx &#x3D; SSLContext.getInstance(&quot;TLS&quot;);
    ctx.init(null, trustAllCerts, null);
     
    LayeredConnectionSocketFactory sslSocketFactory &#x3D; new SSLConnectionSocketFactory(ctx);
     
    CloseableHttpClient httpclient &#x3D; HttpClients.custom()
            .setSSLSocketFactory(sslSocketFactory)
            .build();
     
    HttpGet request &#x3D; new HttpGet(url);
    request.setHeader(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) ...&quot;);
     
    CloseableHttpResponse response &#x3D; httpclient.execute(request);
    String responseBody &#x3D; readResponseBody(response);
    System.out.println(responseBody);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们新建了一个匿名类，继承自 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html#X509TrustManager"><code>X509TrustManager</code></a> 接口，这个接口提供了三个方法用于验证证书的有效性：<code>getAcceptedIssuers</code>、<code>checkClientTrusted</code>、<code>checkServerTrusted</code>，我们在验证的函数中直接返回，不做任何校验，这样在访问 HTTPS 站点时，就算是证书不可信，也不会抛出异常，可以继续执行下去。</p>
<p>这种方法虽然简单，但是却有一个最严重的问题，就是不安全。因为不对证书做任何合法性校验，而且这种处理是全局性的，不管青红皂白，所有的证书都不会做验证，所以就算遇到不信任的证书，代码依然会继续与之通信，至于通信的数据安全不安全就不能保证了。所以如果你只是想在测试环境做个实验，那没问题，但是如果你要将代码发布到生产环境，请慎重。</p>
<h2 id="四、使用证书"><a href="#四、使用证书" class="headerlink" title="四、使用证书"></a>四、使用证书</h2><p>对于有些证书，我们基本上确定是可以信任的，但是这些证书又不在 Java 的 cacerts 文件中，譬如 12306 网站，或者使用了 Let’s Encrypt 证书的一些网站，对于这些网站，我们可以将其添加到信任列表中，而不是使用上面的方法统统都相信，这样程序的安全性仍然可以得到保障。</p>
<h3 id="4-1-使用-keytool-导入证书"><a href="#4-1-使用-keytool-导入证书" class="headerlink" title="4.1 使用 keytool 导入证书"></a>4.1 使用 keytool 导入证书</h3><p>简单的做法是将这些网站的证书导入到 cacerts 文件中，这样 Java 程序在校验证书的时候就可以从 cacerts 文件中找到并成功校验这个证书了。上面我们介绍过 JRE 自带的 keytool 这个工具，这个工具小巧而强悍，拥有很多功能。首先我们可以使用它查看 KeyStore 文件，使用下面的命令可以列出 KeyStore 文件中的所有内容（包括证书、私钥等）：</p>
<pre class="line-numbers language-none"><code class="language-none">$ keytool -list -keystore cacerts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后通过下面的命令，将证书导入到 cacerts 文件中：</p>
<pre class="line-numbers language-none"><code class="language-none">$ keytool -import -alias 12306 -keystore cacerts -file 12306.cer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>要想将网站的证书导入 cacerts 文件中，首先要获取网站的证书，譬如上面命令中的 12306.cer 文件，它是使用浏览器的证书导出向导保存的。如下图所示：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2016/04/898222994.png" alt="export-cert.png"></p>
<p>关于 keytool 的更多用法，可以参考 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool 的官网手册</a>，SSLShopper 上也有一篇文章列出了<a target="_blank" rel="noopener" href="https://www.sslshopper.com/article-most-common-java-keytool-keystore-commands.html">常用的 keytool 命令</a>。</p>
<h3 id="4-2-使用-KeyStore-动态加载证书"><a href="#4-2-使用-KeyStore-动态加载证书" class="headerlink" title="4.2 使用 KeyStore 动态加载证书"></a>4.2 使用 KeyStore 动态加载证书</h3><p>使用 keytool 导入证书，这种方法不仅简单，而且保证了代码的安全性，最关键的是代码不用做任何修改。所以我比较推荐这种方法。但是这种方法有一个致命的缺陷，那就是你需要修改 JRE 目录下的文件，如果你的程序只是在自己的电脑上运行，那倒没什么，可如果你的程序要部署在其他人的电脑上或者公司的服务器上，而你没有权限修改 JRE 目录下的文件，这该怎么办？如果你的程序是一个分布式的程序要部署在成百上千台机器上，难道还得修改每台机器的 JRE 文件吗？好在我们还有另一种通过编程的手段来实现的思路，在代码中动态的加载 KeyStore 文件来完成证书的校验，抱着知其然知其所以然的态度，我们在最后也实践下这种方法。通过编写代码可以更深刻的了解 <code>KeyStore</code>、<code>TrustManagerFactory</code>、<code>SSLContext</code> 以及 <code>SSLSocketFactory</code> 这几个类之间的关系。</p>
<pre class="line-numbers language-none"><code class="language-none">@Test
public void basicHttpsGetUsingSslSocketFactory() throws Exception &#123;
 
    String keyStoreFile &#x3D; &quot;D:\\code\\ttt.ks&quot;;
    String password &#x3D; &quot;poiuyt&quot;;
    KeyStore ks &#x3D; KeyStore.getInstance(KeyStore.getDefaultType());
    FileInputStream in &#x3D; new FileInputStream(keyStoreFile);
    ks.load(in, password.toCharArray());
     
    System.out.println(KeyStore.getDefaultType().toString());
    System.out.println(TrustManagerFactory.getDefaultAlgorithm().toString());
     
    TrustManagerFactory tmf &#x3D; TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(ks);
    SSLContext ctx &#x3D; SSLContext.getInstance(&quot;TLS&quot;);
    ctx.init(null, tmf.getTrustManagers(), null);
     
    LayeredConnectionSocketFactory sslSocketFactory &#x3D; new SSLConnectionSocketFactory(ctx);
     
    String url &#x3D; &quot;https:&#x2F;&#x2F;ttt.aneasystone.com&quot;;
     
    &#x2F;**
     * Return the page with content:
     *     401 Authorization Required
     *&#x2F;
     
    CloseableHttpClient httpclient &#x3D; HttpClients.custom()
            .setSSLSocketFactory(sslSocketFactory)
            .build();
     
    HttpGet request &#x3D; new HttpGet(url);
    request.setHeader(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) ...&quot;);
     
    CloseableHttpResponse response &#x3D; httpclient.execute(request);
    String responseBody &#x3D; readResponseBody(response);
    System.out.println(responseBody);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的代码使用了 HttpClient ，如果是使用 HttpsURLConnection 只需要改动下面两行即可：</p>
<pre class="line-numbers language-none"><code class="language-none">HttpsURLConnection con &#x3D; (HttpsURLConnection) obj.openConnection();
con.setSSLSocketFactory(ctx.getSocketFactory());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>最后的最后，我们还可以通过下面的属性来指定 trustStore ，这样也不需要编写像上面那样大量繁琐的代码，另外，参考我前面的博客，这些属性还可以通过 JVM 的参数来设置。</p>
<pre class="line-numbers language-none"><code class="language-none">System.setProperty(&quot;javax.net.ssl.trustStore&quot;, &quot;D:\\code\\ttt.ks&quot;);
System.setProperty(&quot;javax.net.ssl.trustStorePassword&quot;, &quot;poiuyt&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们的 HTTPS 之旅就要告一段落了。在学习 HTTPS 的过程中，我时时不经意的会被 HTTPS 中的一些技术或技巧感触到，特别是证书的认证过程以及非对称加密算法的原理，真的是积累了人类无穷的智慧，让人不得不感叹数学的美妙。而在学习过程中越是刨根问底，越是一发不可收拾，中间牵扯到的细节太多，太深入反而让人不自觉的迷失了方向。这篇博客断断续续的写了一个多月，慢慢的自己也是从对 HTTPS 一知半解，到现在的初窥门径。写的越多，越发觉自己很多东西不清楚，看得资料越多，越是不敢写，怕写错。这篇博客参考资料众多，质量也参差不齐，不能说对读者会起什么作用，但是确实是在我学习过程中帮我理清了很多思路。在这里对这些博客的原作者表示感谢。同时，如果你发现本篇博客中存在什么问题或错误，欢迎斧正。</p>
<p>共勉。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://publib.boulder.ibm.com/tividd/td/TRM/SC23-4822-00/zh_CN/HTML/user277.htm">SSL 如何工作</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002963044">SSL&#x2F;TLS 协议简介与实例分析</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002554673">SSL&#x2F;TLS原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://imququ.com/post/optimize-tls-handshake.html">TLS 握手优化详解</a></li>
<li><a target="_blank" rel="noopener" href="https://imququ.com/post/how-to-decrypt-https.html">三种解密 HTTPS 流量的方法介绍</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">图解SSL&#x2F;TLS协议</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL&#x2F;TLS协议运行机制的概述</a></li>
<li><a target="_blank" rel="noopener" href="http://www.oschina.net/news/26228/how-to-config-https">HTTPS 从原理到实战</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html">HTTPS工作原理和TCP握手机制</a></li>
<li><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html">扫盲 HTTPS 和 SSL&#x2F;TLS 协议</a></li>
<li><a target="_blank" rel="noopener" href="http://www.guokr.com/post/114121/">HTTPS那些事（一）HTTPS原理</a></li>
<li><a target="_blank" rel="noopener" href="http://www.lupaworld.com/article-252898-1.html">理解HTTPS协议</a></li>
<li><a target="_blank" rel="noopener" href="http://drops.wooyun.org/tips/6002">SSL&#x2F;TLS协议安全系列：SSL&#x2F;TLS概述</a></li>
<li><a target="_blank" rel="noopener" href="http://www.pixelstech.net/article/1408345768-Different-types-of-keystore-in-Java----Overview">Different types of keystore in Java – Overview</a></li>
<li><a target="_blank" rel="noopener" href="http://www.pixelstech.net/article/1409966488-Different-types-of-keystore-in-Java----JKS">Different types of keystore in Java – JKS</a></li>
<li><a target="_blank" rel="noopener" href="http://www.binghe.org/2010/03/use-httpsurlconnection-in-java/">Java中用HttpsURLConnection访问Https链接的问题</a></li>
<li><a target="_blank" rel="noopener" href="http://superuser.com/questions/411909/where-is-the-certificate-folder-in-windows-7">Where is the certificate folder in Windows 7?</a></li>
<li><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html">数字证书及 CA 的扫盲介绍</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html">数字证书原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.cnbluebox.com/blog/2014/03/24/shu-zi-zheng-shu/">数字证书</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.chenxiaosheng.com/posts/2013-12-26/java-use-self_signed_certificate.html">Java 使用自签证书访问https站点</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jayxon.com/12306-certificate/">12306的证书问题</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a></li>
<li><a target="_blank" rel="noopener" href="http://www.xieyidian.com/3213">在线买火车票为什么要安装根证书？</a></li>
<li><a target="_blank" rel="noopener" href="http://snowolf.iteye.com/blog/391931">Java加密技术（八）——数字证书</a></li>
<li><a target="_blank" rel="noopener" href="http://snowolf.iteye.com/blog/397693">Java加密技术（九）——初探SSL</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/lzjsky/archive/2010/09/29/1838240.html">常见的数字证书格式</a></li>
<li><a target="_blank" rel="noopener" href="http://lukejin.iteye.com/blog/605634">keyStore vs trustStore</a></li>
<li><a target="_blank" rel="noopener" href="http://javarevisited.blogspot.jp/2012/09/difference-between-truststore-vs-keyStore-Java-SSL.html">Difference between trustStore and keyStore in Java - SSL</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html">Java Secure Socket Extension (JSSE) Reference Guide</a></li>
<li><a target="_blank" rel="noopener" href="http://www.nakov.com/blog/2009/07/16/disable-certificate-validation-in-java-ssl-connections/">Disable Certificate Validation in Java SSL Connections</a></li>
<li><a target="_blank" rel="noopener" href="http://www.java-samples.com/showtutorial.php?tutorialid=210">javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed</a></li>
<li><a target="_blank" rel="noopener" href="http://wsigrid.blogspot.jp/2008/12/how-to-solve-javaxnetsslsslhandshakeexc.html">How to solve javax.net.ssl.SSLHandshakeException?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sslshopper.com/ssl-converter.html">SSL Converter</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sslshopper.com/article-most-common-java-keytool-keystore-commands.html">The Most Common Java Keytool Keystore Commands</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool - Key and Certificate Management Tool</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.mpoom.cn">逐光</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.mpoom.cn/2020/07/09/java/java-he-http-de-na-xie-shi-si-https-he-zheng-shu/">https://www.mpoom.cn/2020/07/09/java/java-he-http-de-na-xie-shi-si-https-he-zheng-shu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.mpoom.cn" target="_blank">逐光の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Https/">Https</a><a class="post-meta__tags" href="/tags/%E8%AF%81%E4%B9%A6/">证书</a></div><div class="post_share"><div class="social-share" data-image="/images/feature/11.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/13/nginx/nginx-fan-xiang-dai-li-404-wen-ti/" title="Nginx反向代理404问题"><img class="cover" src="/images/feature/17.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx反向代理404问题</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/24/nginx/nginx-chi-xian-an-zhuang/" title="Nginx离线安装"><img class="cover" src="/images/feature/1.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Nginx离线安装</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/19/linux/linux-zhong-de-commitlimit-yu-oomkiller/" title="Linux中的CommitLimit与OOM Killer"><img class="cover" src="/images/feature/7.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-19</div><div class="title">Linux中的CommitLimit与OOM Killer</div></div></a></div><div><a href="/2020/11/30/linux/yi-ci-java-jin-cheng-wu-li-nei-cun-zhan-yong-chao-guo-zui-da-dui-nei-cun-fen-xi/" title="一次Java进程物理内存占用超过最大堆内存分析"><img class="cover" src="/images/feature/0.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-30</div><div class="title">一次Java进程物理内存占用超过最大堆内存分析</div></div></a></div><div><a href="/2020/11/19/linux/tu-ran-xiao-shi-de-java-jin-cheng/" title="突然消失的Java进程"><img class="cover" src="/images/feature/19.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-19</div><div class="title">突然消失的Java进程</div></div></a></div><div><a href="/2019/07/06/java/concurrenthashmap-yuan-ma-jie-xi/" title="ConcurrentHashMap源码解析"><img class="cover" src="/images/feature/10.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-07-06</div><div class="title">ConcurrentHashMap源码解析</div></div></a></div><div><a href="/2019/07/06/java/hashmap-yuan-ma-jie-xi/" title="HashMap源码解析"><img class="cover" src="/images/feature/7.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-07-06</div><div class="title">HashMap源码解析</div></div></a></div><div><a href="/2021/12/28/java/intellij-idea-kuai-jie-jian-shi-yong/" title="IntelliJ IDEA快捷键使用"><img class="cover" src="/images/feature/8.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-28</div><div class="title">IntelliJ IDEA快捷键使用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%BF%E9%97%AE-HTTPS-%E7%AB%99%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">一、访问 HTTPS 站点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BD%BF%E7%94%A8-HttpURLConnection"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 使用 HttpURLConnection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8-HttpClient"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 使用 HttpClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%81%AD%E9%81%87-PKIX-path-building-failed"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 遭遇 PKIX path building failed</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">二、证书认证的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-SSL-TLS-%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 SSL&#x2F;TLS 协议及其握手过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-HTTPS-%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 HTTPS 中的密码学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%85%B3%E4%BA%8E%E8%AF%81%E4%B9%A6"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 关于证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%85%B3%E4%BA%8E-Java-%E9%87%8C%E7%9A%84%E8%AF%81%E4%B9%A6"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 关于 Java 里的证书</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89-TrustManager-%E7%BB%95%E8%BF%87%E8%AF%81%E4%B9%A6%E6%A3%80%E6%9F%A5"><span class="toc-number">3.</span> <span class="toc-text">三、自定义 TrustManager 绕过证书检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%81%E4%B9%A6"><span class="toc-number">4.</span> <span class="toc-text">四、使用证书</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BD%BF%E7%94%A8-keytool-%E5%AF%BC%E5%85%A5%E8%AF%81%E4%B9%A6"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 使用 keytool 导入证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BD%BF%E7%94%A8-KeyStore-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%AF%81%E4%B9%A6"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 使用 KeyStore 动态加载证书</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 逐光</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div class="icp"><span><img src="/images/theme/icp_icon.png"/><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">陕ICP备19021337号-1</span></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'f5WSKiyRgMriw1qIicgn1Dbu-gzGzoHsz',
      appKey: 'c9Jx92rNNJ0RzzaxLNCqu4rR',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>((window.gitter = {}).chat = {}).options = {
  room: 'blog-mpoom/community',
};

if (false) {
  function chatBtnHide () {
    document.getElementsByClassName('gitter-open-chat-button')[0].style.display= 'none'
  }

  function chatBtnShow () {
    document.getElementsByClassName('gitter-open-chat-button')[0].style.display= 'block'
  }
}
</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="async" defer="defer"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>